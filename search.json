[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": ".",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "reference/expr.schema.Schema.html",
    "href": "reference/expr.schema.Schema.html",
    "title": "expr.schema.Schema",
    "section": "",
    "text": "expr.schema.Schema()\nAn object for holding table schema information.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfields\nA mapping of [str][str] to [DataType][ibis.expr.datatypes.DataType] objects\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nequals\nReturn whether other is equal to self.\n\n\nfrom_dask\nReturn the equivalent ibis schema.\n\n\nfrom_numpy\nReturn the equivalent ibis schema.\n\n\nfrom_pandas\nReturn the equivalent ibis schema.\n\n\nfrom_pyarrow\nReturn the equivalent ibis schema.\n\n\nfrom_tuples\nConstruct a Schema from an iterable of pairs.\n\n\nname_at_position\nReturn the name of a schema column at position i.\n\n\nto_dask\nReturn the equivalent dask dtypes.\n\n\nto_numpy\nReturn the equivalent numpy dtypes.\n\n\nto_pandas\nReturn the equivalent pandas datatypes.\n\n\nto_pyarrow\nReturn the equivalent pyarrow schema.\n\n\n\n\n\nexpr.schema.Schema.equals(self, other)\nReturn whether other is equal to self.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nSchema\nSchema to compare self to.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; first = ibis.schema({\"a\": \"int\"})\n&gt;&gt;&gt; second = ibis.schema({\"a\": \"int\"})\n&gt;&gt;&gt; assert first.equals(second)\n&gt;&gt;&gt; third = ibis.schema({\"a\": \"array&lt;int&gt;\"})\n&gt;&gt;&gt; assert not first.equals(third)\n\n\n\n\nexpr.schema.Schema.from_dask(cls, dask_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_numpy(cls, numpy_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_pandas(cls, pandas_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_pyarrow(cls, pyarrow_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_tuples(cls, values)\nConstruct a Schema from an iterable of pairs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\ncollections.abc.Iterable[tuple[str, str | ibis.DataType]]\nAn iterable of pairs of name and type.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSchema\nA new schema\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.Schema.from_tuples([(\"a\", \"int\"), (\"b\", \"string\")])\nibis.Schema {\n  a  int64\n  b  string\n}\n\n\n\n\nexpr.schema.Schema.name_at_position(self, i)\nReturn the name of a schema column at position i.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ni\nint\nThe position of the column\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe name of the column in the schema at position i.\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; sch = ibis.Schema({\"a\": \"int\", \"b\": \"string\"})\n&gt;&gt;&gt; sch.name_at_position(0)\n'a'\n&gt;&gt;&gt; sch.name_at_position(1)\n'b'\n\n\n\n\nexpr.schema.Schema.to_dask(self)\nReturn the equivalent dask dtypes.\n\n\n\nexpr.schema.Schema.to_numpy(self)\nReturn the equivalent numpy dtypes.\n\n\n\nexpr.schema.Schema.to_pandas(self)\nReturn the equivalent pandas datatypes.\n\n\n\nexpr.schema.Schema.to_pyarrow(self)\nReturn the equivalent pyarrow schema."
  },
  {
    "objectID": "reference/expr.schema.Schema.html#attributes",
    "href": "reference/expr.schema.Schema.html#attributes",
    "title": "expr.schema.Schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nfields\nA mapping of [str][str] to [DataType][ibis.expr.datatypes.DataType] objects"
  },
  {
    "objectID": "reference/expr.schema.Schema.html#methods",
    "href": "reference/expr.schema.Schema.html#methods",
    "title": "expr.schema.Schema",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nequals\nReturn whether other is equal to self.\n\n\nfrom_dask\nReturn the equivalent ibis schema.\n\n\nfrom_numpy\nReturn the equivalent ibis schema.\n\n\nfrom_pandas\nReturn the equivalent ibis schema.\n\n\nfrom_pyarrow\nReturn the equivalent ibis schema.\n\n\nfrom_tuples\nConstruct a Schema from an iterable of pairs.\n\n\nname_at_position\nReturn the name of a schema column at position i.\n\n\nto_dask\nReturn the equivalent dask dtypes.\n\n\nto_numpy\nReturn the equivalent numpy dtypes.\n\n\nto_pandas\nReturn the equivalent pandas datatypes.\n\n\nto_pyarrow\nReturn the equivalent pyarrow schema.\n\n\n\n\n\nexpr.schema.Schema.equals(self, other)\nReturn whether other is equal to self.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nSchema\nSchema to compare self to.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; first = ibis.schema({\"a\": \"int\"})\n&gt;&gt;&gt; second = ibis.schema({\"a\": \"int\"})\n&gt;&gt;&gt; assert first.equals(second)\n&gt;&gt;&gt; third = ibis.schema({\"a\": \"array&lt;int&gt;\"})\n&gt;&gt;&gt; assert not first.equals(third)\n\n\n\n\nexpr.schema.Schema.from_dask(cls, dask_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_numpy(cls, numpy_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_pandas(cls, pandas_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_pyarrow(cls, pyarrow_schema)\nReturn the equivalent ibis schema.\n\n\n\nexpr.schema.Schema.from_tuples(cls, values)\nConstruct a Schema from an iterable of pairs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\ncollections.abc.Iterable[tuple[str, str | ibis.DataType]]\nAn iterable of pairs of name and type.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSchema\nA new schema\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.Schema.from_tuples([(\"a\", \"int\"), (\"b\", \"string\")])\nibis.Schema {\n  a  int64\n  b  string\n}\n\n\n\n\nexpr.schema.Schema.name_at_position(self, i)\nReturn the name of a schema column at position i.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ni\nint\nThe position of the column\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nThe name of the column in the schema at position i.\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; sch = ibis.Schema({\"a\": \"int\", \"b\": \"string\"})\n&gt;&gt;&gt; sch.name_at_position(0)\n'a'\n&gt;&gt;&gt; sch.name_at_position(1)\n'b'\n\n\n\n\nexpr.schema.Schema.to_dask(self)\nReturn the equivalent dask dtypes.\n\n\n\nexpr.schema.Schema.to_numpy(self)\nReturn the equivalent numpy dtypes.\n\n\n\nexpr.schema.Schema.to_pandas(self)\nReturn the equivalent pandas datatypes.\n\n\n\nexpr.schema.Schema.to_pyarrow(self)\nReturn the equivalent pyarrow schema."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "Reference",
    "section": "",
    "text": "Top-level APIs\nThese methods and objecst are available directly on the ibis module.\n\n\nTable Expressions\nTable expressions form the basis for most Ibis expressions.\n\n\nGeneric Expression APIs\nThese expressions are available on scalars and columns of any element type.\n\n\nNumeric and Boolean Expressions\nThese APIs are available on numeric and boolean expressions.\n\n\nString Expressions\nAll string operations are valid for both scalars and columns.\n\n\ntemporal\n\n\n\nComplex Type Expressions\nThese APIs are available on arrays, maps and structs.\n\n\nGeospatial Expressions\nIbis supports the following geospatial expression APIs\n\n\n\n\n\n\n\n\n\nselectors\nConvenient column selectors.\n\n\nexpr.schema.Schema\nAn object for holding table schema information.\n\n\nconfig.Options\nIbis configuration options.\n\n\nconfig.Repr\nExpression printing options.\n\n\nconfig.SQL\nSQL-related options.\n\n\nconfig.ContextAdjustment\nOptions related to time context adjustment.\n\n\nexpr.datatypes.core"
  },
  {
    "objectID": "reference/index.html#expressions",
    "href": "reference/index.html#expressions",
    "title": "Reference",
    "section": "",
    "text": "Top-level APIs\nThese methods and objecst are available directly on the ibis module.\n\n\nTable Expressions\nTable expressions form the basis for most Ibis expressions.\n\n\nGeneric Expression APIs\nThese expressions are available on scalars and columns of any element type.\n\n\nNumeric and Boolean Expressions\nThese APIs are available on numeric and boolean expressions.\n\n\nString Expressions\nAll string operations are valid for both scalars and columns.\n\n\ntemporal\n\n\n\nComplex Type Expressions\nThese APIs are available on arrays, maps and structs.\n\n\nGeospatial Expressions\nIbis supports the following geospatial expression APIs"
  },
  {
    "objectID": "reference/index.html#other",
    "href": "reference/index.html#other",
    "title": "Reference",
    "section": "",
    "text": "selectors\nConvenient column selectors.\n\n\nexpr.schema.Schema\nAn object for holding table schema information.\n\n\nconfig.Options\nIbis configuration options.\n\n\nconfig.Repr\nExpression printing options.\n\n\nconfig.SQL\nSQL-related options.\n\n\nconfig.ContextAdjustment\nOptions related to time context adjustment.\n\n\nexpr.datatypes.core"
  },
  {
    "objectID": "reference/expression-collections.html",
    "href": "reference/expression-collections.html",
    "title": "Complex Type Expressions",
    "section": "",
    "text": "These APIs are available on arrays, maps and structs."
  },
  {
    "objectID": "reference/expression-collections.html#methods",
    "href": "reference/expression-collections.html#methods",
    "title": "Complex Type Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncontains\nReturn whether the array contains other.\n\n\nfilter\nFilter array elements using predicate.\n\n\nindex\nReturn the position of other in an array.\n\n\njoin\nJoin the elements of this array expression with sep.\n\n\nlength\nCompute the length of an array.\n\n\nmap\nApply a callable func to each element of this array expression.\n\n\nremove\nRemove other from self.\n\n\nsort\nSort the elements in an array.\n\n\nunion\nUnion two arrays.\n\n\nunique\nReturn the unique values in an array.\n\n\nunnest\nFlatten an array into a column.\n\n\nzip\nZip two or more arrays together.\n\n\n\n\ncontains\nexpr.types.arrays.ArrayValue.contains(self, other)\nReturn whether the array contains other.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nibis.Value\nIbis expression to check for existence of in self\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether other is contained in self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[1], [], [42, 42], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [1]                  │\n│ []                   │\n│ [42, 42]             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.contains(42)\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayContains(arr, 42) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ False                  │\n│ False                  │\n│ True                   │\n│ NULL                   │\n└────────────────────────┘\n&gt;&gt;&gt; t.arr.contains(None)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayContains(arr, None) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                  │\n├──────────────────────────┤\n│ NULL                     │\n│ NULL                     │\n│ NULL                     │\n│ NULL                     │\n└──────────────────────────┘\n\n\n\nfilter\nexpr.types.arrays.ArrayValue.filter(self, predicate)\nFilter array elements using predicate.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npredicate\ntyping.Callable[[ibis.Value], ibis.BooleanValue]\nFunction to use to filter array elements\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nArray elements filtered using predicate\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [[1, None, 2], [4], []]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ a                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [1, None, ... +1]    │\n│ [4]                  │\n│ []                   │\n└──────────────────────┘\n&gt;&gt;&gt; t.a.filter(lambda x: x &gt; 1)\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayFilter(a)       ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [2]                  │\n│ [4]                  │\n│ []                   │\n└──────────────────────┘\n\n\n\nindex\nexpr.types.arrays.ArrayValue.index(self, other)\nReturn the position of other in an array.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nibis.Value\nIbis expression to existence of in self\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nThe position of other in self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[1], [], [42, 42], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [1]                  │\n│ []                   │\n│ [42, 42]             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.index(42)\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayPosition(arr, 42) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                  │\n├────────────────────────┤\n│                     -1 │\n│                     -1 │\n│                      0 │\n│                   NULL │\n└────────────────────────┘\n&gt;&gt;&gt; t.arr.index(800)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayPosition(arr, 800) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                   │\n├─────────────────────────┤\n│                      -1 │\n│                      -1 │\n│                      -1 │\n│                    NULL │\n└─────────────────────────┘\n&gt;&gt;&gt; t.arr.index(None)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayPosition(arr, None) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                    │\n├──────────────────────────┤\n│                     NULL │\n│                     NULL │\n│                     NULL │\n│                     NULL │\n└──────────────────────────┘\n\n\n\njoin\nexpr.types.arrays.ArrayValue.join(self, sep)\nJoin the elements of this array expression with sep.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr | ibis.StringValue\nSeparator to use for joining array elements\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nElements of self joined with sep\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[\"a\", \"b\", \"c\"], None, [], [\"b\", None]]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;string&gt;        │\n├──────────────────────┤\n│ ['a', 'b', ... +1]   │\n│ NULL                 │\n│ []                   │\n│ ['b', None]          │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.join(\"|\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayStringJoin('|', arr) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                    │\n├───────────────────────────┤\n│ a|b|c                     │\n│ NULL                      │\n│ NULL                      │\n│ b                         │\n└───────────────────────────┘\n\n\nSee Also\n[StringValue.join][ibis.expr.types.strings.StringValue.join]\n\n\n\nlength\nexpr.types.arrays.ArrayValue.length(self)\nCompute the length of an array.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe integer length of each element of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [[7, 42], [3], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ a                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [7, 42]              │\n│ [3]                  │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.a.length()\n┏━━━━━━━━━━━━━━━━┓\n┃ ArrayLength(a) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ int64          │\n├────────────────┤\n│              2 │\n│              1 │\n│           NULL │\n└────────────────┘\n\n\n\nmap\nexpr.types.arrays.ArrayValue.map(self, func)\nApply a callable func to each element of this array expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfunc\ntyping.Callable[[ibis.Value], ibis.Value]\nFunction to apply to each element of this array\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nfunc applied to every element of this array expression.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [[1, None, 2], [4], []]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ a                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [1, None, ... +1]    │\n│ [4]                  │\n│ []                   │\n└──────────────────────┘\n&gt;&gt;&gt; t.a.map(lambda x: (x + 100).cast(\"float\"))\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayMap(a)           ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;float64&gt;        │\n├───────────────────────┤\n│ [101.0, None, ... +1] │\n│ [104.0]               │\n│ []                    │\n└───────────────────────┘\n\n\n\nremove\nexpr.types.arrays.ArrayValue.remove(self, other)\nRemove other from self.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nibis.Value\nElement to remove from self.\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[3, 2], [], [42, 2], [2, 2], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [3, 2]               │\n│ []                   │\n│ [42, 2]              │\n│ [2, 2]               │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.remove(2)\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayRemove(arr, 2)  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [3]                  │\n│ []                   │\n│ [42]                 │\n│ []                   │\n│ NULL                 │\n└──────────────────────┘\n\n\n\nsort\nexpr.types.arrays.ArrayValue.sort(self)\nSort the elements in an array.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nSorted values in an array\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[3, 2], [], [42, 42], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [3, 2]               │\n│ []                   │\n│ [42, 42]             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.sort()\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArraySort(arr)       ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [2, 3]               │\n│ []                   │\n│ [42, 42]             │\n│ NULL                 │\n└──────────────────────┘\n\n\n\nunion\nexpr.types.arrays.ArrayValue.union(self, other)\nUnion two arrays.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nibis.ArrayValue\nAnother array to union with self\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nUnioned arrays\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr1\": [[3, 2], [], None], \"arr2\": [[1, 3], [None], [5]]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr1                 ┃ arr2                 ┃\n┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │ array&lt;int64&gt;         │\n├──────────────────────┼──────────────────────┤\n│ [3, 2]               │ [1, 3]               │\n│ []                   │ [None]               │\n│ NULL                 │ [5]                  │\n└──────────────────────┴──────────────────────┘\n&gt;&gt;&gt; t.arr1.union(t.arr2)\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayUnion(arr1, arr2) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;           │\n├────────────────────────┤\n│ [1, 2, ... +1]         │\n│ []                     │\n│ [5]                    │\n└────────────────────────┘\n&gt;&gt;&gt; t.arr1.union(t.arr2).contains(3)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayContains(ArrayUnion(arr1, arr2), 3) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                                  │\n├──────────────────────────────────────────┤\n│ True                                     │\n│ False                                    │\n│ False                                    │\n└──────────────────────────────────────────┘\n\n\n\nunique\nexpr.types.arrays.ArrayValue.unique(self)\nReturn the unique values in an array.\n!!! note “Element ordering in array may not be retained.”\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nUnique values in an array\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[1, 3, 3], [], [42, 42], None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [1, 3, ... +1]       │\n│ []                   │\n│ [42, 42]             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.arr.unique()\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayDistinct(arr)   ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [3, 1]               │\n│ []                   │\n│ [42]                 │\n│ NULL                 │\n└──────────────────────┘\n\n\n\nunnest\nexpr.types.arrays.ArrayValue.unnest(self)\nFlatten an array into a column.\n!!! note “This operation changes the cardinality of the result”\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [[7, 42], [3, 3] , None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ a                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │\n├──────────────────────┤\n│ [7, 42]              │\n│ [3, 3]               │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.a.unnest()\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     7 │\n│    42 │\n│     3 │\n│     3 │\n└───────┘\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nibis.Value\nUnnested array\n\n\n\n\n\n\nzip\nexpr.types.arrays.ArrayValue.zip(self, other, *others)\nZip two or more arrays together.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nibis.Array\nAnother array to zip with self\nrequired\n\n\nothers\nibis.Array\nAdditional arrays to zip with self\n()\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nArray\nArray of structs where each struct field is an element of each input array.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"numbers\": [[3, 2], [], None], \"strings\": [[\"a\", \"c\"], None, [\"e\"]]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓\n┃ numbers              ┃ strings              ┃\n┡━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;int64&gt;         │ array&lt;string&gt;        │\n├──────────────────────┼──────────────────────┤\n│ [3, 2]               │ ['a', 'c']           │\n│ []                   │ NULL                 │\n│ NULL                 │ ['e']                │\n└──────────────────────┴──────────────────────┘\n&gt;&gt;&gt; expr = t.numbers.zip(t.strings)\n&gt;&gt;&gt; expr\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayZip()                           ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;struct&lt;f1: int64, f2: string&gt;&gt; │\n├──────────────────────────────────────┤\n│ [{...}, {...}]                       │\n│ []                                   │\n│ [{...}]                              │\n└──────────────────────────────────────┘\n&gt;&gt;&gt; expr.unnest()\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayZip()                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ struct&lt;f1: int64, f2: string&gt; │\n├───────────────────────────────┤\n│ {'f1': 3, 'f2': 'a'}          │\n│ {'f1': 2, 'f2': 'c'}          │\n│ {'f1': None, 'f2': 'e'}       │\n└───────────────────────────────┘"
  },
  {
    "objectID": "reference/expression-collections.html#examples-12",
    "href": "reference/expression-collections.html#examples-12",
    "title": "Complex Type Expressions",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({'s': [{'a': 1, 'b': 'foo'}, {'a': 3, 'b': None}, None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ s                           ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ struct&lt;a: int64, b: string&gt; │\n├─────────────────────────────┤\n│ {'a': 1, 'b': 'foo'}        │\n│ {'a': 3, 'b': None}         │\n│ NULL                        │\n└─────────────────────────────┘\nCan use either . or [] to access fields:\n&gt;&gt;&gt; t.s.a\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     3 │\n│  NULL │\n└───────┘\n&gt;&gt;&gt; t.s['a']\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     3 │\n│  NULL │\n└───────┘"
  },
  {
    "objectID": "reference/expression-collections.html#attributes",
    "href": "reference/expression-collections.html#attributes",
    "title": "Complex Type Expressions",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\nfields\nReturn a mapping from field name to field type of the struct.\n\n\nnames\nReturn the field names of the struct.\n\n\ntypes\nReturn the field types of the struct."
  },
  {
    "objectID": "reference/expression-collections.html#methods-1",
    "href": "reference/expression-collections.html#methods-1",
    "title": "Complex Type Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ndestructure\nDestructure a StructValue into the corresponding struct fields.\n\n\nlift\nProject the fields of self into a table.\n\n\n\n\ndestructure\nexpr.types.structs.StructValue.destructure(self)\nDestructure a StructValue into the corresponding struct fields.\nWhen assigned, a destruct value will be destructured and assigned to multiple columns.\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nlist[AnyValue]\nValue expressions corresponding to the struct fields.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({'s': [{'a': 1, 'b': 'foo'}, {'a': 3, 'b': None}, None]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ s                           ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ struct&lt;a: int64, b: string&gt; │\n├─────────────────────────────┤\n│ {'a': 1, 'b': 'foo'}        │\n│ {'a': 3, 'b': None}         │\n│ NULL                        │\n└─────────────────────────────┘\n&gt;&gt;&gt; a, b = t.s.destructure()\n&gt;&gt;&gt; a\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     3 │\n│  NULL │\n└───────┘\n&gt;&gt;&gt; b\n┏━━━━━━━━┓\n┃ b      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ foo    │\n│ NULL   │\n│ NULL   │\n└────────┘\n\n\n\nlift\nexpr.types.structs.StructValue.lift(self)\nProject the fields of self into a table.\nThis method is useful when analyzing data that has deeply nested structs or arrays of structs. lift can be chained to avoid repeating column names and table references.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA projection with this struct expression’s fields.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable(\n...     {\n...         \"pos\": [\n...             {\"lat\": 10.1, \"lon\": 30.3},\n...             {\"lat\": 10.2, \"lon\": 30.2},\n...             {\"lat\": 10.3, \"lon\": 30.1},\n...         ]\n...     }\n... )\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ pos                                ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ struct&lt;lat: float64, lon: float64&gt; │\n├────────────────────────────────────┤\n│ {'lat': 10.1, 'lon': 30.3}         │\n│ {'lat': 10.2, 'lon': 30.2}         │\n│ {'lat': 10.3, 'lon': 30.1}         │\n└────────────────────────────────────┘\n&gt;&gt;&gt; t.pos.lift()\n┏━━━━━━━━━┳━━━━━━━━━┓\n┃ lat     ┃ lon     ┃\n┡━━━━━━━━━╇━━━━━━━━━┩\n│ float64 │ float64 │\n├─────────┼─────────┤\n│    10.1 │    30.3 │\n│    10.2 │    30.2 │\n│    10.3 │    30.1 │\n└─────────┴─────────┘\n\n\nSee Also\n[Table.unpack][ibis.expr.types.relations.Table.unpack]."
  },
  {
    "objectID": "reference/expression-collections.html#examples-15",
    "href": "reference/expression-collections.html#examples-15",
    "title": "Complex Type Expressions",
    "section": "Examples",
    "text": "Examples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; tab = pa.table({\n...    \"m\": pa.array([[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...                  type=pa.map_(pa.utf8(), pa.int64()))})\n&gt;&gt;&gt; t = ibis.memtable(tab)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ m                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ map&lt;!string, int64&gt;  │\n├──────────────────────┤\n│ {'a': 1, 'b': 2}     │\n│ {'a': 1}             │\n│ NULL                 │\n└──────────────────────┘\nCan use [] to access values:\n&gt;&gt;&gt; t.m['a']\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ MapGet(m, 'a', None) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                │\n├──────────────────────┤\n│                    1 │\n│                    1 │\n│                 NULL │\n└──────────────────────┘\nTo provide default values, use get:\n&gt;&gt;&gt; t.m.get('b', 0)\n┏━━━━━━━━━━━━━━━━━━━┓\n┃ MapGet(m, 'b', 0) ┃\n┡━━━━━━━━━━━━━━━━━━━┩\n│ int64             │\n├───────────────────┤\n│                 2 │\n│                 0 │\n│                 0 │\n└───────────────────┘"
  },
  {
    "objectID": "reference/expression-collections.html#methods-2",
    "href": "reference/expression-collections.html#methods-2",
    "title": "Complex Type Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\ncontains\nReturn whether the map contains key.\n\n\nget\nReturn the value for key from expr.\n\n\nkeys\nExtract the keys of a map.\n\n\nlength\nReturn the number of key-value pairs in the map.\n\n\nvalues\nExtract the values of a map.\n\n\n\n\ncontains\nexpr.types.maps.MapValue.contains(self, key)\nReturn whether the map contains key.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nint | str | ibis.IntegerValue | ibis.StringValue\nMapping key for which to check\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nBoolean indicating the presence of key in the map expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; tab = pa.table({\n...    \"m\": pa.array([[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...                  type=pa.map_(pa.utf8(), pa.int64()))})\n&gt;&gt;&gt; t = ibis.memtable(tab)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ m                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ map&lt;!string, int64&gt;   │\n├──────────────────────┤\n│ {'a': 1, 'b': 2}     │\n│ {'a': 1}             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.contains(\"b\")\n┏━━━━━━━━━━━━━━━━━━━━━┓\n┃ MapContains(m, 'b') ┃\n┡━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean             │\n├─────────────────────┤\n│ True                │\n│ False               │\n│ False               │\n└─────────────────────┘\n\n\n\nget\nexpr.types.maps.MapValue.get(self, key, default=None)\nReturn the value for key from expr.\nReturn default if key is not in the map.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nibis.Value\nExpression to use for key\nrequired\n\n\ndefault\nibis.Value | None\nExpression to return if key is not a key in expr\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nThe element type of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; tab = pa.table({\n...    \"m\": pa.array([[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...                  type=pa.map_(pa.utf8(), pa.int64()))})\n&gt;&gt;&gt; t = ibis.memtable(tab)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ m                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ map&lt;!string, int64&gt;  │\n├──────────────────────┤\n│ {'a': 1, 'b': 2}     │\n│ {'a': 1}             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.get(\"a\")\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ MapGet(m, 'a', None) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                │\n├──────────────────────┤\n│                    1 │\n│                    1 │\n│                 NULL │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.get(\"b\")\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ MapGet(m, 'b', None) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64                │\n├──────────────────────┤\n│                    2 │\n│                 NULL │\n│                 NULL │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.get(\"b\", 0)\n┏━━━━━━━━━━━━━━━━━━━┓\n┃ MapGet(m, 'b', 0) ┃\n┡━━━━━━━━━━━━━━━━━━━┩\n│ int64             │\n├───────────────────┤\n│                 2 │\n│                 0 │\n│                 0 │\n└───────────────────┘\n\n\n\nkeys\nexpr.types.maps.MapValue.keys(self)\nExtract the keys of a map.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nThe keys of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; tab = pa.table({\n...    \"m\": pa.array([[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...                  type=pa.map_(pa.utf8(), pa.int64()))})\n&gt;&gt;&gt; t = ibis.memtable(tab)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ m                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ map&lt;!string, int64&gt;  │\n├──────────────────────┤\n│ {'a': 1, 'b': 2}     │\n│ {'a': 1}             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.keys()\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ MapKeys(m)           ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;!string&gt;       │\n├──────────────────────┤\n│ ['a', 'b']           │\n│ ['a']                │\n│ NULL                 │\n└──────────────────────┘\n\n\n\nlength\nexpr.types.maps.MapValue.length(self)\nReturn the number of key-value pairs in the map.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe number of elements in self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import pyarrow as pa\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; tab = pa.table({\n...    \"m\": pa.array([[(\"a\", 1), (\"b\", 2)], [(\"a\", 1)], None],\n...                  type=pa.map_(pa.utf8(), pa.int64()))})\n&gt;&gt;&gt; t = ibis.memtable(tab)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ m                    ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ map&lt;!string, int64&gt;  │\n├──────────────────────┤\n│ {'a': 1, 'b': 2}     │\n│ {'a': 1}             │\n│ NULL                 │\n└──────────────────────┘\n&gt;&gt;&gt; t.m.length()\n┏━━━━━━━━━━━━━━┓\n┃ MapLength(m) ┃\n┡━━━━━━━━━━━━━━┩\n│ int64        │\n├──────────────┤\n│            2 │\n│            1 │\n│         NULL │\n└──────────────┘\n\n\n\nvalues\nexpr.types.maps.MapValue.values(self)\nExtract the values of a map.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nThe values of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; m = ibis.map({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; m.values()\n[1, 2]"
  },
  {
    "objectID": "reference/config.SQL.html",
    "href": "reference/config.SQL.html",
    "title": "config.SQL",
    "section": "",
    "text": "config.SQL()\nSQL-related options.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndefault_limit\nint | None\nNumber of rows to be retrieved for a table expression without an explicit limit. [None][None] means no limit.\n\n\ndefault_dialect\nstr\nDialect to use for printing SQL when the backend cannot be determined."
  },
  {
    "objectID": "reference/config.SQL.html#attributes",
    "href": "reference/config.SQL.html#attributes",
    "title": "config.SQL",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndefault_limit\nint | None\nNumber of rows to be retrieved for a table expression without an explicit limit. [None][None] means no limit.\n\n\ndefault_dialect\nstr\nDialect to use for printing SQL when the backend cannot be determined."
  },
  {
    "objectID": "reference/selectors.html",
    "href": "reference/selectors.html",
    "title": "selectors",
    "section": "",
    "text": "selectors\nConvenient column selectors.\n!!! tip “Check out the blog post on selectors for examples!”\n\n\nColumn selectors are convenience functions for selecting columns that share some property.\n\n\n\nFor example, a common task is to be able to select all numeric columns for a subsequent computation.\nWithout selectors this becomes quite verbose and tedious to write:\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; t = ibis.table(...)  # doctest: +SKIP\n&gt;&gt;&gt; t.select([t[c] for c in t.columns if t[c].type().is_numeric()])  # doctest: +SKIP\nCompare that to the [numeric][ibis.selectors.numeric] selector:\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t.select(s.numeric())  # doctest: +SKIP\nWhen there are multiple properties to check it gets worse:\n&gt;&gt;&gt; t.select(  # doctest: +SKIP\n...     [\n...         t[c] for c in t.columns\n...         if t[c].type().is_numeric()\n...         if (\"a\" in c or \"cd\" in c)\n...     ]\n... )\nUsing a composition of selectors this is much less tiresome:\n&gt;&gt;&gt; t.select(s.numeric() & s.contains((\"a\", \"cd\")))  # doctest: +SKIP\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nSelector\nA column selector.\n\n\n\n\n\nselectors.Selector()\nA column selector.\n\n\n\n\n\nName\nDescription\n\n\n\n\nexpand\nExpand table into a sequence of value expressions.\n\n\n\n\n\nselectors.Selector.expand(self, table)\nExpand table into a sequence of value expressions.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable\nibis.Table\nAn ibis table expression\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntyping.Sequence[Value]\nA sequence of value expressions\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nacross\nApply data transformations across multiple columns.\n\n\nall\nReturn every column from a table.\n\n\nall_of\nInclude columns satisfying all of predicates.\n\n\nany_of\nInclude columns satisfying any of predicates.\n\n\nc\nSelect specific column names.\n\n\ncontains\nReturn columns whose name contains needles.\n\n\nendswith\nSelect columns whose name ends with one of suffixes.\n\n\nfirst\nReturn the first column of a table.\n\n\nif_all\nReturn the conjunction of predicate applied on all selector columns.\n\n\nif_any\nReturn the disjunction of predicate applied on all selector columns.\n\n\nlast\nReturn the last column of a table.\n\n\nmatches\nReturn columns whose name matches the regular expression regex.\n\n\nnumeric\nReturn numeric columns.\n\n\nof_type\nSelect columns of type dtype.\n\n\nstartswith\nSelect columns whose name starts with one of prefixes.\n\n\nwhere\nSelect columns that satisfy predicate.\n\n\n\n\n\nselectors.across(selector, func, names=None)\nApply data transformations across multiple columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nibis.selectors.Selector | typing.Iterable[str] | str\nAn expression that selects columns on which the transformation function will be applied, an iterable of str column names or a single str column name.\nrequired\n\n\nfunc\nibis.expr.deferred.Deferred | typing.Callable[[ibis.Value], ibis.Value] | typing.Mapping[str | None, ibis.expr.deferred.Deferred | typing.Callable[[ibis.Value], ibis.Value]]\nA function (or dictionary of functions) to use to transform the data.\nrequired\n\n\nnames\nstr | typing.Callable[[str, str | None], str] | None\nA lambda function or a format string to name the columns created by the transformation function.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nAcross\nAn Across selector object\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from ibis import _, selectors as s\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.select(s.startswith(\"bill\")).mutate(\n...     s.across(\n...         s.numeric(),\n...         dict(centered =_ - _.mean()),\n...         names = \"{fn}_{col}\"\n...     )\n... )\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ centered_bill_length_mm ┃ … ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ float64        │ float64       │ float64                 │ … │\n├────────────────┼───────────────┼─────────────────────────┼───┤\n│           39.1 │          18.7 │                -4.82193 │ … │\n│           39.5 │          17.4 │                -4.42193 │ … │\n│           40.3 │          18.0 │                -3.62193 │ … │\n│            nan │           nan │                     nan │ … │\n│           36.7 │          19.3 │                -7.22193 │ … │\n│           39.3 │          20.6 │                -4.62193 │ … │\n│           38.9 │          17.8 │                -5.02193 │ … │\n│           39.2 │          19.6 │                -4.72193 │ … │\n│           34.1 │          18.1 │                -9.82193 │ … │\n│           42.0 │          20.2 │                -1.92193 │ … │\n│              … │             … │                       … │ … │\n└────────────────┴───────────────┴─────────────────────────┴───┘\n\n\n\n\nselectors.all()\nReturn every column from a table.\n\n\n\nselectors.all_of(*predicates)\nInclude columns satisfying all of predicates.\n\n\n\nselectors.any_of(*predicates)\nInclude columns satisfying any of predicates.\n\n\n\nselectors.c(*names)\nSelect specific column names.\n\n\n\nselectors.contains(needles, how=any)\nReturn columns whose name contains needles.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nneedles\nstr | tuple[str, …]\nOne or more strings to search for in column names\nrequired\n\n\nhow\ntyping.Callable[[typing.Iterable[bool]], bool]\nA boolean reduction to allow the configuration of how needles are summarized.\nany\n\n\n\n\n\n\nSelect columns that contain either \"a\" or \"b\"\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int64\", b=\"string\", c=\"float\", d=\"array&lt;int16&gt;\", ab=\"struct&lt;x: int&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.contains((\"a\", \"b\")))\n&gt;&gt;&gt; expr.columns\n['a', 'b', 'ab']\nSelect columns that contain all of \"a\" and \"b\", that is, both \"a\" and \"b\" must be in each column’s name to match.\n&gt;&gt;&gt; expr = t.select(s.contains((\"a\", \"b\"), how=all))\n&gt;&gt;&gt; expr.columns\n['ab']\n\n\n\n[matches][ibis.selectors.matches]\n\n\n\n\nselectors.endswith(suffixes)\nSelect columns whose name ends with one of suffixes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsuffixes\nstr | tuple[str, …]\nSuffixes to compare column names against\nrequired\n\n\n\n\n\n\n[startswith][ibis.selectors.startswith]\n\n\n\n\nselectors.first()\nReturn the first column of a table.\n\n\n\nselectors.if_all(selector, predicate)\nReturn the conjunction of predicate applied on all selector columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nSelector\nA column selector\nrequired\n\n\npredicate\nibis.expr.deferred.Deferred | typing.Callable\nA callable or deferred object defining a predicate to apply to each column from selector.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import selectors as s, _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; penguins = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n&gt;&gt;&gt; expr = penguins.mutate(cols).filter(s.if_all(s.endswith(\"_mm\"), _.abs() &gt; 1))\n&gt;&gt;&gt; expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() &gt; 1)\n...     & (_.bill_depth_mm.abs() &gt; 1)\n...     & (_.flipper_length_mm.abs() &gt; 1)\n... )\n&gt;&gt;&gt; expr.equals(expr_by_hand)\nTrue\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ float64           │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Dream     │      -1.157951 │      1.088129 │         -1.416272 │ … │\n│ Adelie  │ Torgersen │      -1.231217 │      1.138768 │         -1.202926 │ … │\n│ Gentoo  │ Biscoe    │       1.149917 │     -1.443781 │          1.214987 │ … │\n│ Gentoo  │ Biscoe    │       1.040019 │     -1.089314 │          1.072757 │ … │\n│ Gentoo  │ Biscoe    │       1.131601 │     -1.089314 │          1.712792 │ … │\n│ Gentoo  │ Biscoe    │       1.241499 │     -1.089314 │          1.570562 │ … │\n│ Gentoo  │ Biscoe    │       1.351398 │     -1.494420 │          1.214987 │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\n\nselectors.if_any(selector, predicate)\nReturn the disjunction of predicate applied on all selector columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nSelector\nA column selector\nrequired\n\n\npredicate\nibis.expr.deferred.Deferred | typing.Callable\nA callable or deferred object defining a predicate to apply to each column from selector.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import selectors as s, _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; penguins = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n&gt;&gt;&gt; expr = penguins.mutate(cols).filter(s.if_any(s.endswith(\"_mm\"), _.abs() &gt; 2))\n&gt;&gt;&gt; expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() &gt; 2)\n...     | (_.bill_depth_mm.abs() &gt; 2)\n...     | (_.flipper_length_mm.abs() &gt; 2)\n... )\n&gt;&gt;&gt; expr.equals(expr_by_hand)\nTrue\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string │ float64        │ float64       │ float64           │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Biscoe │      -1.103002 │      0.733662 │         -2.056307 │ … │\n│ Gentoo  │ Biscoe │       1.113285 │     -0.431017 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       2.871660 │     -0.076550 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.900890 │     -0.734846 │          2.139483 │ … │\n│ Gentoo  │ Biscoe │       1.076652 │     -0.177826 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       0.856855 │     -0.582932 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.497929 │     -0.076550 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.388031 │     -0.431017 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       2.047422 │     -0.582932 │          2.068368 │ … │\n│ Adelie  │ Dream  │      -2.165354 │     -0.836123 │         -0.918466 │ … │\n│ …       │ …      │              … │             … │                 … │ … │\n└─────────┴────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\n\nselectors.last()\nReturn the last column of a table.\n\n\n\nselectors.matches(regex)\nReturn columns whose name matches the regular expression regex.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nregex\nstr | re.Pattern\nA string or re.Pattern object\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(ab=\"string\", abd=\"int\", be=\"array&lt;string&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.matches(r\"ab+\"))\n&gt;&gt;&gt; expr.columns\n['ab', 'abd']\n\n\n\n[contains][ibis.selectors.contains]\n\n\n\n\nselectors.numeric()\nReturn numeric columns.\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int\", b=\"string\", c=\"array&lt;string&gt;\"), name=\"t\")\n&gt;&gt;&gt; t\nUnboundTable: t\n  a int64\n  b string\n  c array&lt;string&gt;\n&gt;&gt;&gt; expr = t.select(s.numeric())  # `a` has integer type, so it's numeric\n&gt;&gt;&gt; expr.columns\n['a']\n\n\n\n[of_type][ibis.selectors.of_type]\n\n\n\n\nselectors.of_type(dtype)\nSelect columns of type dtype.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndtype\nibis.DataType | str | type[ibis.DataType]\nDataType instance, str or DataType class\nrequired\n\n\n\n\n\n\nSelect according to a specific DataType instance\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(name=\"string\", siblings=\"array&lt;string&gt;\", parents=\"array&lt;int64&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.of_type(dt.Array(dt.string)))\n&gt;&gt;&gt; expr.columns\n['siblings']\nStrings are also accepted\n&gt;&gt;&gt; expr = t.select(s.of_type(\"array&lt;string&gt;\"))\n&gt;&gt;&gt; expr.columns\n['siblings']\nAbstract/unparametrized types may also be specified by their string name (e.g. “integer” for any integer type), or by passing in a DataType class instead. The following options are equivalent.\n&gt;&gt;&gt; expr1 = t.select(s.of_type(\"array\"))\n&gt;&gt;&gt; expr2 = t.select(s.of_type(dt.Array))\n&gt;&gt;&gt; expr1.equals(expr2)\nTrue\n&gt;&gt;&gt; expr2.columns\n['siblings', 'parents']\n\n\n\n[numeric][ibis.selectors.numeric]\n\n\n\n\nselectors.startswith(prefixes)\nSelect columns whose name starts with one of prefixes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprefixes\nstr | tuple[str, …]\nPrefixes to compare column names against\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(apples=\"int\", oranges=\"float\", bananas=\"bool\"), name=\"t\")\n&gt;&gt;&gt; expr = t.select(s.startswith((\"a\", \"b\")))\n&gt;&gt;&gt; expr.columns\n['apples', 'bananas']\n\n\n\n[endswith][ibis.selectors.endswith]\n\n\n\n\nselectors.where(predicate)\nSelect columns that satisfy predicate.\nUse this selector when one of the other selectors does not meet your needs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npredicate\ntyping.Callable[[ibis.Value], bool]\nA callable that accepts an ibis value expression and returns a bool\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"float32\"), name=\"t\")\n&gt;&gt;&gt; expr = t.select(s.where(lambda col: col.get_name() == \"a\"))\n&gt;&gt;&gt; expr.columns\n['a']"
  },
  {
    "objectID": "reference/selectors.html#rationale",
    "href": "reference/selectors.html#rationale",
    "title": "selectors",
    "section": "",
    "text": "Column selectors are convenience functions for selecting columns that share some property."
  },
  {
    "objectID": "reference/selectors.html#discussion",
    "href": "reference/selectors.html#discussion",
    "title": "selectors",
    "section": "",
    "text": "For example, a common task is to be able to select all numeric columns for a subsequent computation.\nWithout selectors this becomes quite verbose and tedious to write:\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; t = ibis.table(...)  # doctest: +SKIP\n&gt;&gt;&gt; t.select([t[c] for c in t.columns if t[c].type().is_numeric()])  # doctest: +SKIP\nCompare that to the [numeric][ibis.selectors.numeric] selector:\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t.select(s.numeric())  # doctest: +SKIP\nWhen there are multiple properties to check it gets worse:\n&gt;&gt;&gt; t.select(  # doctest: +SKIP\n...     [\n...         t[c] for c in t.columns\n...         if t[c].type().is_numeric()\n...         if (\"a\" in c or \"cd\" in c)\n...     ]\n... )\nUsing a composition of selectors this is much less tiresome:\n&gt;&gt;&gt; t.select(s.numeric() & s.contains((\"a\", \"cd\")))  # doctest: +SKIP"
  },
  {
    "objectID": "reference/selectors.html#classes",
    "href": "reference/selectors.html#classes",
    "title": "selectors",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nSelector\nA column selector.\n\n\n\n\n\nselectors.Selector()\nA column selector.\n\n\n\n\n\nName\nDescription\n\n\n\n\nexpand\nExpand table into a sequence of value expressions.\n\n\n\n\n\nselectors.Selector.expand(self, table)\nExpand table into a sequence of value expressions.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable\nibis.Table\nAn ibis table expression\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\ntyping.Sequence[Value]\nA sequence of value expressions"
  },
  {
    "objectID": "reference/selectors.html#functions",
    "href": "reference/selectors.html#functions",
    "title": "selectors",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nacross\nApply data transformations across multiple columns.\n\n\nall\nReturn every column from a table.\n\n\nall_of\nInclude columns satisfying all of predicates.\n\n\nany_of\nInclude columns satisfying any of predicates.\n\n\nc\nSelect specific column names.\n\n\ncontains\nReturn columns whose name contains needles.\n\n\nendswith\nSelect columns whose name ends with one of suffixes.\n\n\nfirst\nReturn the first column of a table.\n\n\nif_all\nReturn the conjunction of predicate applied on all selector columns.\n\n\nif_any\nReturn the disjunction of predicate applied on all selector columns.\n\n\nlast\nReturn the last column of a table.\n\n\nmatches\nReturn columns whose name matches the regular expression regex.\n\n\nnumeric\nReturn numeric columns.\n\n\nof_type\nSelect columns of type dtype.\n\n\nstartswith\nSelect columns whose name starts with one of prefixes.\n\n\nwhere\nSelect columns that satisfy predicate.\n\n\n\n\n\nselectors.across(selector, func, names=None)\nApply data transformations across multiple columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nibis.selectors.Selector | typing.Iterable[str] | str\nAn expression that selects columns on which the transformation function will be applied, an iterable of str column names or a single str column name.\nrequired\n\n\nfunc\nibis.expr.deferred.Deferred | typing.Callable[[ibis.Value], ibis.Value] | typing.Mapping[str | None, ibis.expr.deferred.Deferred | typing.Callable[[ibis.Value], ibis.Value]]\nA function (or dictionary of functions) to use to transform the data.\nrequired\n\n\nnames\nstr | typing.Callable[[str, str | None], str] | None\nA lambda function or a format string to name the columns created by the transformation function.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nAcross\nAn Across selector object\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from ibis import _, selectors as s\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.select(s.startswith(\"bill\")).mutate(\n...     s.across(\n...         s.numeric(),\n...         dict(centered =_ - _.mean()),\n...         names = \"{fn}_{col}\"\n...     )\n... )\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ centered_bill_length_mm ┃ … ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ float64        │ float64       │ float64                 │ … │\n├────────────────┼───────────────┼─────────────────────────┼───┤\n│           39.1 │          18.7 │                -4.82193 │ … │\n│           39.5 │          17.4 │                -4.42193 │ … │\n│           40.3 │          18.0 │                -3.62193 │ … │\n│            nan │           nan │                     nan │ … │\n│           36.7 │          19.3 │                -7.22193 │ … │\n│           39.3 │          20.6 │                -4.62193 │ … │\n│           38.9 │          17.8 │                -5.02193 │ … │\n│           39.2 │          19.6 │                -4.72193 │ … │\n│           34.1 │          18.1 │                -9.82193 │ … │\n│           42.0 │          20.2 │                -1.92193 │ … │\n│              … │             … │                       … │ … │\n└────────────────┴───────────────┴─────────────────────────┴───┘\n\n\n\n\nselectors.all()\nReturn every column from a table.\n\n\n\nselectors.all_of(*predicates)\nInclude columns satisfying all of predicates.\n\n\n\nselectors.any_of(*predicates)\nInclude columns satisfying any of predicates.\n\n\n\nselectors.c(*names)\nSelect specific column names.\n\n\n\nselectors.contains(needles, how=any)\nReturn columns whose name contains needles.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nneedles\nstr | tuple[str, …]\nOne or more strings to search for in column names\nrequired\n\n\nhow\ntyping.Callable[[typing.Iterable[bool]], bool]\nA boolean reduction to allow the configuration of how needles are summarized.\nany\n\n\n\n\n\n\nSelect columns that contain either \"a\" or \"b\"\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int64\", b=\"string\", c=\"float\", d=\"array&lt;int16&gt;\", ab=\"struct&lt;x: int&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.contains((\"a\", \"b\")))\n&gt;&gt;&gt; expr.columns\n['a', 'b', 'ab']\nSelect columns that contain all of \"a\" and \"b\", that is, both \"a\" and \"b\" must be in each column’s name to match.\n&gt;&gt;&gt; expr = t.select(s.contains((\"a\", \"b\"), how=all))\n&gt;&gt;&gt; expr.columns\n['ab']\n\n\n\n[matches][ibis.selectors.matches]\n\n\n\n\nselectors.endswith(suffixes)\nSelect columns whose name ends with one of suffixes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsuffixes\nstr | tuple[str, …]\nSuffixes to compare column names against\nrequired\n\n\n\n\n\n\n[startswith][ibis.selectors.startswith]\n\n\n\n\nselectors.first()\nReturn the first column of a table.\n\n\n\nselectors.if_all(selector, predicate)\nReturn the conjunction of predicate applied on all selector columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nSelector\nA column selector\nrequired\n\n\npredicate\nibis.expr.deferred.Deferred | typing.Callable\nA callable or deferred object defining a predicate to apply to each column from selector.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import selectors as s, _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; penguins = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n&gt;&gt;&gt; expr = penguins.mutate(cols).filter(s.if_all(s.endswith(\"_mm\"), _.abs() &gt; 1))\n&gt;&gt;&gt; expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() &gt; 1)\n...     & (_.bill_depth_mm.abs() &gt; 1)\n...     & (_.flipper_length_mm.abs() &gt; 1)\n... )\n&gt;&gt;&gt; expr.equals(expr_by_hand)\nTrue\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ float64           │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Dream     │      -1.157951 │      1.088129 │         -1.416272 │ … │\n│ Adelie  │ Torgersen │      -1.231217 │      1.138768 │         -1.202926 │ … │\n│ Gentoo  │ Biscoe    │       1.149917 │     -1.443781 │          1.214987 │ … │\n│ Gentoo  │ Biscoe    │       1.040019 │     -1.089314 │          1.072757 │ … │\n│ Gentoo  │ Biscoe    │       1.131601 │     -1.089314 │          1.712792 │ … │\n│ Gentoo  │ Biscoe    │       1.241499 │     -1.089314 │          1.570562 │ … │\n│ Gentoo  │ Biscoe    │       1.351398 │     -1.494420 │          1.214987 │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\n\nselectors.if_any(selector, predicate)\nReturn the disjunction of predicate applied on all selector columns.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nselector\nSelector\nA column selector\nrequired\n\n\npredicate\nibis.expr.deferred.Deferred | typing.Callable\nA callable or deferred object defining a predicate to apply to each column from selector.\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import selectors as s, _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; penguins = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; cols = s.across(s.endswith(\"_mm\"), (_ - _.mean()) / _.std())\n&gt;&gt;&gt; expr = penguins.mutate(cols).filter(s.if_any(s.endswith(\"_mm\"), _.abs() &gt; 2))\n&gt;&gt;&gt; expr_by_hand = penguins.mutate(cols).filter(\n...     (_.bill_length_mm.abs() &gt; 2)\n...     | (_.bill_depth_mm.abs() &gt; 2)\n...     | (_.flipper_length_mm.abs() &gt; 2)\n... )\n&gt;&gt;&gt; expr.equals(expr_by_hand)\nTrue\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string │ float64        │ float64       │ float64           │ … │\n├─────────┼────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Biscoe │      -1.103002 │      0.733662 │         -2.056307 │ … │\n│ Gentoo  │ Biscoe │       1.113285 │     -0.431017 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       2.871660 │     -0.076550 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.900890 │     -0.734846 │          2.139483 │ … │\n│ Gentoo  │ Biscoe │       1.076652 │     -0.177826 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       0.856855 │     -0.582932 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.497929 │     -0.076550 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       1.388031 │     -0.431017 │          2.068368 │ … │\n│ Gentoo  │ Biscoe │       2.047422 │     -0.582932 │          2.068368 │ … │\n│ Adelie  │ Dream  │      -2.165354 │     -0.836123 │         -0.918466 │ … │\n│ …       │ …      │              … │             … │                 … │ … │\n└─────────┴────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\n\nselectors.last()\nReturn the last column of a table.\n\n\n\nselectors.matches(regex)\nReturn columns whose name matches the regular expression regex.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nregex\nstr | re.Pattern\nA string or re.Pattern object\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(ab=\"string\", abd=\"int\", be=\"array&lt;string&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.matches(r\"ab+\"))\n&gt;&gt;&gt; expr.columns\n['ab', 'abd']\n\n\n\n[contains][ibis.selectors.contains]\n\n\n\n\nselectors.numeric()\nReturn numeric columns.\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int\", b=\"string\", c=\"array&lt;string&gt;\"), name=\"t\")\n&gt;&gt;&gt; t\nUnboundTable: t\n  a int64\n  b string\n  c array&lt;string&gt;\n&gt;&gt;&gt; expr = t.select(s.numeric())  # `a` has integer type, so it's numeric\n&gt;&gt;&gt; expr.columns\n['a']\n\n\n\n[of_type][ibis.selectors.of_type]\n\n\n\n\nselectors.of_type(dtype)\nSelect columns of type dtype.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndtype\nibis.DataType | str | type[ibis.DataType]\nDataType instance, str or DataType class\nrequired\n\n\n\n\n\n\nSelect according to a specific DataType instance\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(name=\"string\", siblings=\"array&lt;string&gt;\", parents=\"array&lt;int64&gt;\"))\n&gt;&gt;&gt; expr = t.select(s.of_type(dt.Array(dt.string)))\n&gt;&gt;&gt; expr.columns\n['siblings']\nStrings are also accepted\n&gt;&gt;&gt; expr = t.select(s.of_type(\"array&lt;string&gt;\"))\n&gt;&gt;&gt; expr.columns\n['siblings']\nAbstract/unparametrized types may also be specified by their string name (e.g. “integer” for any integer type), or by passing in a DataType class instead. The following options are equivalent.\n&gt;&gt;&gt; expr1 = t.select(s.of_type(\"array\"))\n&gt;&gt;&gt; expr2 = t.select(s.of_type(dt.Array))\n&gt;&gt;&gt; expr1.equals(expr2)\nTrue\n&gt;&gt;&gt; expr2.columns\n['siblings', 'parents']\n\n\n\n[numeric][ibis.selectors.numeric]\n\n\n\n\nselectors.startswith(prefixes)\nSelect columns whose name starts with one of prefixes.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nprefixes\nstr | tuple[str, …]\nPrefixes to compare column names against\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(apples=\"int\", oranges=\"float\", bananas=\"bool\"), name=\"t\")\n&gt;&gt;&gt; expr = t.select(s.startswith((\"a\", \"b\")))\n&gt;&gt;&gt; expr.columns\n['apples', 'bananas']\n\n\n\n[endswith][ibis.selectors.endswith]\n\n\n\n\nselectors.where(predicate)\nSelect columns that satisfy predicate.\nUse this selector when one of the other selectors does not meet your needs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npredicate\ntyping.Callable[[ibis.Value], bool]\nA callable that accepts an ibis value expression and returns a bool\nrequired\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t = ibis.table(dict(a=\"float32\"), name=\"t\")\n&gt;&gt;&gt; expr = t.select(s.where(lambda col: col.get_name() == \"a\"))\n&gt;&gt;&gt; expr.columns\n['a']"
  },
  {
    "objectID": "reference/expression-generic.html",
    "href": "reference/expression-generic.html",
    "title": "Generic Expression APIs",
    "section": "",
    "text": "These expressions are available on scalars and columns of any element type."
  },
  {
    "objectID": "reference/expression-generic.html#methods",
    "href": "reference/expression-generic.html#methods",
    "title": "Generic Expression APIs",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nas_table\nPromote the expression to a table.\n\n\nasc\nSort an expression ascending.\n\n\nbetween\nCheck if this expression is between lower and upper, inclusive.\n\n\ncase\nCreate a SimpleCaseBuilder to chain multiple if-else statements.\n\n\ncases\nCreate a case expression in one shot.\n\n\ncast\nCast expression to indicated data type.\n\n\ncoalesce\nReturn the first non-null value from args.\n\n\ncollect\nAggregate this expression’s elements into an array.\n\n\ndesc\nSort an expression descending.\n\n\nfillna\nReplace any null values with the indicated fill value.\n\n\ngreatest\nCompute the largest value among the supplied arguments.\n\n\ngroup_concat\nConcatenate values using the indicated separator to produce a string.\n\n\nhash\nCompute an integer hash value.\n\n\nidentical_to\nReturn whether this expression is identical to other.\n\n\nisin\nCheck whether this expression’s values are in values.\n\n\nisnull\nReturn whether this expression is NULL.\n\n\nleast\nCompute the smallest value among the supplied arguments.\n\n\nname\nRename an expression to name.\n\n\nnotin\nCheck whether this expression’s values are not in values.\n\n\nnotnull\nReturn whether this expression is not NULL.\n\n\nnullif\nSet values to null if they equal the values null_if_expr.\n\n\nover\nConstruct a window expression.\n\n\nsubstitute\nReplace values given in values with replacement.\n\n\nto_pandas\nConvert a column expression to a pandas Series or scalar object.\n\n\ntry_cast\nTry cast expression to indicated data type.\n\n\ntype\nReturn the [DataType] of this expression.\n\n\ntypeof\nReturn the data type of the expression.\n\n\n\n\nas_table\nexpr.types.generic.Value.as_table(self)\nPromote the expression to a table.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; t = ibis.table(dict(a=\"str\"), name=\"t\")\n&gt;&gt;&gt; expr = t.a.length().name(\"len\").as_table()\n&gt;&gt;&gt; expected = t.select(len=t.a.length())\n&gt;&gt;&gt; expr.equals(expected)\nTrue\n\n\n\nasc\nexpr.types.generic.Value.asc(self)\nSort an expression ascending.\n\n\nbetween\nexpr.types.generic.Value.between(self, lower, upper)\nCheck if this expression is between lower and upper, inclusive.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlower\nValue\nLower bound\nrequired\n\n\nupper\nValue\nUpper bound\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nExpression indicating membership in the provided range\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.bill_length_mm.between(35, 38)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ Between(bill_length_mm, 35, 38) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                         │\n├─────────────────────────────────┤\n│ False                           │\n│ False                           │\n│ False                           │\n│ NULL                            │\n│ True                            │\n└─────────────────────────────────┘\n\n\n\ncase\nexpr.types.generic.Value.case(self)\nCreate a SimpleCaseBuilder to chain multiple if-else statements.\nAdd new search expressions with the .when() method. These must be comparable with this column expression. Conclude by calling .end()\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nSimpleCaseBuilder\nA case builder\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; t = ibis.table([('string_col', 'string')], name='t')\n&gt;&gt;&gt; expr = t.string_col\n&gt;&gt;&gt; case_expr = (expr.case()\n...              .when('a', 'an a')\n...              .when('b', 'a b')\n...              .else_('null or (not a and not b)')\n...              .end())\n&gt;&gt;&gt; case_expr\nr0 := UnboundTable: t\n  string_col string\nSimpleCase(...)\n\n\n\ncases\nexpr.types.generic.Value.cases(self, case_result_pairs, default=None)\nCreate a case expression in one shot.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncase_result_pairs\ntyping.Iterable[tuple[ibis.BooleanValue, ibis.expr.types.generic.Value]]\nConditional-result pairs\nrequired\n\n\ndefault\nibis.expr.types.generic.Value | None\nValue to return if none of the case conditions are true\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nValue expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2, 4]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ values ┃\n┡━━━━━━━━┩\n│ int64  │\n├────────┤\n│      1 │\n│      2 │\n│      1 │\n│      2 │\n│      3 │\n│      2 │\n│      4 │\n└────────┘\n&gt;&gt;&gt; number_letter_map = ((1, \"a\"), (2, \"b\"), (3, \"c\"))\n&gt;&gt;&gt; t.values.cases(number_letter_map, default=\"unk\").name(\"replace\")\n┏━━━━━━━━━┓\n┃ replace ┃\n┡━━━━━━━━━┩\n│ string  │\n├─────────┤\n│ a       │\n│ b       │\n│ a       │\n│ b       │\n│ c       │\n│ b       │\n│ unk     │\n└─────────┘\n\n\n\ncast\nexpr.types.generic.Value.cast(self, target_type)\nCast expression to indicated data type.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntarget_type\nibis.DataType\nType to cast to\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nCasted expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = False\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int64\"), name=\"t\")\n&gt;&gt;&gt; t.a.cast(\"float\")\nr0 := UnboundTable: t\n  a int64\nCast(a, float64): Cast(r0.a, to=float64)\n\n\n\ncoalesce\nexpr.types.generic.Value.coalesce(self, *args)\nReturn the first non-null value from args.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nValue\nArguments from which to choose the first non-null value\n()\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nCoalesced expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.coalesce(None, 4, 5).name(\"x\")\nx: Coalesce(...)\n\n\n\ncollect\nexpr.types.generic.Value.collect(self, where=None)\nAggregate this expression’s elements into an array.\nThis function is called array_agg, list_agg, or list in other systems.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter to apply before aggregation\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayScalar\nCollected array\n\n\n\n\n\nExamples\nBasic collect usage\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"key\": list(\"aaabb\"), \"value\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┳━━━━━━━┓\n┃ key    ┃ value ┃\n┡━━━━━━━━╇━━━━━━━┩\n│ string │ int64 │\n├────────┼───────┤\n│ a      │     1 │\n│ a      │     2 │\n│ a      │     3 │\n│ b      │     4 │\n│ b      │     5 │\n└────────┴───────┘\n&gt;&gt;&gt; t.value.collect()\n[1, 2, 3, 4, 5]\n&gt;&gt;&gt; type(t.value.collect())\n&lt;class 'ibis.expr.types.arrays.ArrayScalar'&gt;\nCollect elements per group\n&gt;&gt;&gt; t.group_by(\"key\").agg(v=lambda t: t.value.collect())\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓\n┃ key    ┃ v                    ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩\n│ string │ array&lt;int64&gt;         │\n├────────┼──────────────────────┤\n│ a      │ [1, 2, ... +1]       │\n│ b      │ [4, 5]               │\n└────────┴──────────────────────┘\nCollect elements per group using a filter\n&gt;&gt;&gt; t.group_by(\"key\").agg(v=lambda t: t.value.collect(where=t.value &gt; 1))\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓\n┃ key    ┃ v                    ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩\n│ string │ array&lt;int64&gt;         │\n├────────┼──────────────────────┤\n│ a      │ [2, 3]               │\n│ b      │ [4, 5]               │\n└────────┴──────────────────────┘\n\n\n\ndesc\nexpr.types.generic.Value.desc(self)\nSort an expression descending.\n\n\nfillna\nexpr.types.generic.Value.fillna(self, fill_value)\nReplace any null values with the indicated fill value.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfill_value\nScalar\nValue with which to replace NA values in self\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.sex\n┏━━━━━━━━┓\n┃ sex    ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ male   │\n│ female │\n│ female │\n│ NULL   │\n│ female │\n└────────┘\n&gt;&gt;&gt; t.sex.fillna(\"unrecorded\").name(\"sex\")\n┏━━━━━━━━━━━━┓\n┃ sex        ┃\n┡━━━━━━━━━━━━┩\n│ string     │\n├────────────┤\n│ male       │\n│ female     │\n│ female     │\n│ unrecorded │\n│ female     │\n└────────────┘\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nself filled with fill_value where it is NA\n\n\n\n\n\n\ngreatest\nexpr.types.generic.Value.greatest(self, *args)\nCompute the largest value among the supplied arguments.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nibis.Value\nArguments to choose from\n()\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nMaximum of the passed arguments\n\n\n\n\n\n\ngroup_concat\nexpr.types.generic.Value.group_concat(self, sep=',', where=None)\nConcatenate values using the indicated separator to produce a string.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsep\nstr\nSeparator will be used to join strings\n','\n\n\nwhere\nibis.BooleanValue | None\nFilter expression\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringScalar\nConcatenated string expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t[[\"bill_length_mm\", \"bill_depth_mm\"]]\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━┩\n│ float64        │ float64       │\n├────────────────┼───────────────┤\n│           39.1 │          18.7 │\n│           39.5 │          17.4 │\n│           40.3 │          18.0 │\n│            nan │           nan │\n│           36.7 │          19.3 │\n└────────────────┴───────────────┘\n&gt;&gt;&gt; t.bill_length_mm.group_concat()\n'39.1,39.5,40.3,36.7'\n&gt;&gt;&gt; t.bill_length_mm.group_concat(sep=\": \")\n'39.1: 39.5: 40.3: 36.7'\n&gt;&gt;&gt; t.bill_length_mm.group_concat(sep=\": \", where=t.bill_depth_mm &gt; 18)\n'39.1: 36.7'\n\n\n\nhash\nexpr.types.generic.Value.hash(self)\nCompute an integer hash value.\n!!! info “The hashing function used is backend-dependent.”\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe hash value of self\n\n\n\n\n\n\nidentical_to\nexpr.types.generic.Value.identical_to(self, other)\nReturn whether this expression is identical to other.\nCorresponds to IS NOT DISTINCT FROM in SQL.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nValue\nExpression to compare to\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether this expression is not distinct from other\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; one = ibis.literal(1)\n&gt;&gt;&gt; two = ibis.literal(2)\n&gt;&gt;&gt; two.identical_to(one + one)\nTrue\n\n\n\nisin\nexpr.types.generic.Value.isin(self, values)\nCheck whether this expression’s values are in values.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\nibis.expr.types.generic.Value | typing.Sequence[ibis.expr.types.generic.Value]\nValues or expression to check for membership\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nExpression indicating membership\n\n\n\n\n\nExamples\nCheck whether a column’s values are contained in a sequence\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; table = ibis.table(dict(string_col='string'), name=\"t\")\n&gt;&gt;&gt; table.string_col.isin(['foo', 'bar', 'baz'])\nr0 := UnboundTable: t\n  string_col string\nContains(string_col): Contains(...)\nCheck whether a column’s values are contained in another table’s column\n&gt;&gt;&gt; table2 = ibis.table(dict(other_string_col='string'), name=\"t2\")\n&gt;&gt;&gt; table.string_col.isin(table2.other_string_col)\nr0 := UnboundTable: t\n  string_col string\nr1 := UnboundTable: t2\n  other_string_col string\nContains(string_col, other_string_col): Contains(...)\n\n\n\nisnull\nexpr.types.generic.Value.isnull(self)\nReturn whether this expression is NULL.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.bill_depth_mm\n┏━━━━━━━━━━━━━━━┓\n┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│          18.7 │\n│          17.4 │\n│          18.0 │\n│           nan │\n│          19.3 │\n└───────────────┘\n&gt;&gt;&gt; t.bill_depth_mm.isnull()\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ IsNull(bill_depth_mm) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean               │\n├───────────────────────┤\n│ False                 │\n│ False                 │\n│ False                 │\n│ True                  │\n│ False                 │\n└───────────────────────┘\n\n\n\nleast\nexpr.types.generic.Value.least(self, *args)\nCompute the smallest value among the supplied arguments.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nargs\nibis.Value\nArguments to choose from\n()\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nMinimum of the passed arguments\n\n\n\n\n\n\nname\nexpr.types.generic.Value.name(self, name)\nRename an expression to name.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\n\nThe new name of the expression\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nself with name name\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int64\"), name=\"t\")\n&gt;&gt;&gt; t.a.name(\"b\")\nr0 := UnboundTable: t\n  a int64\nb: r0.a\n\n\n\nnotin\nexpr.types.generic.Value.notin(self, values)\nCheck whether this expression’s values are not in values.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalues\nibis.expr.types.generic.Value | typing.Sequence[ibis.expr.types.generic.Value]\nValues or expression to check for lack of membership\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self’s values are not contained in values\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.bill_depth_mm\n┏━━━━━━━━━━━━━━━┓\n┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│          18.7 │\n│          17.4 │\n│          18.0 │\n│           nan │\n│          19.3 │\n└───────────────┘\n&gt;&gt;&gt; t.bill_depth_mm.notin([18.7, 18.1])\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ NotContains(bill_depth_mm) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                    │\n├────────────────────────────┤\n│ False                      │\n│ True                       │\n│ True                       │\n│ NULL                       │\n│ True                       │\n└────────────────────────────┘\n\n\n\nnotnull\nexpr.types.generic.Value.notnull(self)\nReturn whether this expression is not NULL.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.bill_depth_mm\n┏━━━━━━━━━━━━━━━┓\n┃ bill_depth_mm ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│          18.7 │\n│          17.4 │\n│          18.0 │\n│           nan │\n│          19.3 │\n└───────────────┘\n&gt;&gt;&gt; t.bill_depth_mm.notnull()\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ NotNull(bill_depth_mm) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ True                   │\n│ True                   │\n│ True                   │\n│ False                  │\n│ True                   │\n└────────────────────────┘\n\n\n\nnullif\nexpr.types.generic.Value.nullif(self, null_if_expr)\nSet values to null if they equal the values null_if_expr.\nCommonly use to avoid divide-by-zero problems by replacing zero with NULL in the divisor.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnull_if_expr\nValue\nExpression indicating what values should be NULL\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nValue expression\n\n\n\n\n\n\nover\nexpr.types.generic.Value.over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None)\nConstruct a window expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow\n\nWindow specification\nNone\n\n\nrows\n\nWhether to use the ROWS window clause\nNone\n\n\nrange\n\nWhether to use the RANGE window clause\nNone\n\n\ngroup_by\n\nGrouping key\nNone\n\n\norder_by\n\nOrdering key\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nA window function expression\n\n\n\n\n\n\nsubstitute\nexpr.types.generic.Value.substitute(self, value, replacement=None, else_=None)\nReplace values given in values with replacement.\nThis is similar to the pandas replace method.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nvalue\nibis.expr.types.generic.Value | dict\nExpression or dict.\nrequired\n\n\nreplacement\nibis.expr.types.generic.Value | None\nIf an expression is passed to value, this must be passed.\nNone\n\n\nelse_\nibis.expr.types.generic.Value | None\nIf an original value does not match value, then else_ is used. The default of None means leave the original value unchanged.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nReplaced values\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.island.value_counts()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━┓\n┃ island    ┃ island_count ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━┩\n│ string    │ int64        │\n├───────────┼──────────────┤\n│ Torgersen │           52 │\n│ Biscoe    │          168 │\n│ Dream     │          124 │\n└───────────┴──────────────┘\n&gt;&gt;&gt; t.island.substitute({\"Torgersen\": \"torg\", \"Biscoe\": \"bisc\"}).value_counts()\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ SimpleCase(island, island) ┃ SimpleCase(island, island)_count ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                     │ int64                            │\n├────────────────────────────┼──────────────────────────────────┤\n│ torg                       │                               52 │\n│ bisc                       │                              168 │\n│ Dream                      │                              124 │\n└────────────────────────────┴──────────────────────────────────┘\n\n\n\nto_pandas\nexpr.types.generic.Value.to_pandas(self, **kwargs)\nConvert a column expression to a pandas Series or scalar object.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\n\nSame as keyword arguments to [execute][ibis.expr.types.core.Expr.execute]\n{}\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().limit(5)\n&gt;&gt;&gt; t.to_pandas()\n  species     island  bill_length_mm  ...  body_mass_g     sex  year\n0  Adelie  Torgersen            39.1  ...       3750.0    male  2007\n1  Adelie  Torgersen            39.5  ...       3800.0  female  2007\n2  Adelie  Torgersen            40.3  ...       3250.0  female  2007\n3  Adelie  Torgersen             NaN  ...          NaN    None  2007\n4  Adelie  Torgersen            36.7  ...       3450.0  female  2007\n[5 rows x 8 columns]\n\n\n\ntry_cast\nexpr.types.generic.Value.try_cast(self, target_type)\nTry cast expression to indicated data type. If the cast fails for a row, the value is returned as null or NaN depending on target_type and backend behavior.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntarget_type\nibis.DataType\nType to try cast to\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nCasted expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"numbers\": [1, 2, 3, 4], \"strings\": [\"1.0\", \"2\", \"hello\", \"world\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━┓\n┃ numbers ┃ strings ┃\n┡━━━━━━━━━╇━━━━━━━━━┩\n│ int64   │ string  │\n├─────────┼─────────┤\n│       1 │ 1.0     │\n│       2 │ 2       │\n│       3 │ hello   │\n│       4 │ world   │\n└─────────┴─────────┘\n&gt;&gt;&gt; t = t.mutate(numbers_to_strings=_.numbers.try_cast(\"string\"))\n&gt;&gt;&gt; t = t.mutate(strings_to_numbers=_.strings.try_cast(\"int\"))\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┓\n┃ numbers ┃ strings ┃ numbers_to_strings ┃ strings_to_numbers ┃\n┡━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━┩\n│ int64   │ string  │ string             │ int64              │\n├─────────┼─────────┼────────────────────┼────────────────────┤\n│       1 │ 1.0     │ 1                  │                  1 │\n│       2 │ 2       │ 2                  │                  2 │\n│       3 │ hello   │ 3                  │               NULL │\n│       4 │ world   │ 4                  │               NULL │\n└─────────┴─────────┴────────────────────┴────────────────────┘\n\n\n\ntype\nexpr.types.generic.Value.type(self)\nReturn the [DataType] of this expression.\n\n\ntypeof\nexpr.types.generic.Value.typeof(self)\nReturn the data type of the expression.\nThe values of the returned strings are necessarily backend dependent.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nA string indicating the type of the value"
  },
  {
    "objectID": "reference/expression-generic.html#methods-1",
    "href": "reference/expression-generic.html#methods-1",
    "title": "Generic Expression APIs",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\napprox_median\nReturn an approximate of the median of self.\n\n\napprox_nunique\nReturn the approximate number of distinct elements in self.\n\n\narbitrary\nSelect an arbitrary value in a column.\n\n\nargmax\nReturn the value of self that maximizes key.\n\n\nargmin\nReturn the value of self that minimizes key.\n\n\ncount\nCompute the number of rows in an expression.\n\n\ncume_dist\nReturn the cumulative distribution over a window.\n\n\ncummax\nReturn the cumulative max over a window.\n\n\ncummin\nReturn the cumulative min over a window.\n\n\ndense_rank\nPosition of first element within each group of equal values.\n\n\nfirst\nReturn the first value of a column.\n\n\nlag\nReturn the row located at offset rows before the current row.\n\n\nlast\nReturn the last value of a column.\n\n\nlead\nReturn the row located at offset rows after the current row.\n\n\nmax\nReturn the maximum of a column.\n\n\nmin\nReturn the minimum of a column.\n\n\nmode\nReturn the mode of a column.\n\n\nnth\nReturn the nth value (0-indexed) over a window.\n\n\nntile\nReturn the integer number of a partitioning of the column values.\n\n\nnunique\nCompute the number of distinct rows in an expression.\n\n\npercent_rank\nReturn the relative rank of the values in the column.\n\n\nrank\nCompute position of first element within each equal-value group in sorted order.\n\n\ntopk\nReturn a “top k” expression.\n\n\nvalue_counts\nCompute a frequency table.\n\n\n\n\napprox_median\nexpr.types.generic.Column.approx_median(self, where=None)\nReturn an approximate of the median of self.\n!!! info “The result may or may not be exact”\nWhether the result is an approximation depends on the backend.\n\n!!! warning \"Do not depend on the results being exact\"\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nAn approximation of the median of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.approx_median()\n4030\n&gt;&gt;&gt; t.body_mass_g.approx_median(where=t.species == \"Chinstrap\")\n3700\n\n\n\napprox_nunique\nexpr.types.generic.Column.approx_nunique(self, where=None)\nReturn the approximate number of distinct elements in self.\n!!! info “The result may or may not be exact”\nWhether the result is an approximation depends on the backend.\n\n!!! warning \"Do not depend on the results being exact\"\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nAn approximate count of the distinct elements of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.approx_nunique()\n94\n&gt;&gt;&gt; t.body_mass_g.approx_nunique(where=t.species == \"Adelie\")\n55\n\n\n\narbitrary\nexpr.types.generic.Column.arbitrary(self, where=None, how='first')\nSelect an arbitrary value in a column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nA filter expression\nNone\n\n\nhow\ntyping.Literal[‘first’, ‘last’, ‘heavy’]\nThe method to use for selecting the element. * \"first\": Select the first non-NULL element * \"last\": Select the last non-NULL element * \"heavy\": Select a frequently occurring value using the heavy hitters algorithm. \"heavy\" is only supported by Clickhouse backend.\n'first'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nAn expression\n\n\n\n\n\n\nargmax\nexpr.types.generic.Column.argmax(self, key, where=None)\nReturn the value of self that maximizes key.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nThe value of self that maximizes key\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.species.argmax(t.body_mass_g)\n'Gentoo'\n&gt;&gt;&gt; t.species.argmax(t.body_mass_g, where=t.island == \"Dream\")\n'Chinstrap'\n\n\n\nargmin\nexpr.types.generic.Column.argmin(self, key, where=None)\nReturn the value of self that minimizes key.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nThe value of self that minimizes key\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.species.argmin(t.body_mass_g)\n'Chinstrap'\n&gt;&gt;&gt; t.species.argmin(t.body_mass_g, where=t.island == \"Biscoe\")\n'Adelie'\n\n\n\ncount\nexpr.types.generic.Column.count(self, where=None)\nCompute the number of rows in an expression.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter expression\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerScalar\nNumber of elements in an expression\n\n\n\n\n\n\ncume_dist\nexpr.types.generic.Column.cume_dist(self)\nReturn the cumulative distribution over a window.\n\n\ncummax\nexpr.types.generic.Column.cummax(self)\nReturn the cumulative max over a window.\n\n\ncummin\nexpr.types.generic.Column.cummin(self)\nReturn the cumulative min over a window.\n\n\ndense_rank\nexpr.types.generic.Column.dense_rank(self)\nPosition of first element within each group of equal values.\nValues are returned in sorted order and duplicate values are ignored.\nEquivalent to SQL’s DENSE_RANK().\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerColumn\nThe rank\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n&gt;&gt;&gt; t.mutate(rank=t.values.dense_rank())\n┏━━━━━━━━┳━━━━━━━┓\n┃ values ┃ rank  ┃\n┡━━━━━━━━╇━━━━━━━┩\n│ int64  │ int64 │\n├────────┼───────┤\n│      1 │     0 │\n│      1 │     0 │\n│      2 │     1 │\n│      2 │     1 │\n│      2 │     1 │\n│      3 │     2 │\n└────────┴───────┘\n\n\n\nfirst\nexpr.types.generic.Column.first(self, where=None)\nReturn the first value of a column.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"chars\": [\"a\", \"b\", \"c\", \"d\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ chars  ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ a      │\n│ b      │\n│ c      │\n│ d      │\n└────────┘\n&gt;&gt;&gt; t.chars.first()\n'a'\n&gt;&gt;&gt; t.chars.first(where=t.chars != 'a')\n'b'\n\n\n\nlag\nexpr.types.generic.Column.lag(self, offset=None, default=None)\nReturn the row located at offset rows before the current row.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noffset\nint | ibis.IntegerValue | None\nIndex of row to select\nNone\n\n\ndefault\nibis.expr.types.generic.Value | None\nValue used if no row exists at offset\nNone\n\n\n\n\n\n\nlast\nexpr.types.generic.Column.last(self, where=None)\nReturn the last value of a column.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"chars\": [\"a\", \"b\", \"c\", \"d\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ chars  ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ a      │\n│ b      │\n│ c      │\n│ d      │\n└────────┘\n&gt;&gt;&gt; t.chars.last()\n'd'\n&gt;&gt;&gt; t.chars.last(where=t.chars != 'd')\n'c'\n\n\n\nlead\nexpr.types.generic.Column.lead(self, offset=None, default=None)\nReturn the row located at offset rows after the current row.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\noffset\nint | ibis.IntegerValue | None\nIndex of row to select\nNone\n\n\ndefault\nibis.expr.types.generic.Value | None\nValue used if no row exists at offset\nNone\n\n\n\n\n\n\nmax\nexpr.types.generic.Column.max(self, where=None)\nReturn the maximum of a column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nThe maximum value in self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.max()\n6300\n&gt;&gt;&gt; t.body_mass_g.max(where=t.species == \"Chinstrap\")\n4800\n\n\n\nmin\nexpr.types.generic.Column.min(self, where=None)\nReturn the minimum of a column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nThe minimum value in self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.min()\n2700\n&gt;&gt;&gt; t.body_mass_g.min(where=t.species == \"Adelie\")\n2850\n\n\n\nmode\nexpr.types.generic.Column.mode(self, where=None)\nReturn the mode of a column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter in values when where is True\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nScalar\nThe mode of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.mode()\n3800\n&gt;&gt;&gt; t.body_mass_g.mode(where=(t.species == \"Gentoo\") & (t.sex == \"male\"))\n5550\n\n\n\nnth\nexpr.types.generic.Column.nth(self, n)\nReturn the nth value (0-indexed) over a window.\n.nth(0) is equivalent to .first(). Negative will result in NULL. If the value of n is greater than the number of rows in the window, NULL will be returned.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint | ibis.IntegerValue\nDesired rank value\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nColumn\nThe nth value over a window\n\n\n\n\n\n\nntile\nexpr.types.generic.Column.ntile(self, buckets)\nReturn the integer number of a partitioning of the column values.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbuckets\nint | ibis.IntegerValue\nNumber of buckets to partition into\nrequired\n\n\n\n\n\n\nnunique\nexpr.types.generic.Column.nunique(self, where=None)\nCompute the number of distinct rows in an expression.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter expression\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerScalar\nNumber of distinct elements in an expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.body_mass_g.nunique()\n94\n&gt;&gt;&gt; t.body_mass_g.nunique(where=t.species == \"Adelie\")\n55\n\n\n\npercent_rank\nexpr.types.generic.Column.percent_rank(self)\nReturn the relative rank of the values in the column.\n\n\nrank\nexpr.types.generic.Column.rank(self)\nCompute position of first element within each equal-value group in sorted order.\nEquivalent to SQL’s RANK() window function.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nInt64Column\nThe min rank\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 2, 1, 2, 3, 2]})\n&gt;&gt;&gt; t.mutate(rank=t.values.rank())\n┏━━━━━━━━┳━━━━━━━┓\n┃ values ┃ rank  ┃\n┡━━━━━━━━╇━━━━━━━┩\n│ int64  │ int64 │\n├────────┼───────┤\n│      1 │     0 │\n│      1 │     0 │\n│      2 │     2 │\n│      2 │     2 │\n│      2 │     2 │\n│      3 │     5 │\n└────────┴───────┘\n\n\n\ntopk\nexpr.types.generic.Column.topk(self, k, by=None)\nReturn a “top k” expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nk\nint\nReturn this number of rows\nrequired\n\n\nby\nibis.Value | None\nAn expression. Defaults to count.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTableExpr\nA top-k expression\n\n\n\n\n\n\nvalue_counts\nexpr.types.generic.Column.value_counts(self)\nCompute a frequency table.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nFrequency table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"chars\": char} for char in \"aabcddd\")\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ chars  ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ a      │\n│ a      │\n│ b      │\n│ c      │\n│ d      │\n│ d      │\n│ d      │\n└────────┘\n&gt;&gt;&gt; t.chars.value_counts()\n┏━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ chars  ┃ chars_count ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━┩\n│ string │ int64       │\n├────────┼─────────────┤\n│ a      │           2 │\n│ b      │           1 │\n│ c      │           1 │\n│ d      │           3 │\n└────────┴─────────────┘"
  },
  {
    "objectID": "reference/expression-generic.html#methods-2",
    "href": "reference/expression-generic.html#methods-2",
    "title": "Generic Expression APIs",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nas_table\nPromote the scalar expression to a table.\n\n\n\n\nas_table\nexpr.types.generic.Scalar.as_table(self)\nPromote the scalar expression to a table.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA table expression\n\n\n\n\n\nExamples\nPromote an aggregation to a table\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.expr.types as ir\n&gt;&gt;&gt; t = ibis.table(dict(a=\"str\"), name=\"t\")\n&gt;&gt;&gt; expr = t.a.length().sum().name(\"len\").as_table()\n&gt;&gt;&gt; isinstance(expr, ir.Table)\nTrue\nPromote a literal value to a table\n&gt;&gt;&gt; import ibis.expr.types as ir\n&gt;&gt;&gt; lit = ibis.literal(1).name(\"a\").as_table()\n&gt;&gt;&gt; isinstance(lit, ir.Table)\nTrue"
  },
  {
    "objectID": "reference/expr.datatypes.core.html",
    "href": "reference/expr.datatypes.core.html",
    "title": "expr.datatypes.core",
    "section": "",
    "text": "expr.datatypes.core\n\n\n\n\n\nName\nDescription\n\n\n\n\nArray\nArray values.\n\n\nBinary\nA type representing a sequence of bytes.\n\n\nBoolean\n[True][True] or [False][False] values.\n\n\nBounds\nThe lower and upper bound of a fixed-size value.\n\n\nDataType\nBase class for all data types.\n\n\nDate\nDate values.\n\n\nDecimal\nFixed-precision decimal values.\n\n\nFloat16\n16-bit floating point numbers.\n\n\nFloat32\n32-bit floating point numbers.\n\n\nFloat64\n64-bit floating point numbers.\n\n\nFloating\nFloating point values.\n\n\nGeoSpatial\nGeospatial values.\n\n\nINET\nIP addresses.\n\n\nInt16\nSigned 16-bit integers.\n\n\nInt32\nSigned 32-bit integers.\n\n\nInt64\nSigned 64-bit integers.\n\n\nInt8\nSigned 8-bit integers.\n\n\nInteger\nInteger values.\n\n\nInterval\nInterval values.\n\n\nJSON\nJSON values.\n\n\nLineString\nA sequence of 2 or more points.\n\n\nMACADDR\nMedia Access Control (MAC) address of a network interface.\n\n\nMap\nAssociative array values.\n\n\nMultiLineString\nA set of one or more line strings.\n\n\nMultiPoint\nA set of one or more points.\n\n\nMultiPolygon\nA set of one or more polygons.\n\n\nNull\nNull values.\n\n\nNumeric\nNumeric types.\n\n\nParametric\nTypes that can be parameterized.\n\n\nPoint\nA point described by two coordinates.\n\n\nPolygon\nA set of one or more closed line strings.\n\n\nPrimitive\nValues with known size.\n\n\nSignedInteger\nSigned integer values.\n\n\nString\nA type representing a string.\n\n\nStruct\nStructured values.\n\n\nTemporal\nData types related to time.\n\n\nTime\nTime values.\n\n\nTimestamp\nTimestamp values.\n\n\nUInt16\nUnsigned 16-bit integers.\n\n\nUInt32\nUnsigned 32-bit integers.\n\n\nUInt64\nUnsigned 64-bit integers.\n\n\nUInt8\nUnsigned 8-bit integers.\n\n\nUUID\nA 128-bit number used to identify information in computer systems.\n\n\nUnknown\nAn unknown type.\n\n\nUnsignedInteger\nUnsigned integer values.\n\n\nVariadic\nValues with unknown size.\n\n\n\n\n\nexpr.datatypes.core.Array()\nArray values.\n\n\n\nexpr.datatypes.core.Binary()\n\n\nSome databases treat strings and blobs of equally, and some do not.\nFor example, Impala doesn’t make a distinction between string and binary types but PostgreSQL has a TEXT type and a BYTEA type which are distinct types that have different behavior.\n\n\n\n\nexpr.datatypes.core.Boolean()\n[True][True] or [False][False] values.\n\n\n\nexpr.datatypes.core.Bounds()\nThe lower and upper bound of a fixed-size value.\n\n\n\nexpr.datatypes.core.DataType()\nBase class for all data types.\n[DataType][ibis.expr.datatypes.DataType] instances are immutable.\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn the name of the data type.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dask\nReturn the equivalent ibis datatype.\n\n\nfrom_numpy\nReturn the equivalent ibis datatype.\n\n\nfrom_pandas\nReturn the equivalent ibis datatype.\n\n\nfrom_pyarrow\nReturn the equivalent ibis datatype.\n\n\nto_dask\nReturn the equivalent dask datatype.\n\n\nto_numpy\nReturn the equivalent numpy datatype.\n\n\nto_pandas\nReturn the equivalent pandas datatype.\n\n\nto_pyarrow\nReturn the equivalent pyarrow datatype.\n\n\n\n\n\nexpr.datatypes.core.DataType.from_dask(cls, dask_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_numpy(cls, numpy_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_pandas(cls, pandas_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_pyarrow(cls, arrow_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.to_dask(self)\nReturn the equivalent dask datatype.\n\n\n\nexpr.datatypes.core.DataType.to_numpy(self)\nReturn the equivalent numpy datatype.\n\n\n\nexpr.datatypes.core.DataType.to_pandas(self)\nReturn the equivalent pandas datatype.\n\n\n\nexpr.datatypes.core.DataType.to_pyarrow(self)\nReturn the equivalent pyarrow datatype.\n\n\n\n\n\nexpr.datatypes.core.Date()\nDate values.\n\n\n\nexpr.datatypes.core.Decimal(self, precision=None, scale=None, **kwargs)\nFixed-precision decimal values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of decimal.\n\n\nprecision\nThe number of decimal places values of this type can hold.\n\n\nscale\nThe number of values after the decimal point.\n\n\n\n\n\n\n\nexpr.datatypes.core.Float16()\n16-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Float32()\n32-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Float64()\n64-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Floating()\nFloating point values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of floating point values.\n\n\n\n\n\n\n\nexpr.datatypes.core.GeoSpatial()\nGeospatial values.\n\n\n\n\n\nName\nDescription\n\n\n\n\ngeotype\nThe specific geospatial type.\n\n\nsrid\nThe spatial reference identifier.\n\n\n\n\n\n\n\nexpr.datatypes.core.INET()\nIP addresses.\n\n\n\nexpr.datatypes.core.Int16()\nSigned 16-bit integers.\n\n\n\nexpr.datatypes.core.Int32()\nSigned 32-bit integers.\n\n\n\nexpr.datatypes.core.Int64()\nSigned 64-bit integers.\n\n\n\nexpr.datatypes.core.Int8()\nSigned 8-bit integers.\n\n\n\nexpr.datatypes.core.Integer()\nInteger values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nnbytes\nReturn the number of bytes used to store values of this type.\n\n\n\n\n\n\n\nexpr.datatypes.core.Interval()\nInterval values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nresolution\nThe interval unit’s name.\n\n\nunit\nThe time unit of the interval.\n\n\n\n\n\n\n\nexpr.datatypes.core.JSON()\nJSON values.\n\n\n\nexpr.datatypes.core.LineString()\nA sequence of 2 or more points.\n\n\n\nexpr.datatypes.core.MACADDR()\nMedia Access Control (MAC) address of a network interface.\n\n\n\nexpr.datatypes.core.Map()\nAssociative array values.\n\n\n\nexpr.datatypes.core.MultiLineString()\nA set of one or more line strings.\n\n\n\nexpr.datatypes.core.MultiPoint()\nA set of one or more points.\n\n\n\nexpr.datatypes.core.MultiPolygon()\nA set of one or more polygons.\n\n\n\nexpr.datatypes.core.Null()\nNull values.\n\n\n\nexpr.datatypes.core.Numeric()\nNumeric types.\n\n\n\nexpr.datatypes.core.Parametric()\nTypes that can be parameterized.\n\n\n\nexpr.datatypes.core.Point()\nA point described by two coordinates.\n\n\n\nexpr.datatypes.core.Polygon()\nA set of one or more closed line strings.\nThe first line string represents the shape (external ring) and the rest represent holes in that shape (internal rings).\n\n\n\nexpr.datatypes.core.Primitive()\nValues with known size.\n\n\n\nexpr.datatypes.core.SignedInteger()\nSigned integer values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of signed integer.\n\n\n\n\n\n\n\nexpr.datatypes.core.String()\n\n\nBecause of differences in the way different backends handle strings, we cannot assume that strings are UTF-8 encoded.\n\n\n\n\nexpr.datatypes.core.Struct()\nStructured values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_tuples\nConstruct a Struct type from pairs.\n\n\nnames\nReturn the names of the struct’s fields.\n\n\ntypes\nReturn the types of the struct’s fields.\n\n\n\n\n\nexpr.datatypes.core.Struct.from_tuples(cls, pairs, nullable=True)\nConstruct a Struct type from pairs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npairs\ntyping.Iterable[tuple[ibis.expr.datatypes.str, ibis.expr.datatypes.str | ibis.expr.datatypes.core.DataType]]\nAn iterable of pairs of field name and type\nrequired\n\n\nnullable\nbool\nWhether the type is nullable\nTrue\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nStruct\nStruct data type instance\n\n\n\n\n\n\n\nexpr.datatypes.core.Struct.names(self)\nReturn the names of the struct’s fields.\n\n\n\nexpr.datatypes.core.Struct.types(self)\nReturn the types of the struct’s fields.\n\n\n\n\n\nexpr.datatypes.core.Temporal()\nData types related to time.\n\n\n\nexpr.datatypes.core.Time()\nTime values.\n\n\n\nexpr.datatypes.core.Timestamp()\nTimestamp values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nscale\nThe scale of the timestamp if known.\n\n\ntimezone\nThe timezone of values of this type.\n\n\nunit\nReturn the unit of the timestamp.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_unit\nReturn a timestamp type with the given unit and timezone.\n\n\n\n\n\nexpr.datatypes.core.Timestamp.from_unit(cls, unit, timezone=None, nullable=True)\nReturn a timestamp type with the given unit and timezone.\n\n\n\n\n\nexpr.datatypes.core.UInt16()\nUnsigned 16-bit integers.\n\n\n\nexpr.datatypes.core.UInt32()\nUnsigned 32-bit integers.\n\n\n\nexpr.datatypes.core.UInt64()\nUnsigned 64-bit integers.\n\n\n\nexpr.datatypes.core.UInt8()\nUnsigned 8-bit integers.\n\n\n\nexpr.datatypes.core.UUID()\nA 128-bit number used to identify information in computer systems.\n\n\n\nexpr.datatypes.core.Unknown()\nAn unknown type.\n\n\n\nexpr.datatypes.core.UnsignedInteger()\nUnsigned integer values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of unsigned integer.\n\n\n\n\n\n\n\nexpr.datatypes.core.Variadic()\nValues with unknown size.\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndtype\nConstruct an ibis datatype from a python type.\n\n\n\n\n\nexpr.datatypes.core.dtype(value, nullable=True)\nConstruct an ibis datatype from a python type."
  },
  {
    "objectID": "reference/expr.datatypes.core.html#classes",
    "href": "reference/expr.datatypes.core.html#classes",
    "title": "expr.datatypes.core",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nArray\nArray values.\n\n\nBinary\nA type representing a sequence of bytes.\n\n\nBoolean\n[True][True] or [False][False] values.\n\n\nBounds\nThe lower and upper bound of a fixed-size value.\n\n\nDataType\nBase class for all data types.\n\n\nDate\nDate values.\n\n\nDecimal\nFixed-precision decimal values.\n\n\nFloat16\n16-bit floating point numbers.\n\n\nFloat32\n32-bit floating point numbers.\n\n\nFloat64\n64-bit floating point numbers.\n\n\nFloating\nFloating point values.\n\n\nGeoSpatial\nGeospatial values.\n\n\nINET\nIP addresses.\n\n\nInt16\nSigned 16-bit integers.\n\n\nInt32\nSigned 32-bit integers.\n\n\nInt64\nSigned 64-bit integers.\n\n\nInt8\nSigned 8-bit integers.\n\n\nInteger\nInteger values.\n\n\nInterval\nInterval values.\n\n\nJSON\nJSON values.\n\n\nLineString\nA sequence of 2 or more points.\n\n\nMACADDR\nMedia Access Control (MAC) address of a network interface.\n\n\nMap\nAssociative array values.\n\n\nMultiLineString\nA set of one or more line strings.\n\n\nMultiPoint\nA set of one or more points.\n\n\nMultiPolygon\nA set of one or more polygons.\n\n\nNull\nNull values.\n\n\nNumeric\nNumeric types.\n\n\nParametric\nTypes that can be parameterized.\n\n\nPoint\nA point described by two coordinates.\n\n\nPolygon\nA set of one or more closed line strings.\n\n\nPrimitive\nValues with known size.\n\n\nSignedInteger\nSigned integer values.\n\n\nString\nA type representing a string.\n\n\nStruct\nStructured values.\n\n\nTemporal\nData types related to time.\n\n\nTime\nTime values.\n\n\nTimestamp\nTimestamp values.\n\n\nUInt16\nUnsigned 16-bit integers.\n\n\nUInt32\nUnsigned 32-bit integers.\n\n\nUInt64\nUnsigned 64-bit integers.\n\n\nUInt8\nUnsigned 8-bit integers.\n\n\nUUID\nA 128-bit number used to identify information in computer systems.\n\n\nUnknown\nAn unknown type.\n\n\nUnsignedInteger\nUnsigned integer values.\n\n\nVariadic\nValues with unknown size.\n\n\n\n\n\nexpr.datatypes.core.Array()\nArray values.\n\n\n\nexpr.datatypes.core.Binary()\n\n\nSome databases treat strings and blobs of equally, and some do not.\nFor example, Impala doesn’t make a distinction between string and binary types but PostgreSQL has a TEXT type and a BYTEA type which are distinct types that have different behavior.\n\n\n\n\nexpr.datatypes.core.Boolean()\n[True][True] or [False][False] values.\n\n\n\nexpr.datatypes.core.Bounds()\nThe lower and upper bound of a fixed-size value.\n\n\n\nexpr.datatypes.core.DataType()\nBase class for all data types.\n[DataType][ibis.expr.datatypes.DataType] instances are immutable.\n\n\n\n\n\nName\nDescription\n\n\n\n\nname\nReturn the name of the data type.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_dask\nReturn the equivalent ibis datatype.\n\n\nfrom_numpy\nReturn the equivalent ibis datatype.\n\n\nfrom_pandas\nReturn the equivalent ibis datatype.\n\n\nfrom_pyarrow\nReturn the equivalent ibis datatype.\n\n\nto_dask\nReturn the equivalent dask datatype.\n\n\nto_numpy\nReturn the equivalent numpy datatype.\n\n\nto_pandas\nReturn the equivalent pandas datatype.\n\n\nto_pyarrow\nReturn the equivalent pyarrow datatype.\n\n\n\n\n\nexpr.datatypes.core.DataType.from_dask(cls, dask_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_numpy(cls, numpy_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_pandas(cls, pandas_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.from_pyarrow(cls, arrow_type, nullable=True)\nReturn the equivalent ibis datatype.\n\n\n\nexpr.datatypes.core.DataType.to_dask(self)\nReturn the equivalent dask datatype.\n\n\n\nexpr.datatypes.core.DataType.to_numpy(self)\nReturn the equivalent numpy datatype.\n\n\n\nexpr.datatypes.core.DataType.to_pandas(self)\nReturn the equivalent pandas datatype.\n\n\n\nexpr.datatypes.core.DataType.to_pyarrow(self)\nReturn the equivalent pyarrow datatype.\n\n\n\n\n\nexpr.datatypes.core.Date()\nDate values.\n\n\n\nexpr.datatypes.core.Decimal(self, precision=None, scale=None, **kwargs)\nFixed-precision decimal values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of decimal.\n\n\nprecision\nThe number of decimal places values of this type can hold.\n\n\nscale\nThe number of values after the decimal point.\n\n\n\n\n\n\n\nexpr.datatypes.core.Float16()\n16-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Float32()\n32-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Float64()\n64-bit floating point numbers.\n\n\n\nexpr.datatypes.core.Floating()\nFloating point values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of floating point values.\n\n\n\n\n\n\n\nexpr.datatypes.core.GeoSpatial()\nGeospatial values.\n\n\n\n\n\nName\nDescription\n\n\n\n\ngeotype\nThe specific geospatial type.\n\n\nsrid\nThe spatial reference identifier.\n\n\n\n\n\n\n\nexpr.datatypes.core.INET()\nIP addresses.\n\n\n\nexpr.datatypes.core.Int16()\nSigned 16-bit integers.\n\n\n\nexpr.datatypes.core.Int32()\nSigned 32-bit integers.\n\n\n\nexpr.datatypes.core.Int64()\nSigned 64-bit integers.\n\n\n\nexpr.datatypes.core.Int8()\nSigned 8-bit integers.\n\n\n\nexpr.datatypes.core.Integer()\nInteger values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nnbytes\nReturn the number of bytes used to store values of this type.\n\n\n\n\n\n\n\nexpr.datatypes.core.Interval()\nInterval values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nresolution\nThe interval unit’s name.\n\n\nunit\nThe time unit of the interval.\n\n\n\n\n\n\n\nexpr.datatypes.core.JSON()\nJSON values.\n\n\n\nexpr.datatypes.core.LineString()\nA sequence of 2 or more points.\n\n\n\nexpr.datatypes.core.MACADDR()\nMedia Access Control (MAC) address of a network interface.\n\n\n\nexpr.datatypes.core.Map()\nAssociative array values.\n\n\n\nexpr.datatypes.core.MultiLineString()\nA set of one or more line strings.\n\n\n\nexpr.datatypes.core.MultiPoint()\nA set of one or more points.\n\n\n\nexpr.datatypes.core.MultiPolygon()\nA set of one or more polygons.\n\n\n\nexpr.datatypes.core.Null()\nNull values.\n\n\n\nexpr.datatypes.core.Numeric()\nNumeric types.\n\n\n\nexpr.datatypes.core.Parametric()\nTypes that can be parameterized.\n\n\n\nexpr.datatypes.core.Point()\nA point described by two coordinates.\n\n\n\nexpr.datatypes.core.Polygon()\nA set of one or more closed line strings.\nThe first line string represents the shape (external ring) and the rest represent holes in that shape (internal rings).\n\n\n\nexpr.datatypes.core.Primitive()\nValues with known size.\n\n\n\nexpr.datatypes.core.SignedInteger()\nSigned integer values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of signed integer.\n\n\n\n\n\n\n\nexpr.datatypes.core.String()\n\n\nBecause of differences in the way different backends handle strings, we cannot assume that strings are UTF-8 encoded.\n\n\n\n\nexpr.datatypes.core.Struct()\nStructured values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_tuples\nConstruct a Struct type from pairs.\n\n\nnames\nReturn the names of the struct’s fields.\n\n\ntypes\nReturn the types of the struct’s fields.\n\n\n\n\n\nexpr.datatypes.core.Struct.from_tuples(cls, pairs, nullable=True)\nConstruct a Struct type from pairs.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npairs\ntyping.Iterable[tuple[ibis.expr.datatypes.str, ibis.expr.datatypes.str | ibis.expr.datatypes.core.DataType]]\nAn iterable of pairs of field name and type\nrequired\n\n\nnullable\nbool\nWhether the type is nullable\nTrue\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nStruct\nStruct data type instance\n\n\n\n\n\n\n\nexpr.datatypes.core.Struct.names(self)\nReturn the names of the struct’s fields.\n\n\n\nexpr.datatypes.core.Struct.types(self)\nReturn the types of the struct’s fields.\n\n\n\n\n\nexpr.datatypes.core.Temporal()\nData types related to time.\n\n\n\nexpr.datatypes.core.Time()\nTime values.\n\n\n\nexpr.datatypes.core.Timestamp()\nTimestamp values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nscale\nThe scale of the timestamp if known.\n\n\ntimezone\nThe timezone of values of this type.\n\n\nunit\nReturn the unit of the timestamp.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\nfrom_unit\nReturn a timestamp type with the given unit and timezone.\n\n\n\n\n\nexpr.datatypes.core.Timestamp.from_unit(cls, unit, timezone=None, nullable=True)\nReturn a timestamp type with the given unit and timezone.\n\n\n\n\n\nexpr.datatypes.core.UInt16()\nUnsigned 16-bit integers.\n\n\n\nexpr.datatypes.core.UInt32()\nUnsigned 32-bit integers.\n\n\n\nexpr.datatypes.core.UInt64()\nUnsigned 64-bit integers.\n\n\n\nexpr.datatypes.core.UInt8()\nUnsigned 8-bit integers.\n\n\n\nexpr.datatypes.core.UUID()\nA 128-bit number used to identify information in computer systems.\n\n\n\nexpr.datatypes.core.Unknown()\nAn unknown type.\n\n\n\nexpr.datatypes.core.UnsignedInteger()\nUnsigned integer values.\n\n\n\n\n\nName\nDescription\n\n\n\n\nlargest\nReturn the largest type of unsigned integer.\n\n\n\n\n\n\n\nexpr.datatypes.core.Variadic()\nValues with unknown size."
  },
  {
    "objectID": "reference/expr.datatypes.core.html#functions",
    "href": "reference/expr.datatypes.core.html#functions",
    "title": "expr.datatypes.core",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndtype\nConstruct an ibis datatype from a python type.\n\n\n\n\n\nexpr.datatypes.core.dtype(value, nullable=True)\nConstruct an ibis datatype from a python type."
  },
  {
    "objectID": "reference/expression-geospatial.html",
    "href": "reference/expression-geospatial.html",
    "title": "Geospatial Expressions",
    "section": "",
    "text": "Ibis supports the following geospatial expression APIs"
  },
  {
    "objectID": "reference/expression-geospatial.html#methods",
    "href": "reference/expression-geospatial.html#methods",
    "title": "Geospatial Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\narea\nCompute the area of a geospatial value.\n\n\nas_binary\nGet the geometry as well-known bytes (WKB) without the SRID data.\n\n\nas_ewkb\nGet the geometry as well-known bytes (WKB) with the SRID data.\n\n\nas_ewkt\nGet the geometry as well-known text (WKT) with the SRID data.\n\n\nas_text\nGet the geometry as well-known text (WKT) without the SRID data.\n\n\nazimuth\nReturn the angle in radians from the horizontal of the vector defined by the inputs.\n\n\nbuffer\nReturn all points whose distance from this geometry is less than or equal to radius.\n\n\ncentroid\nReturns the centroid of the geometry.\n\n\ncontains\nCheck if the geometry contains the right.\n\n\ncontains_properly\nCheck if the first geometry contains the second one.\n\n\ncovered_by\nCheck if the first geometry is covered by the second one.\n\n\ncovers\nCheck if the first geometry covers the second one.\n\n\ncrosses\nCheck if the geometries have at least one interior point in common.\n\n\nd_fully_within\nCheck if self is entirely within distance from right.\n\n\nd_within\nCheck if self is partially within distance from right.\n\n\ndifference\nReturn the difference of two geometries.\n\n\ndisjoint\nCheck if the geometries have no points in common.\n\n\ndistance\nCompute the distance between two geospatial expressions.\n\n\nend_point\nReturn the last point of a LINESTRING geometry as a POINT.\n\n\nenvelope\nReturns a geometry representing the bounding box of self.\n\n\ngeo_equals\nCheck if the geometries are equal.\n\n\ngeometry_n\nGet the 1-based Nth geometry of a multi geometry.\n\n\ngeometry_type\nGet the type of a geometry.\n\n\nintersection\nReturn the intersection of two geometries.\n\n\nintersects\nCheck if the geometries share any points.\n\n\nis_valid\nCheck if the geometry is valid.\n\n\nlength\nCompute the length of a geospatial expression.\n\n\nline_locate_point\nLocate the distance a point falls along the length of a line.\n\n\nline_merge\nMerge a MultiLineString into a LineString.\n\n\nline_substring\nClip a substring from a LineString.\n\n\nmax_distance\nReturns the 2-dimensional max distance between two geometries in projected units.\n\n\nn_points\nReturn the number of points in a geometry. Works for all geometries.\n\n\nn_rings\nReturn the number of rings for polygons and multipolygons.\n\n\nordering_equals\nCheck if two geometries are equal and have the same point ordering.\n\n\noverlaps\nCheck if the geometries share space, have the same dimension, and are not completely contained by each other.\n\n\nperimeter\nCompute the perimeter of a geospatial expression.\n\n\npoint_n\nReturn the Nth point in a single linestring in the geometry.\n\n\nset_srid\nSet the spatial reference identifier for the ST_Geometry.\n\n\nsimplify\nSimplify a given geometry.\n\n\nsrid\nReturn the spatial reference identifier for the ST_Geometry.\n\n\nstart_point\nReturn the first point of a LINESTRING geometry as a POINT.\n\n\ntouches\nCheck if the geometries have at least one point in common, but do not intersect.\n\n\ntransform\nTransform a geometry into a new SRID.\n\n\nunion\nMerge two geometries into a union geometry.\n\n\nwithin\nCheck if the first geometry is completely inside of the second.\n\n\nx\nReturn the X coordinate of self, or NULL if not available.\n\n\nx_max\nReturn the X maxima of a geometry.\n\n\nx_min\nReturn the X minima of a geometry.\n\n\ny\nReturn the Y coordinate of self, or NULL if not available.\n\n\ny_max\nReturn the Y maxima of a geometry.\n\n\ny_min\nReturn the Y minima of a geometry.\n\n\n\n\narea\nexpr.types.geospatial.GeoSpatialValue.area(self)\nCompute the area of a geospatial value.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nThe area of self\n\n\n\n\n\n\nas_binary\nexpr.types.geospatial.GeoSpatialValue.as_binary(self)\nGet the geometry as well-known bytes (WKB) without the SRID data.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBinaryValue\nBinary value\n\n\n\n\n\n\nas_ewkb\nexpr.types.geospatial.GeoSpatialValue.as_ewkb(self)\nGet the geometry as well-known bytes (WKB) with the SRID data.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBinaryValue\nWKB value\n\n\n\n\n\n\nas_ewkt\nexpr.types.geospatial.GeoSpatialValue.as_ewkt(self)\nGet the geometry as well-known text (WKT) with the SRID data.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nString value\n\n\n\n\n\n\nas_text\nexpr.types.geospatial.GeoSpatialValue.as_text(self)\nGet the geometry as well-known text (WKT) without the SRID data.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nString value\n\n\n\n\n\n\nazimuth\nexpr.types.geospatial.GeoSpatialValue.azimuth(self, right)\nReturn the angle in radians from the horizontal of the vector defined by the inputs.\nAngle is computed clockwise from down-to-up on the clock: 12=0; 3=PI/2; 6=PI; 9=3PI/2.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nazimuth\n\n\n\n\n\n\nbuffer\nexpr.types.geospatial.GeoSpatialValue.buffer(self, radius)\nReturn all points whose distance from this geometry is less than or equal to radius.\nCalculations are in the Spatial Reference System of this Geometry.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nradius\nfloat | ibis.FloatingValue\nFloating expression\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nGeometry expression\n\n\n\n\n\n\ncentroid\nexpr.types.geospatial.GeoSpatialValue.centroid(self)\nReturns the centroid of the geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPointValue\nThe centroid\n\n\n\n\n\n\ncontains\nexpr.types.geospatial.GeoSpatialValue.contains(self, right)\nCheck if the geometry contains the right.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self contains right\n\n\n\n\n\n\ncontains_properly\nexpr.types.geospatial.GeoSpatialValue.contains_properly(self, right)\nCheck if the first geometry contains the second one.\nExcludes common border points.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self contains right excluding border points.\n\n\n\n\n\n\ncovered_by\nexpr.types.geospatial.GeoSpatialValue.covered_by(self, right)\nCheck if the first geometry is covered by the second one.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self is covered by right\n\n\n\n\n\n\ncovers\nexpr.types.geospatial.GeoSpatialValue.covers(self, right)\nCheck if the first geometry covers the second one.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self covers right\n\n\n\n\n\n\ncrosses\nexpr.types.geospatial.GeoSpatialValue.crosses(self, right)\nCheck if the geometries have at least one interior point in common.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self and right have at least one common interior point.\n\n\n\n\n\n\nd_fully_within\nexpr.types.geospatial.GeoSpatialValue.d_fully_within(self, right, distance)\nCheck if self is entirely within distance from right.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\ndistance\nibis.FloatingValue\nDistance to check\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self is within a specified distance from right.\n\n\n\n\n\n\nd_within\nexpr.types.geospatial.GeoSpatialValue.d_within(self, right, distance)\nCheck if self is partially within distance from right.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\ndistance\nibis.FloatingValue\nDistance to check\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self is partially within distance from right.\n\n\n\n\n\n\ndifference\nexpr.types.geospatial.GeoSpatialValue.difference(self, right)\nReturn the difference of two geometries.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nDifference of self and right\n\n\n\n\n\n\ndisjoint\nexpr.types.geospatial.GeoSpatialValue.disjoint(self, right)\nCheck if the geometries have no points in common.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self and right are disjoint\n\n\n\n\n\n\ndistance\nexpr.types.geospatial.GeoSpatialValue.distance(self, right)\nCompute the distance between two geospatial expressions.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry or geography\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nDistance between self and right\n\n\n\n\n\n\nend_point\nexpr.types.geospatial.GeoSpatialValue.end_point(self)\nReturn the last point of a LINESTRING geometry as a POINT.\nReturn NULL if the input parameter is not a LINESTRING\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPointValue\nEnd point\n\n\n\n\n\n\nenvelope\nexpr.types.geospatial.GeoSpatialValue.envelope(self)\nReturns a geometry representing the bounding box of self.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPolygonValue\nA polygon\n\n\n\n\n\n\ngeo_equals\nexpr.types.geospatial.GeoSpatialValue.geo_equals(self, right)\nCheck if the geometries are equal.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self equals right\n\n\n\n\n\n\ngeometry_n\nexpr.types.geospatial.GeoSpatialValue.geometry_n(self, n)\nGet the 1-based Nth geometry of a multi geometry.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint | ibis.IntegerValue\nNth geometry index\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nGeometry value\n\n\n\n\n\n\ngeometry_type\nexpr.types.geospatial.GeoSpatialValue.geometry_type(self)\nGet the type of a geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nString representing the type of self.\n\n\n\n\n\n\nintersection\nexpr.types.geospatial.GeoSpatialValue.intersection(self, right)\nReturn the intersection of two geometries.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nIntersection of self and right\n\n\n\n\n\n\nintersects\nexpr.types.geospatial.GeoSpatialValue.intersects(self, right)\nCheck if the geometries share any points.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self intersects right\n\n\n\n\n\n\nis_valid\nexpr.types.geospatial.GeoSpatialValue.is_valid(self)\nCheck if the geometry is valid.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self is valid\n\n\n\n\n\n\nlength\nexpr.types.geospatial.GeoSpatialValue.length(self)\nCompute the length of a geospatial expression.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nLength of self\n\n\n\n\n\n\nline_locate_point\nexpr.types.geospatial.GeoSpatialValue.line_locate_point(self, right)\nLocate the distance a point falls along the length of a line.\nReturns a float between zero and one representing the location of the closest point on the linestring to the given point, as a fraction of the total 2d line length.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nPointValue\nPoint geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nFraction of the total line length\n\n\n\n\n\n\nline_merge\nexpr.types.geospatial.GeoSpatialValue.line_merge(self)\nMerge a MultiLineString into a LineString.\nReturns a (set of) LineString(s) formed by sewing together the constituent line work of a MultiLineString. If a geometry other than a LineString or MultiLineString is given, this will return an empty geometry collection.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nMerged linestrings\n\n\n\n\n\n\nline_substring\nexpr.types.geospatial.GeoSpatialValue.line_substring(self, start, end)\nClip a substring from a LineString.\nReturns a linestring that is a substring of the input one, starting and ending at the given fractions of the total 2d length. The second and third arguments are floating point values between zero and one. This only works with linestrings.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nibis.FloatingValue\nStart value\nrequired\n\n\nend\nibis.FloatingValue\nEnd value\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nLineStringValue\nClipped linestring\n\n\n\n\n\n\nmax_distance\nexpr.types.geospatial.GeoSpatialValue.max_distance(self, right)\nReturns the 2-dimensional max distance between two geometries in projected units.\nIf self and right are the same geometry the function will return the distance between the two vertices most far from each other in that geometry.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nMaximum distance\n\n\n\n\n\n\nn_points\nexpr.types.geospatial.GeoSpatialValue.n_points(self)\nReturn the number of points in a geometry. Works for all geometries.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nNumber of points\n\n\n\n\n\n\nn_rings\nexpr.types.geospatial.GeoSpatialValue.n_rings(self)\nReturn the number of rings for polygons and multipolygons.\nOuter rings are counted as well.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nNumber of rings\n\n\n\n\n\n\nordering_equals\nexpr.types.geospatial.GeoSpatialValue.ordering_equals(self, right)\nCheck if two geometries are equal and have the same point ordering.\nReturns true if the two geometries are equal and the coordinates are in the same order.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether points and orderings are equal.\n\n\n\n\n\n\noverlaps\nexpr.types.geospatial.GeoSpatialValue.overlaps(self, right)\nCheck if the geometries share space, have the same dimension, and are not completely contained by each other.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nOverlaps indicator\n\n\n\n\n\n\nperimeter\nexpr.types.geospatial.GeoSpatialValue.perimeter(self)\nCompute the perimeter of a geospatial expression.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nPerimeter of self\n\n\n\n\n\n\npoint_n\nexpr.types.geospatial.GeoSpatialValue.point_n(self, n)\nReturn the Nth point in a single linestring in the geometry.\nNegative values are counted backwards from the end of the LineString, so that -1 is the last point. Returns NULL if there is no linestring in the geometry.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nibis.IntegerValue\nNth point index\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPointValue\nNth point in self\n\n\n\n\n\n\nset_srid\nexpr.types.geospatial.GeoSpatialValue.set_srid(self, srid)\nSet the spatial reference identifier for the ST_Geometry.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsrid\nibis.IntegerValue\nSRID integer value\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nself with SRID set to srid\n\n\n\n\n\n\nsimplify\nexpr.types.geospatial.GeoSpatialValue.simplify(self, tolerance, preserve_collapsed)\nSimplify a given geometry.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntolerance\nibis.FloatingValue\nTolerance\nrequired\n\n\npreserve_collapsed\nibis.BooleanValue\nWhether to preserve collapsed geometries\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nSimplified geometry\n\n\n\n\n\n\nsrid\nexpr.types.geospatial.GeoSpatialValue.srid(self)\nReturn the spatial reference identifier for the ST_Geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nSRID\n\n\n\n\n\n\nstart_point\nexpr.types.geospatial.GeoSpatialValue.start_point(self)\nReturn the first point of a LINESTRING geometry as a POINT.\nReturn NULL if the input parameter is not a LINESTRING\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPointValue\nStart point\n\n\n\n\n\n\ntouches\nexpr.types.geospatial.GeoSpatialValue.touches(self, right)\nCheck if the geometries have at least one point in common, but do not intersect.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self and right are touching\n\n\n\n\n\n\ntransform\nexpr.types.geospatial.GeoSpatialValue.transform(self, srid)\nTransform a geometry into a new SRID.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsrid\nibis.IntegerValue\nInteger expression\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nTransformed geometry\n\n\n\n\n\n\nunion\nexpr.types.geospatial.GeoSpatialValue.union(self, right)\nMerge two geometries into a union geometry.\nReturns the pointwise union of the two geometries. This corresponds to the non-aggregate version the PostGIS ST_Union.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialValue\nUnion of geometries\n\n\n\n\n\n\nwithin\nexpr.types.geospatial.GeoSpatialValue.within(self, right)\nCheck if the first geometry is completely inside of the second.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nGeoSpatialValue\nRight geometry\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nWhether self is in right.\n\n\n\n\n\n\nx\nexpr.types.geospatial.GeoSpatialValue.x(self)\nReturn the X coordinate of self, or NULL if not available.\nInput must be a point.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nX coordinate of self\n\n\n\n\n\n\nx_max\nexpr.types.geospatial.GeoSpatialValue.x_max(self)\nReturn the X maxima of a geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nX maxima\n\n\n\n\n\n\nx_min\nexpr.types.geospatial.GeoSpatialValue.x_min(self)\nReturn the X minima of a geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nX minima\n\n\n\n\n\n\ny\nexpr.types.geospatial.GeoSpatialValue.y(self)\nReturn the Y coordinate of self, or NULL if not available.\nInput must be a point.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nY coordinate of self\n\n\n\n\n\n\ny_max\nexpr.types.geospatial.GeoSpatialValue.y_max(self)\nReturn the Y maxima of a geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nY maxima\n\n\n\n\n\n\ny_min\nexpr.types.geospatial.GeoSpatialValue.y_min(self)\nReturn the Y minima of a geometry.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nFloatingValue\nY minima"
  },
  {
    "objectID": "reference/expression-geospatial.html#methods-1",
    "href": "reference/expression-geospatial.html#methods-1",
    "title": "Geospatial Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nunary_union\nAggregate a set of geometries into a union.\n\n\n\n\nunary_union\nexpr.types.geospatial.GeoSpatialColumn.unary_union(self)\nAggregate a set of geometries into a union.\nThis corresponds to the aggregate version of the PostGIS ST_Union. We give it a different name (following the corresponding method in GeoPandas) to avoid name conflicts with the non-aggregate version.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGeoSpatialScalar\nUnion of geometries"
  },
  {
    "objectID": "reference/temporal.html",
    "href": "reference/temporal.html",
    "title": "temporal",
    "section": "",
    "text": "expr.types.temporal\n\n\n\n\n\nName\nDescription\n\n\n\n\nDayOfWeek\nA namespace of methods for extracting day of week information.\n\n\n\n\n\nexpr.types.temporal.DayOfWeek(self, expr)\nA namespace of methods for extracting day of week information.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_name\nGet the name of the day of the week.\n\n\nindex\nGet the index of the day of the week.\n\n\n\n\n\nexpr.types.temporal.DayOfWeek.full_name(self)\nGet the name of the day of the week.\n\n\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nThe name of the day of the week\n\n\n\n\n\n\n\nexpr.types.temporal.DayOfWeek.index(self)\nGet the index of the day of the week.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe index of the day of the week. !!! note “Ibis follows pandas’ conventions for day numbers: Monday = 0 and Sunday = 6.”"
  },
  {
    "objectID": "reference/temporal.html#classes",
    "href": "reference/temporal.html#classes",
    "title": "temporal",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nDayOfWeek\nA namespace of methods for extracting day of week information.\n\n\n\n\n\nexpr.types.temporal.DayOfWeek(self, expr)\nA namespace of methods for extracting day of week information.\n\n\n\n\n\nName\nDescription\n\n\n\n\nfull_name\nGet the name of the day of the week.\n\n\nindex\nGet the index of the day of the week.\n\n\n\n\n\nexpr.types.temporal.DayOfWeek.full_name(self)\nGet the name of the day of the week.\n\n\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nThe name of the day of the week\n\n\n\n\n\n\n\nexpr.types.temporal.DayOfWeek.index(self)\nGet the index of the day of the week.\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe index of the day of the week. !!! note “Ibis follows pandas’ conventions for day numbers: Monday = 0 and Sunday = 6.”"
  },
  {
    "objectID": "reference/config.Options.html",
    "href": "reference/config.Options.html",
    "title": "config.Options",
    "section": "",
    "text": "config.Options()\nIbis configuration options.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ninteractive\nbool\nShow the first few rows of computing an expression when in a repl.\n\n\nrepr\nRepr\nOptions controlling expression printing.\n\n\nverbose\nbool\nRun in verbose mode if [True][True]\n\n\nverbose_log\ntyping.Callable[[str], None] | None\nA callable to use when logging.\n\n\ngraphviz_repr\nbool\nRender expressions as GraphViz PNGs when running in a Jupyter notebook.\n\n\ndefault_backend\nOptional[ibis.backends.base.BaseBackend], default None\nThe default backend to use for execution, defaults to DuckDB if not set.\n\n\ncontext_adjustment\nContextAdjustment\nOptions related to time context adjustment.\n\n\nsql\nSQL\nSQL-related options.\n\n\nclickhouse\nibis.config.Config | None\nClickhouse specific options.\n\n\ndask\nibis.config.Config | None\nDask specific options.\n\n\nimpala\nibis.config.Config | None\nImpala specific options.\n\n\npandas\nibis.config.Config | None\nPandas specific options.\n\n\npyspark\nibis.config.Config | None\nPySpark specific options."
  },
  {
    "objectID": "reference/config.Options.html#attributes",
    "href": "reference/config.Options.html#attributes",
    "title": "config.Options",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ninteractive\nbool\nShow the first few rows of computing an expression when in a repl.\n\n\nrepr\nRepr\nOptions controlling expression printing.\n\n\nverbose\nbool\nRun in verbose mode if [True][True]\n\n\nverbose_log\ntyping.Callable[[str], None] | None\nA callable to use when logging.\n\n\ngraphviz_repr\nbool\nRender expressions as GraphViz PNGs when running in a Jupyter notebook.\n\n\ndefault_backend\nOptional[ibis.backends.base.BaseBackend], default None\nThe default backend to use for execution, defaults to DuckDB if not set.\n\n\ncontext_adjustment\nContextAdjustment\nOptions related to time context adjustment.\n\n\nsql\nSQL\nSQL-related options.\n\n\nclickhouse\nibis.config.Config | None\nClickhouse specific options.\n\n\ndask\nibis.config.Config | None\nDask specific options.\n\n\nimpala\nibis.config.Config | None\nImpala specific options.\n\n\npandas\nibis.config.Config | None\nPandas specific options.\n\n\npyspark\nibis.config.Config | None\nPySpark specific options."
  },
  {
    "objectID": "reference/expression-tables.html",
    "href": "reference/expression-tables.html",
    "title": "Table Expressions",
    "section": "",
    "text": "Table expressions form the basis for most Ibis expressions."
  },
  {
    "objectID": "reference/expression-tables.html#attributes",
    "href": "reference/expression-tables.html#attributes",
    "title": "Table Expressions",
    "section": "Attributes",
    "text": "Attributes\n\n\n\nName\nDescription\n\n\n\n\ncolumns\nThe list of columns in this table."
  },
  {
    "objectID": "reference/expression-tables.html#methods",
    "href": "reference/expression-tables.html#methods",
    "title": "Table Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\naggregate\nAggregate a table with a given set of reductions grouping by by.\n\n\nalias\nCreate a table expression with a specific name alias.\n\n\nas_table\nPromote the expression to a table.\n\n\nasof_join\nPerform an “as-of” join between left and right.\n\n\ncache\nCache the provided expression.\n\n\ncast\nCast the columns of a table.\n\n\ncount\nCompute the number of rows in the table.\n\n\ncross_join\nCompute the cross join of a sequence of tables.\n\n\ndifference\nCompute the set difference of multiple table expressions.\n\n\ndistinct\nReturn a Table with duplicate rows removed.\n\n\ndrop\nRemove fields from a table.\n\n\ndropna\nRemove rows with null values from the table.\n\n\nfillna\nFill null values in a table expression.\n\n\nfilter\nSelect rows from table based on predicates.\n\n\ngroup_by\nCreate a grouped table expression.\n\n\nhead\nSelect the first n rows of a table.\n\n\ninfo\nReturn summary information about a table.\n\n\nintersect\nCompute the set intersection of multiple table expressions.\n\n\njoin\nPerform a join between two tables.\n\n\nlimit\nSelect n rows from self starting at offset.\n\n\nmutate\nAdd columns to a table expression.\n\n\norder_by\nSort a table by one or more expressions.\n\n\npivot_longer\nTransform a table from wider to longer.\n\n\npivot_wider\nPivot a table to a wider format.\n\n\nrelabel\nRename columns in the table.\n\n\nrowid\nA unique integer per row.\n\n\nschema\nReturn the schema for this table.\n\n\nselect\nCompute a new table expression using exprs and named_exprs.\n\n\nsql\nRun a SQL query against a table expression.\n\n\nto_array\nView a single column table as an array.\n\n\nto_pandas\nConvert a table expression to a pandas DataFrame.\n\n\ntry_cast\nCast the columns of a table.\n\n\nunion\nCompute the set union of multiple table expressions.\n\n\nunpack\nProject the struct fields of each of columns into self.\n\n\nview\nCreate a new table expression distinct from the current one.\n\n\n\n\naggregate\nexpr.types.relations.Table.aggregate(self, metrics=None, by=None, having=None, **kwargs)\nAggregate a table with a given set of reductions grouping by by.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nmetrics\ntyping.Sequence[ibis.Scalar] | None\nAggregate expressions. These can be any scalar-producing expression, including aggregation functions like sum or literal values like ibis.literal(1).\nNone\n\n\nby\ntyping.Sequence[ibis.Value] | None\nGrouping expressions.\nNone\n\n\nhaving\ntyping.Sequence[ibis.BooleanValue] | None\nPost-aggregation filters. The shape requirements are the same metrics, but the output type for having is boolean. !!! warning “Expressions like x is None return bool and will not generate a SQL comparison to NULL”\nNone\n\n\nkwargs\nibis.Value\nNamed aggregate expressions\n{}\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nAn aggregate table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"fruit\": [\"apple\", \"apple\", \"banana\", \"orange\"], \"price\": [0.5, 0.5, 0.25, 0.33]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┳━━━━━━━━━┓\n┃ fruit  ┃ price   ┃\n┡━━━━━━━━╇━━━━━━━━━┩\n│ string │ float64 │\n├────────┼─────────┤\n│ apple  │    0.50 │\n│ apple  │    0.50 │\n│ banana │    0.25 │\n│ orange │    0.33 │\n└────────┴─────────┘\n&gt;&gt;&gt; t.aggregate(by=[\"fruit\"], total_cost=_.price.sum(), avg_cost=_.price.mean(), having=_.price.sum() &lt; 0.5)\n┏━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━┓\n┃ fruit  ┃ total_cost ┃ avg_cost ┃\n┡━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━┩\n│ string │ float64    │ float64  │\n├────────┼────────────┼──────────┤\n│ banana │       0.25 │     0.25 │\n│ orange │       0.33 │     0.33 │\n└────────┴────────────┴──────────┘\n\n\n\nalias\nexpr.types.relations.Table.alias(self, alias)\nCreate a table expression with a specific name alias.\nThis method is useful for exposing an ibis expression to the underlying backend for use in the [Table.sql][ibis.expr.types.relations.Table.sql] method.\n!!! note “.alias will create a temporary view”\n`.alias` creates a temporary view in the database.\n\nThis side effect will be removed in a future version of ibis and\n**is not part of the public API**.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalias\nstr\nName of the child expression\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nAn table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; expr = t.alias(\"pingüinos\").sql('SELECT * FROM \"pingüinos\" LIMIT 5')\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\nas_table\nexpr.types.relations.Table.as_table(self)\nPromote the expression to a table.\nThis method is a no-op for table expressions.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; t = ibis.table(dict(a=\"int\"), name=\"t\")\n&gt;&gt;&gt; s = t.as_table()\n&gt;&gt;&gt; t is s\nTrue\n\n\n\nasof_join\nexpr.types.relations.Table.asof_join(left, right, predicates=(), by=(), tolerance=None, *, lname='', rname='{name}_right')\nPerform an “as-of” join between left and right.\nSimilar to a left join except that the match is done on nearest key rather than equal keys.\nOptionally, match keys with by before joining with predicates.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nleft\nTable\nTable expression\nrequired\n\n\nright\nTable\nTable expression\nrequired\n\n\npredicates\nstr | ibis.BooleanColumn | typing.Sequence[str | ibis.BooleanColumn]\nJoin expressions\n()\n\n\nby\nstr | ibis.Column | typing.Sequence[str | ibis.Column]\ncolumn to group by before joining\n()\n\n\ntolerance\nstr | ibis.IntervalScalar | None\nAmount of time to look behind when joining\nNone\n\n\nlname\nstr\nA format string to use to rename overlapping columns in the left table (e.g. \"left_{name}\").\n''\n\n\nrname\nstr\nA format string to use to rename overlapping columns in the right table (e.g. \"right_{name}\").\n'{name}_right'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\n\ncache\nexpr.types.relations.Table.cache(self)\nCache the provided expression.\nAll subsequent operations on the returned expression will be performed on the cached data. Use the with statement to limit the lifetime of a cached table.\nThis method is idempotent: calling it multiple times in succession will return the same value as the first call.\n!!! note “This method eagerly evaluates the expression prior to caching”\nSubsequent evaluations will not recompute the expression so method\nchaining will not incur the overhead of caching more than once.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nCached table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; cached_penguins = t.mutate(computation=\"Heavy Computation\").cache()\n&gt;&gt;&gt; cached_penguins\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\nExplicit cache cleanup\n&gt;&gt;&gt; with t.mutate(computation=\"Heavy Computation\").cache() as cached_penguins:\n...     cached_penguins\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n\n\n\ncast\nexpr.types.relations.Table.cast(self, schema)\nCast the columns of a table.\n!!! note “If you need to cast columns to a single type, use selectors.”\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nschema\nSupportsSchema\nMapping, schema or iterable of pairs to use for casting\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nCasted table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.schema()\nibis.Schema {\n  species            string\n  island             string\n  bill_length_mm     float64\n  bill_depth_mm      float64\n  flipper_length_mm  int64\n  body_mass_g        int64\n  sex                string\n  year               int64\n}\n&gt;&gt;&gt; cols = [\"body_mass_g\", \"bill_length_mm\"]\n&gt;&gt;&gt; t[cols].head()\n┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ body_mass_g ┃ bill_length_mm ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ int64       │ float64        │\n├─────────────┼────────────────┤\n│        3750 │           39.1 │\n│        3800 │           39.5 │\n│        3250 │           40.3 │\n│        NULL │            nan │\n│        3450 │           36.7 │\n└─────────────┴────────────────┘\nColumns not present in the input schema will be passed through unchanged\n&gt;&gt;&gt; t.columns\n['species', 'island', 'bill_length_mm', 'bill_depth_mm', 'flipper_length_mm', 'body_mass_g', 'sex', 'year']\n&gt;&gt;&gt; expr = t.cast({\"body_mass_g\": \"float64\", \"bill_length_mm\": \"int\"})\n&gt;&gt;&gt; expr.select(*cols).head()\n┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ body_mass_g ┃ bill_length_mm ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ float64     │ int64          │\n├─────────────┼────────────────┤\n│      3750.0 │             39 │\n│      3800.0 │             40 │\n│      3250.0 │             40 │\n│         nan │           NULL │\n│      3450.0 │             37 │\n└─────────────┴────────────────┘\nColumns that are in the input schema but not in the table raise an error\n&gt;&gt;&gt; t.cast({\"foo\": \"string\"})\nTraceback (most recent call last):\n    ...\nibis.common.exceptions.IbisError: Cast schema has fields that are not in the table: ['foo']\n\n\n\ncount\nexpr.types.relations.Table.count(self, where=None)\nCompute the number of rows in the table.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nOptional boolean expression to filter rows when counting.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerScalar\nNumber of rows in the table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [\"foo\", \"bar\", \"baz\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ a      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ foo    │\n│ bar    │\n│ baz    │\n└────────┘\n&gt;&gt;&gt; t.count()\n3\n&gt;&gt;&gt; t.count(t.a != \"foo\")\n2\n&gt;&gt;&gt; type(t.count())\n&lt;class 'ibis.expr.types.numeric.IntegerScalar'&gt;\n\n\n\ncross_join\nexpr.types.relations.Table.cross_join(left, right, *rest, lname='', rname='{name}_right')\nCompute the cross join of a sequence of tables.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nleft\nTable\nLeft table\nrequired\n\n\nright\nTable\nRight table\nrequired\n\n\nrest\nTable\nAdditional tables to cross join\n()\n\n\nlname\nstr\nA format string to use to rename overlapping columns in the left table (e.g. \"left_{name}\").\n''\n\n\nrname\nstr\nA format string to use to rename overlapping columns in the right table (e.g. \"right_{name}\").\n'{name}_right'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nCross join of left, right and rest\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.count()\n344\n&gt;&gt;&gt; agg = t.drop(\"year\").agg(s.across(s.numeric(), _.mean()))\n&gt;&gt;&gt; expr = t.cross_join(agg)\n&gt;&gt;&gt; expr\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n&gt;&gt;&gt; expr.columns\n['species',\n 'island',\n 'bill_length_mm',\n 'bill_depth_mm',\n 'flipper_length_mm',\n 'body_mass_g',\n 'sex',\n 'year',\n 'bill_length_mm_right',\n 'bill_depth_mm_right',\n 'flipper_length_mm_right',\n 'body_mass_g_right']\n&gt;&gt;&gt; expr.count()\n344\n\n\n\ndifference\nexpr.types.relations.Table.difference(self, table, *rest, distinct=True)\nCompute the set difference of multiple table expressions.\nThe input tables must have identical schemas.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable\nTable\nA table expression\nrequired\n\n\n*rest\nTable\nAdditional table expressions\n()\n\n\ndistinct\nbool\nOnly diff distinct rows not occurring in the calling table\nTrue\n\n\n\n\n\nSee Also\n[ibis.difference][ibis.difference]\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTable\nThe rows present in self that are not present in tables.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t1 = ibis.memtable({\"a\": [1, 2]})\n&gt;&gt;&gt; t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n&gt;&gt;&gt; t2 = ibis.memtable({\"a\": [2, 3]})\n&gt;&gt;&gt; t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n&gt;&gt;&gt; t1.difference(t2)\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n└───────┘\n\n\n\ndistinct\nexpr.types.relations.Table.distinct(self, *, on=None, keep='first')\nReturn a Table with duplicate rows removed.\nSimilar to pandas.DataFrame.drop_duplicates().\n!!! note “Some backends do not support keep='last'”\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\non\nstr | typing.Iterable[str] | ibis.Selector | None\nOnly consider certain columns for identifying duplicates. By default deduplicate all of the columns.\nNone\n\n\nkeep\ntyping.Literal[‘first’, ‘last’] | None\nDetermines which duplicates to keep. - \"first\": Drop duplicates except for the first occurrence. - \"last\": Drop duplicates except for the last occurrence. - None: Drop all duplicates\n'first'\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.examples as ex\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ex.penguins.fetch()\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\nCompute the distinct rows of a subset of columns\n&gt;&gt;&gt; t[[\"species\", \"island\"]].distinct()\n┏━━━━━━━━━━━┳━━━━━━━━━━━┓\n┃ species   ┃ island    ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━┩\n│ string    │ string    │\n├───────────┼───────────┤\n│ Adelie    │ Torgersen │\n│ Adelie    │ Biscoe    │\n│ Adelie    │ Dream     │\n│ Gentoo    │ Biscoe    │\n│ Chinstrap │ Dream     │\n└───────────┴───────────┘\nDrop all duplicate rows except the first\n&gt;&gt;&gt; t.distinct(on=[\"species\", \"island\"], keep=\"first\")\n┏━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━┓\n┃ species   ┃ island    ┃ bill_length_mm ┃ bill_depth_… ┃ flipper_length_mm ┃  ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━┩\n│ string    │ string    │ float64        │ float64      │ int64             │  │\n├───────────┼───────────┼────────────────┼──────────────┼───────────────────┼──┤\n│ Adelie    │ Torgersen │           39.1 │         18.7 │               181 │  │\n│ Adelie    │ Biscoe    │           37.8 │         18.3 │               174 │  │\n│ Adelie    │ Dream     │           39.5 │         16.7 │               178 │  │\n│ Gentoo    │ Biscoe    │           46.1 │         13.2 │               211 │  │\n│ Chinstrap │ Dream     │           46.5 │         17.9 │               192 │  │\n└───────────┴───────────┴────────────────┴──────────────┴───────────────────┴──┘\nDrop all duplicate rows except the last\n&gt;&gt;&gt; t.distinct(on=[\"species\", \"island\"], keep=\"last\")\n┏━━━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━┓\n┃ species   ┃ island    ┃ bill_length_mm ┃ bill_depth_… ┃ flipper_length_mm ┃  ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━┩\n│ string    │ string    │ float64        │ float64      │ int64             │  │\n├───────────┼───────────┼────────────────┼──────────────┼───────────────────┼──┤\n│ Adelie    │ Torgersen │           43.1 │         19.2 │               197 │  │\n│ Adelie    │ Biscoe    │           42.7 │         18.3 │               196 │  │\n│ Adelie    │ Dream     │           41.5 │         18.5 │               201 │  │\n│ Gentoo    │ Biscoe    │           49.9 │         16.1 │               213 │  │\n│ Chinstrap │ Dream     │           50.2 │         18.7 │               198 │  │\n└───────────┴───────────┴────────────────┴──────────────┴───────────────────┴──┘\nDrop all duplicated rows\n&gt;&gt;&gt; expr = t.distinct(on=[\"species\", \"island\", \"year\", \"bill_length_mm\"], keep=None)\n&gt;&gt;&gt; expr.count()\n273\n&gt;&gt;&gt; t.count()\n344\nYou can pass [selectors][ibis.selectors] to on\n&gt;&gt;&gt; t.distinct(on=~s.numeric())\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Biscoe    │           37.8 │          18.3 │               174 │ … │\n│ Adelie  │ Biscoe    │           37.7 │          18.7 │               180 │ … │\n│ Adelie  │ Dream     │           39.5 │          16.7 │               178 │ … │\n│ Adelie  │ Dream     │           37.2 │          18.1 │               178 │ … │\n│ Adelie  │ Dream     │           37.5 │          18.9 │               179 │ … │\n│ Gentoo  │ Biscoe    │           46.1 │          13.2 │               211 │ … │\n│ Gentoo  │ Biscoe    │           50.0 │          16.3 │               230 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\nThe only valid values of keep are \"first\", \"last\" and [`None][None]\n&gt;&gt;&gt; t.distinct(on=\"species\", keep=\"second\")\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisError: Invalid value for keep: 'second' ...\n\n\n\ndrop\nexpr.types.relations.Table.drop(self, *fields)\nRemove fields from a table.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfields\nstr | ibis.selectors.Selector\nFields to drop. Strings and selectors are accepted.\n()\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA table with all columns matching fields removed.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\nDrop one or more columns\n&gt;&gt;&gt; t.drop(\"species\").head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string    │ float64        │ float64       │ int64             │ … │\n├───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Torgersen │            nan │           nan │              NULL │ … │\n│ Torgersen │           36.7 │          19.3 │               193 │ … │\n└───────────┴────────────────┴───────────────┴───────────────────┴───┘\n&gt;&gt;&gt; t.drop(\"species\", \"bill_length_mm\").head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┳━━━┓\n┃ island    ┃ bill_depth_mm ┃ flipper_length_mm ┃ body_mass_g ┃ sex    ┃ … ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━╇━━━┩\n│ string    │ float64       │ int64             │ int64       │ string │ … │\n├───────────┼───────────────┼───────────────────┼─────────────┼────────┼───┤\n│ Torgersen │          18.7 │               181 │        3750 │ male   │ … │\n│ Torgersen │          17.4 │               186 │        3800 │ female │ … │\n│ Torgersen │          18.0 │               195 │        3250 │ female │ … │\n│ Torgersen │           nan │              NULL │        NULL │ NULL   │ … │\n│ Torgersen │          19.3 │               193 │        3450 │ female │ … │\n└───────────┴───────────────┴───────────────────┴─────────────┴────────┴───┘\nDrop with selectors, mix and match\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t.drop(\"species\", s.startswith(\"bill_\")).head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ island    ┃ flipper_length_mm ┃ body_mass_g ┃ sex    ┃ year  ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ string    │ int64             │ int64       │ string │ int64 │\n├───────────┼───────────────────┼─────────────┼────────┼───────┤\n│ Torgersen │               181 │        3750 │ male   │  2007 │\n│ Torgersen │               186 │        3800 │ female │  2007 │\n│ Torgersen │               195 │        3250 │ female │  2007 │\n│ Torgersen │              NULL │        NULL │ NULL   │  2007 │\n│ Torgersen │               193 │        3450 │ female │  2007 │\n└───────────┴───────────────────┴─────────────┴────────┴───────┘\n\n\n\ndropna\nexpr.types.relations.Table.dropna(self, subset=None, how='any')\nRemove rows with null values from the table.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubset\ntyping.Sequence[str] | str | None\nColumns names to consider when dropping nulls. By default all columns are considered.\nNone\n\n\nhow\ntyping.Literal[‘any’, ‘all’]\nDetermine whether a row is removed if there is at least one null value in the row ('any'), or if all row values are null ('all').\n'any'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n&gt;&gt;&gt; t.count()\n344\n&gt;&gt;&gt; t.dropna([\"bill_length_mm\", \"body_mass_g\"]).count()\n342\n&gt;&gt;&gt; t.dropna(how=\"all\").count()  # no rows where all columns are null\n344\n\n\n\nfillna\nexpr.types.relations.Table.fillna(self, replacements)\nFill null values in a table expression.\n!!! note “There is potential lack of type stability with the fillna API”\nFor example, different library versions may impact whether a given\nbackend promotes integer replacement values to floats.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nreplacements\nibis.Scalar | typing.Mapping[str, ibis.Scalar]\nValue with which to fill nulls. If replacements is a mapping, the keys are column names that map to their replacement value. If passed as a scalar all columns are filled with that value.\nrequired\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.sex\n┏━━━━━━━━┓\n┃ sex    ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ male   │\n│ female │\n│ female │\n│ NULL   │\n│ female │\n│ male   │\n│ female │\n│ male   │\n│ NULL   │\n│ NULL   │\n│ …      │\n└────────┘\n&gt;&gt;&gt; t.fillna({\"sex\": \"unrecorded\"}).sex\n┏━━━━━━━━━━━━┓\n┃ sex        ┃\n┡━━━━━━━━━━━━┩\n│ string     │\n├────────────┤\n│ male       │\n│ female     │\n│ female     │\n│ unrecorded │\n│ female     │\n│ male       │\n│ female     │\n│ male       │\n│ unrecorded │\n│ unrecorded │\n│ …          │\n└────────────┘\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\n\nfilter\nexpr.types.relations.Table.filter(self, predicates)\nSelect rows from table based on predicates.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npredicates\nibis.BooleanValue | typing.Sequence[ibis.BooleanValue] | ibis.selectors.IfAnyAll\nBoolean value expressions used to select rows in table.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nFiltered table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\n&gt;&gt;&gt; t.filter([t.species == \"Adelie\", t.body_mass_g &gt; 3500]).sex.value_counts().dropna(\"sex\")\n┏━━━━━━━━┳━━━━━━━━━━━┓\n┃ sex    ┃ sex_count ┃\n┡━━━━━━━━╇━━━━━━━━━━━┩\n│ string │ int64     │\n├────────┼───────────┤\n│ male   │        68 │\n│ female │        22 │\n└────────┴───────────┘\n\n\n\ngroup_by\nexpr.types.relations.Table.group_by(self, by=None, **key_exprs)\nCreate a grouped table expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nby\nstr | ibis.Value | typing.Iterable[str] | typing.Iterable[ibis.Value] | None\nGrouping expressions\nNone\n\n\nkey_exprs\nstr | ibis.Value | typing.Iterable[str] | typing.Iterable[ibis.Value]\nNamed grouping expressions\n{}\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGroupedTable\nA grouped table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"fruit\": [\"apple\", \"apple\", \"banana\", \"orange\"], \"price\": [0.5, 0.5, 0.25, 0.33]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┳━━━━━━━━━┓\n┃ fruit  ┃ price   ┃\n┡━━━━━━━━╇━━━━━━━━━┩\n│ string │ float64 │\n├────────┼─────────┤\n│ apple  │    0.50 │\n│ apple  │    0.50 │\n│ banana │    0.25 │\n│ orange │    0.33 │\n└────────┴─────────┘\n&gt;&gt;&gt; t.group_by(\"fruit\").agg(total_cost=_.price.sum(), avg_cost=_.price.mean())\n┏━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━┓\n┃ fruit  ┃ total_cost ┃ avg_cost ┃\n┡━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━┩\n│ string │ float64    │ float64  │\n├────────┼────────────┼──────────┤\n│ apple  │       1.00 │     0.50 │\n│ banana │       0.25 │     0.25 │\n│ orange │       0.33 │     0.33 │\n└────────┴────────────┴──────────┘\n\n\n\nhead\nexpr.types.relations.Table.head(self, n=5)\nSelect the first n rows of a table.\n!!! note “The result set is not deterministic without a call to [order_by][ibis.expr.types.relations.Table.order_by].”\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of rows to include\n5\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nself limited to n rows\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [1, 1, 2], \"b\": [\"c\", \"a\", \"a\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ c      │\n│     1 │ a      │\n│     2 │ a      │\n└───────┴────────┘\n&gt;&gt;&gt; t.head(2)\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ c      │\n│     1 │ a      │\n└───────┴────────┘\n\n\nSee Also\n[Table.limit][ibis.expr.types.relations.Table.limit] [Table.order_by][ibis.expr.types.relations.Table.order_by]\n\n\n\ninfo\nexpr.types.relations.Table.info(self)\nReturn summary information about a table.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nSummary of self\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.info()\n┏━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┳━━━┓\n┃ name              ┃ type    ┃ nullable ┃ nulls ┃ non_nulls ┃ null_frac ┃ … ┃\n┡━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━╇━━━┩\n│ string            │ string  │ boolean  │ int64 │ int64     │ float64   │ … │\n├───────────────────┼─────────┼──────────┼───────┼───────────┼───────────┼───┤\n│ species           │ string  │ True     │     0 │       344 │  0.000000 │ … │\n│ island            │ string  │ True     │     0 │       344 │  0.000000 │ … │\n│ bill_length_mm    │ float64 │ True     │     2 │       342 │  0.005814 │ … │\n│ bill_depth_mm     │ float64 │ True     │     2 │       342 │  0.005814 │ … │\n│ flipper_length_mm │ int64   │ True     │     2 │       342 │  0.005814 │ … │\n│ body_mass_g       │ int64   │ True     │     2 │       342 │  0.005814 │ … │\n│ sex               │ string  │ True     │    11 │       333 │  0.031977 │ … │\n│ year              │ int64   │ True     │     0 │       344 │  0.000000 │ … │\n└───────────────────┴─────────┴──────────┴───────┴───────────┴───────────┴───┘\n\n\n\nintersect\nexpr.types.relations.Table.intersect(self, table, *rest, distinct=True)\nCompute the set intersection of multiple table expressions.\nThe input tables must have identical schemas.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable\nTable\nA table expression\nrequired\n\n\n*rest\nTable\nAdditional table expressions\n()\n\n\ndistinct\nbool\nOnly return distinct rows\nTrue\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTable\nA new table containing the intersection of all input tables.\n\n\n\n\n\nSee Also\n[ibis.intersect][ibis.intersect]\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t1 = ibis.memtable({\"a\": [1, 2]})\n&gt;&gt;&gt; t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n&gt;&gt;&gt; t2 = ibis.memtable({\"a\": [2, 3]})\n&gt;&gt;&gt; t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n&gt;&gt;&gt; t1.intersect(t2)\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n└───────┘\n\n\n\njoin\nexpr.types.relations.Table.join(left, right, predicates=(), how='inner', *, lname='', rname='{name}_right')\nPerform a join between two tables.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nleft\nTable\nLeft table to join\nrequired\n\n\nright\nTable\nRight table to join\nrequired\n\n\npredicates\nstr | typing.Sequence[str | tuple[str | ibis.Column, str | ibis.Column] | ibis.BooleanColumn]\nBoolean or column names to join on\n()\n\n\nhow\ntyping.Literal[‘inner’, ‘left’, ‘outer’, ‘right’, ‘semi’, ‘anti’, ‘any_inner’, ‘any_left’, ‘left_semi’]\nJoin method\n'inner'\n\n\nlname\nstr\nA format string to use to rename overlapping columns in the left table (e.g. \"left_{name}\").\n''\n\n\nrname\nstr\nA format string to use to rename overlapping columns in the right table (e.g. \"right_{name}\").\n'{name}_right'\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; import ibis.examples as ex\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; movies = ex.ml_latest_small_movies.fetch()\n&gt;&gt;&gt; movies\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ movieId ┃ title                            ┃ genres                          ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ int64   │ string                           │ string                          │\n├─────────┼──────────────────────────────────┼─────────────────────────────────┤\n│       1 │ Toy Story (1995)                 │ Adventure|Animation|Children|C… │\n│       2 │ Jumanji (1995)                   │ Adventure|Children|Fantasy      │\n│       3 │ Grumpier Old Men (1995)          │ Comedy|Romance                  │\n│       4 │ Waiting to Exhale (1995)         │ Comedy|Drama|Romance            │\n│       5 │ Father of the Bride Part II (19… │ Comedy                          │\n│       6 │ Heat (1995)                      │ Action|Crime|Thriller           │\n│       7 │ Sabrina (1995)                   │ Comedy|Romance                  │\n│       8 │ Tom and Huck (1995)              │ Adventure|Children              │\n│       9 │ Sudden Death (1995)              │ Action                          │\n│      10 │ GoldenEye (1995)                 │ Action|Adventure|Thriller       │\n│       … │ …                                │ …                               │\n└─────────┴──────────────────────────────────┴─────────────────────────────────┘\n&gt;&gt;&gt; links = ex.ml_latest_small_links.fetch()\n&gt;&gt;&gt; links\n┏━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┓\n┃ movieId ┃ imdbId  ┃ tmdbId ┃\n┡━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━┩\n│ int64   │ string  │ int64  │\n├─────────┼─────────┼────────┤\n│       1 │ 0114709 │    862 │\n│       2 │ 0113497 │   8844 │\n│       3 │ 0113228 │  15602 │\n│       4 │ 0114885 │  31357 │\n│       5 │ 0113041 │  11862 │\n│       6 │ 0113277 │    949 │\n│       7 │ 0114319 │  11860 │\n│       8 │ 0112302 │  45325 │\n│       9 │ 0114576 │   9091 │\n│      10 │ 0113189 │    710 │\n│       … │ …       │      … │\n└─────────┴─────────┴────────┘\nImplicit inner equality join on the shared movieId column\n&gt;&gt;&gt; linked = movies.join(links, \"movieId\", how=\"inner\")\n&gt;&gt;&gt; linked.head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┓\n┃ movieId ┃ title                  ┃ genres                 ┃ imdbId  ┃ tmdbId ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━┩\n│ int64   │ string                 │ string                 │ string  │ int64  │\n├─────────┼────────────────────────┼────────────────────────┼─────────┼────────┤\n│       1 │ Toy Story (1995)       │ Adventure|Animation|C… │ 0114709 │    862 │\n│       2 │ Jumanji (1995)         │ Adventure|Children|Fa… │ 0113497 │   8844 │\n│       3 │ Grumpier Old Men (199… │ Comedy|Romance         │ 0113228 │  15602 │\n│       4 │ Waiting to Exhale (19… │ Comedy|Drama|Romance   │ 0114885 │  31357 │\n│       5 │ Father of the Bride P… │ Comedy                 │ 0113041 │  11862 │\n└─────────┴────────────────────────┴────────────────────────┴─────────┴────────┘\nExplicit equality join using the default how value of \"inner\"\n&gt;&gt;&gt; linked = movies.join(links, movies.movieId == links.movieId)\n&gt;&gt;&gt; linked.head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┓\n┃ movieId ┃ title                  ┃ genres                 ┃ imdbId  ┃ tmdbId ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━┩\n│ int64   │ string                 │ string                 │ string  │ int64  │\n├─────────┼────────────────────────┼────────────────────────┼─────────┼────────┤\n│       1 │ Toy Story (1995)       │ Adventure|Animation|C… │ 0114709 │    862 │\n│       2 │ Jumanji (1995)         │ Adventure|Children|Fa… │ 0113497 │   8844 │\n│       3 │ Grumpier Old Men (199… │ Comedy|Romance         │ 0113228 │  15602 │\n│       4 │ Waiting to Exhale (19… │ Comedy|Drama|Romance   │ 0114885 │  31357 │\n│       5 │ Father of the Bride P… │ Comedy                 │ 0113041 │  11862 │\n└─────────┴────────────────────────┴────────────────────────┴─────────┴────────┘\n\n\n\nlimit\nexpr.types.relations.Table.limit(self, n, offset=0)\nSelect n rows from self starting at offset.\n!!! note “The result set is not deterministic without a call to [order_by][ibis.expr.types.relations.Table.order_by].”\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint\nNumber of rows to include\nrequired\n\n\noffset\nint\nNumber of rows to skip first\n0\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nThe first n rows of self starting at offset\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [1, 1, 2], \"b\": [\"c\", \"a\", \"a\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ c      │\n│     1 │ a      │\n│     2 │ a      │\n└───────┴────────┘\n&gt;&gt;&gt; t.limit(2)\n┏━━━━━━━┳━━━━━━━━┓\n┃ a     ┃ b      ┃\n┡━━━━━━━╇━━━━━━━━┩\n│ int64 │ string │\n├───────┼────────┤\n│     1 │ c      │\n│     1 │ a      │\n└───────┴────────┘\n\n\nSee Also\n[Table.order_by][ibis.expr.types.relations.Table.order_by]\n\n\n\nmutate\nexpr.types.relations.Table.mutate(self, exprs=None, **mutations)\nAdd columns to a table expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexprs\ntyping.Sequence[ibis.Expr] | None\nList of named expressions to add as columns\nNone\n\n\nmutations\nibis.Value\nNamed expressions using keyword arguments\n{}\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression with additional columns\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch().select(\"species\", \"year\", \"bill_length_mm\")\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ species ┃ year  ┃ bill_length_mm ┃\n┡━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ string  │ int64 │ float64        │\n├─────────┼───────┼────────────────┤\n│ Adelie  │  2007 │           39.1 │\n│ Adelie  │  2007 │           39.5 │\n│ Adelie  │  2007 │           40.3 │\n│ Adelie  │  2007 │            nan │\n│ Adelie  │  2007 │           36.7 │\n│ Adelie  │  2007 │           39.3 │\n│ Adelie  │  2007 │           38.9 │\n│ Adelie  │  2007 │           39.2 │\n│ Adelie  │  2007 │           34.1 │\n│ Adelie  │  2007 │           42.0 │\n│ …       │     … │              … │\n└─────────┴───────┴────────────────┘\nAdd a new column from a per-element expression\n&gt;&gt;&gt; t.mutate(next_year=_.year + 1).head()\n┏━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━┓\n┃ species ┃ year  ┃ bill_length_mm ┃ next_year ┃\n┡━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━┩\n│ string  │ int64 │ float64        │ int64     │\n├─────────┼───────┼────────────────┼───────────┤\n│ Adelie  │  2007 │           39.1 │      2008 │\n│ Adelie  │  2007 │           39.5 │      2008 │\n│ Adelie  │  2007 │           40.3 │      2008 │\n│ Adelie  │  2007 │            nan │      2008 │\n│ Adelie  │  2007 │           36.7 │      2008 │\n└─────────┴───────┴────────────────┴───────────┘\nAdd a new column based on an aggregation. Note the automatic broadcasting.\n&gt;&gt;&gt; t.select(\"species\", bill_demean=_.bill_length_mm - _.bill_length_mm.mean()).head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ species ┃ bill_demean ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ string  │ float64     │\n├─────────┼─────────────┤\n│ Adelie  │    -4.82193 │\n│ Adelie  │    -4.42193 │\n│ Adelie  │    -3.62193 │\n│ Adelie  │         nan │\n│ Adelie  │    -7.22193 │\n└─────────┴─────────────┘\nMutate across multiple columns\n&gt;&gt;&gt; t.mutate(s.across(s.numeric() & ~s.c(\"year\"), _ - _.mean())).head()\n┏━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ species ┃ year  ┃ bill_length_mm ┃\n┡━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ string  │ int64 │ float64        │\n├─────────┼───────┼────────────────┤\n│ Adelie  │  2007 │       -4.82193 │\n│ Adelie  │  2007 │       -4.42193 │\n│ Adelie  │  2007 │       -3.62193 │\n│ Adelie  │  2007 │            nan │\n│ Adelie  │  2007 │       -7.22193 │\n└─────────┴───────┴────────────────┘\n\n\n\norder_by\nexpr.types.relations.Table.order_by(self, by)\nSort a table by one or more expressions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nby\nstr | ibis.Column | tuple[str | ibis.Column, bool] | typing.Sequence[str] | typing.Sequence[ibis.Column] | typing.Sequence[tuple[str | ibis.Column, bool]] | None\nExpressions to sort the table by.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nSorted table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [1, 2, 3], \"b\": [\"c\", \"b\", \"a\"], \"c\": [4, 6, 5]})\n&gt;&gt;&gt; t\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     1 │ c      │     4 │\n│     2 │ b      │     6 │\n│     3 │ a      │     5 │\n└───────┴────────┴───────┘\n&gt;&gt;&gt; t.order_by(\"b\")\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     3 │ a      │     5 │\n│     2 │ b      │     6 │\n│     1 │ c      │     4 │\n└───────┴────────┴───────┘\n&gt;&gt;&gt; t.order_by(ibis.desc(\"c\"))\n┏━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ a     ┃ b      ┃ c     ┃\n┡━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ int64 │ string │ int64 │\n├───────┼────────┼───────┤\n│     2 │ b      │     6 │\n│     3 │ a      │     5 │\n│     1 │ c      │     4 │\n└───────┴────────┴───────┘\n\n\n\npivot_longer\nexpr.types.relations.Table.pivot_longer(self, col, *, names_to='name', names_pattern='(.+)', names_transform=None, values_to='value', values_transform=None)\nTransform a table from wider to longer.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncol\nstr | ibis.Selector\nString column name or selector.\nrequired\n\n\nnames_to\nstr | typing.Iterable[str]\nA string or iterable of strings indicating how to name the new pivoted columns.\n'name'\n\n\nnames_pattern\nstr | re.Pattern\nPattern to use to extract column names from the input. By default the entire column name is extracted.\n'(.+)'\n\n\nnames_transform\ntyping.Callable[[str], ibis.Value] | typing.Mapping[str, typing.Callable[[str], ibis.Value]] | None\nFunction or mapping of a name in names_to to a function to transform a column name to a value.\nNone\n\n\nvalues_to\nstr\nName of the pivoted value column.\n'value'\n\n\nvalues_transform\ntyping.Callable[[ibis.Value], ibis.Value] | ibis.expr.deferred.Deferred | None\nApply a function to the value column. This can be a lambda or deferred expression.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nPivoted table\n\n\n\n\n\nExamples\nBasic usage\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; relig_income = ibis.examples.relig_income_raw.fetch()\n&gt;&gt;&gt; relig_income\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┳━━━┓\n┃ religion                ┃ &lt;$10k ┃ $10-20k ┃ $20-30k ┃ $30-40k ┃ $40-50k ┃ … ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━╇━━━┩\n│ string                  │ int64 │ int64   │ int64   │ int64   │ int64   │ … │\n├─────────────────────────┼───────┼─────────┼─────────┼─────────┼─────────┼───┤\n│ Agnostic                │    27 │      34 │      60 │      81 │      76 │ … │\n│ Atheist                 │    12 │      27 │      37 │      52 │      35 │ … │\n│ Buddhist                │    27 │      21 │      30 │      34 │      33 │ … │\n│ Catholic                │   418 │     617 │     732 │     670 │     638 │ … │\n│ Don’t know/refused      │    15 │      14 │      15 │      11 │      10 │ … │\n│ Evangelical Prot        │   575 │     869 │    1064 │     982 │     881 │ … │\n│ Hindu                   │     1 │       9 │       7 │       9 │      11 │ … │\n│ Historically Black Prot │   228 │     244 │     236 │     238 │     197 │ … │\n│ Jehovah's Witness       │    20 │      27 │      24 │      24 │      21 │ … │\n│ Jewish                  │    19 │      19 │      25 │      25 │      30 │ … │\n│ …                       │     … │       … │       … │       … │       … │ … │\n└─────────────────────────┴───────┴─────────┴─────────┴─────────┴─────────┴───┘\nHere we convert column names not matching the selector for the religion column and convert those names into values\n&gt;&gt;&gt; relig_income.pivot_longer(~s.c(\"religion\"), names_to=\"income\", values_to=\"count\")\n┏━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━┳━━━━━━━┓\n┃ religion ┃ income             ┃ count ┃\n┡━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━╇━━━━━━━┩\n│ string   │ string             │ int64 │\n├──────────┼────────────────────┼───────┤\n│ Agnostic │ &lt;$10k              │    27 │\n│ Agnostic │ $10-20k            │    34 │\n│ Agnostic │ $20-30k            │    60 │\n│ Agnostic │ $30-40k            │    81 │\n│ Agnostic │ $40-50k            │    76 │\n│ Agnostic │ $50-75k            │   137 │\n│ Agnostic │ $75-100k           │   122 │\n│ Agnostic │ $100-150k          │   109 │\n│ Agnostic │ &gt;150k              │    84 │\n│ Agnostic │ Don't know/refused │    96 │\n│ …        │ …                  │     … │\n└──────────┴────────────────────┴───────┘\nSimilarly for a different example dataset, we convert names to values but using a different selector and the default values_to value.\n&gt;&gt;&gt; world_bank_pop = ibis.examples.world_bank_pop_raw.fetch()\n&gt;&gt;&gt; world_bank_pop.head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━┓\n┃ country ┃ indicator   ┃ 2000         ┃ 2001         ┃ 2002         ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string      │ float64      │ float64      │ float64      │ … │\n├─────────┼─────────────┼──────────────┼──────────────┼──────────────┼───┤\n│ ABW     │ SP.URB.TOTL │ 4.244400e+04 │ 4.304800e+04 │ 4.367000e+04 │ … │\n│ ABW     │ SP.URB.GROW │ 1.182632e+00 │ 1.413021e+00 │ 1.434560e+00 │ … │\n│ ABW     │ SP.POP.TOTL │ 9.085300e+04 │ 9.289800e+04 │ 9.499200e+04 │ … │\n│ ABW     │ SP.POP.GROW │ 2.055027e+00 │ 2.225930e+00 │ 2.229056e+00 │ … │\n│ AFG     │ SP.URB.TOTL │ 4.436299e+06 │ 4.648055e+06 │ 4.892951e+06 │ … │\n└─────────┴─────────────┴──────────────┴──────────────┴──────────────┴───┘\n&gt;&gt;&gt; world_bank_pop.pivot_longer(s.matches(r\"\\d{4}\"), names_to=\"year\").head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━━┓\n┃ country ┃ indicator   ┃ year   ┃ value   ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━━┩\n│ string  │ string      │ string │ float64 │\n├─────────┼─────────────┼────────┼─────────┤\n│ ABW     │ SP.URB.TOTL │ 2000   │ 42444.0 │\n│ ABW     │ SP.URB.TOTL │ 2001   │ 43048.0 │\n│ ABW     │ SP.URB.TOTL │ 2002   │ 43670.0 │\n│ ABW     │ SP.URB.TOTL │ 2003   │ 44246.0 │\n│ ABW     │ SP.URB.TOTL │ 2004   │ 44669.0 │\n└─────────┴─────────────┴────────┴─────────┘\npivot_longer has some preprocessing capabiltiies like stripping a prefix and applying a function to column names\n&gt;&gt;&gt; billboard = ibis.examples.billboard.fetch()\n&gt;&gt;&gt; billboard\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━━┳━━━━━━━┳━━━┓\n┃ artist         ┃ track                   ┃ date_entered ┃ wk1   ┃ wk2   ┃ … ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━╇━━━━━━━╇━━━┩\n│ string         │ string                  │ date         │ int64 │ int64 │ … │\n├────────────────┼─────────────────────────┼──────────────┼───────┼───────┼───┤\n│ 2 Pac          │ Baby Don't Cry (Keep... │ 2000-02-26   │    87 │    82 │ … │\n│ 2Ge+her        │ The Hardest Part Of ... │ 2000-09-02   │    91 │    87 │ … │\n│ 3 Doors Down   │ Kryptonite              │ 2000-04-08   │    81 │    70 │ … │\n│ 3 Doors Down   │ Loser                   │ 2000-10-21   │    76 │    76 │ … │\n│ 504 Boyz       │ Wobble Wobble           │ 2000-04-15   │    57 │    34 │ … │\n│ 98^0           │ Give Me Just One Nig... │ 2000-08-19   │    51 │    39 │ … │\n│ A*Teens        │ Dancing Queen           │ 2000-07-08   │    97 │    97 │ … │\n│ Aaliyah        │ I Don't Wanna           │ 2000-01-29   │    84 │    62 │ … │\n│ Aaliyah        │ Try Again               │ 2000-03-18   │    59 │    53 │ … │\n│ Adams, Yolanda │ Open My Heart           │ 2000-08-26   │    76 │    76 │ … │\n│ …              │ …                       │ …            │     … │     … │ … │\n└────────────────┴─────────────────────────┴──────────────┴───────┴───────┴───┘\n&gt;&gt;&gt; billboard.pivot_longer(\n...     s.startswith(\"wk\"),\n...     names_to=\"week\",\n...     names_pattern=r\"wk(.+)\",\n...     names_transform=int,\n...     values_to=\"rank\",\n...     values_transform=_.cast(\"int\"),\n... ).dropna(\"rank\")\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━━━━┳━━━━━━━┓\n┃ artist  ┃ track                   ┃ date_entered ┃ week ┃ rank  ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━╇━━━━━━━┩\n│ string  │ string                  │ date         │ int8 │ int64 │\n├─────────┼─────────────────────────┼──────────────┼──────┼───────┤\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    1 │    87 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    2 │    82 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    3 │    72 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    4 │    77 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    5 │    87 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    6 │    94 │\n│ 2 Pac   │ Baby Don't Cry (Keep... │ 2000-02-26   │    7 │    99 │\n│ 2Ge+her │ The Hardest Part Of ... │ 2000-09-02   │    1 │    91 │\n│ 2Ge+her │ The Hardest Part Of ... │ 2000-09-02   │    2 │    87 │\n│ 2Ge+her │ The Hardest Part Of ... │ 2000-09-02   │    3 │    92 │\n│ …       │ …                       │ …            │    … │     … │\n└─────────┴─────────────────────────┴──────────────┴──────┴───────┘\nYou can use regular expression capture groups to extract multiple variables stored in column names\n&gt;&gt;&gt; who = ibis.examples.who.fetch()\n&gt;&gt;&gt; who\n┏━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━┳━━━┓\n┃ country     ┃ iso2   ┃ iso3   ┃ year  ┃ new_sp_m014 ┃ new_sp_m1524 ┃ … ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━┩\n│ string      │ string │ string │ int64 │ int64       │ int64        │ … │\n├─────────────┼────────┼────────┼───────┼─────────────┼──────────────┼───┤\n│ Afghanistan │ AF     │ AFG    │  1980 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1981 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1982 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1983 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1984 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1985 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1986 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1987 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1988 │        NULL │         NULL │ … │\n│ Afghanistan │ AF     │ AFG    │  1989 │        NULL │         NULL │ … │\n│ …           │ …      │ …      │     … │           … │            … │ … │\n└─────────────┴────────┴────────┴───────┴─────────────┴──────────────┴───┘\n&gt;&gt;&gt; len(who.columns)\n60\n&gt;&gt;&gt; who.pivot_longer(\n...     s.r[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_(.)(.*)\",\n...     values_to=\"count\",\n... )\n┏━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━┳━━━━━━━┓\n┃ country     ┃ iso2   ┃ iso3   ┃ year  ┃ diagnosis ┃ gender ┃ age    ┃ count ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━╇━━━━━━━┩\n│ string      │ string │ string │ int64 │ string    │ string │ string │ int64 │\n├─────────────┼────────┼────────┼───────┼───────────┼────────┼────────┼───────┤\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 014    │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 1524   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 2534   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 3544   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 4554   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 5564   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ m      │ 65     │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ f      │ 014    │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ f      │ 1524   │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │ f      │ 2534   │  NULL │\n│ …           │ …      │ …      │     … │ …         │ …      │ …      │     … │\n└─────────────┴────────┴────────┴───────┴───────────┴────────┴────────┴───────┘\nnames_transform is flexible, and can be:\n1. A mapping of one or more names in `names_to` to callable\n2. A callable that will be applied to every name\nLet’s recode gender and age to numeric values using a mapping\n&gt;&gt;&gt; who.pivot_longer(\n...     s.r[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_(.)(.*)\",\n...     names_transform=dict(\n...         gender={\"m\": 1, \"f\": 2}.get,\n...         age=dict(zip([\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\"], range(7))).get,\n...     ),\n...     values_to=\"count\",\n... )\n┏━━━━━━━━━━━━━┳━━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━┳━━━━━━┳━━━━━━━┓\n┃ country     ┃ iso2   ┃ iso3   ┃ year  ┃ diagnosis ┃ gender ┃ age  ┃ count ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━╇━━━━━━╇━━━━━━━┩\n│ string      │ string │ string │ int64 │ string    │ int8   │ int8 │ int64 │\n├─────────────┼────────┼────────┼───────┼───────────┼────────┼──────┼───────┤\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    0 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    1 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    2 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    3 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    4 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    5 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      1 │    6 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      2 │    0 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      2 │    1 │  NULL │\n│ Afghanistan │ AF     │ AFG    │  1980 │ sp        │      2 │    2 │  NULL │\n│ …           │ …      │ …      │     … │ …         │      … │    … │     … │\n└─────────────┴────────┴────────┴───────┴───────────┴────────┴──────┴───────┘\nThe number of match groups in names_pattern must match the length of names_to\n&gt;&gt;&gt; who.pivot_longer(\n...     s.r[\"new_sp_m014\":\"newrel_f65\"],\n...     names_to=[\"diagnosis\", \"gender\", \"age\"],\n...     names_pattern=\"new_?(.*)_.(.*)\",\n... )\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisInputError: Number of match groups in `names_pattern` ...\nnames_transform must be a mapping or callable\n&gt;&gt;&gt; who.pivot_longer(s.r[\"new_sp_m014\":\"newrel_f65\"], names_transform=\"upper\")\nTraceback (most recent call last):\n  ...\nibis.common.exceptions.IbisTypeError: ... Got &lt;class 'str'&gt;\n\n\n\npivot_wider\nexpr.types.relations.Table.pivot_wider(self, *, id_cols=None, names_from='name', names_prefix='', names_sep='_', names_sort=False, names=None, values_from='value', values_fill=None, values_agg='arbitrary')\nPivot a table to a wider format.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nid_cols\nibis.Selector | None\nA set of columns that uniquely identify each observation.\nNone\n\n\nnames_from\nstr | typing.Iterable[str] | ibis.Selector\nAn argument describing which column or columns to use to get the name of the output columns.\n'name'\n\n\nnames_prefix\nstr\nString added to the start of every column name.\n''\n\n\nnames_sep\nstr\nIf names_from or values_from contains multiple columns, this argument will be used to join their values together into a single string to use as a column name.\n'_'\n\n\nnames_sort\nbool\nIf [True][True] columns are sorted. If [False][False] column names are ordered by appearance.\nFalse\n\n\nnames\ntyping.Iterable[str] | None\nAn explicit sequence of values to look for in columns matching names_from. * When this value is None, the values will be computed from names_from. * When this value is not None, each element’s length must match the length of names_from. See examples below for more detail.\nNone\n\n\nvalues_from\nstr | typing.Iterable[str] | ibis.Selector\nAn argument describing which column or columns to get the cell values from.\n'value'\n\n\nvalues_fill\nint | float | str | ibis.Scalar | None\nA scalar value that specifies what each value should be filled with when missing.\nNone\n\n\nvalues_agg\nstr | typing.Callable[[ibis.Value], ibis.Scalar] | ibis.expr.deferred.Deferred\nA function applied to the value in each cell in the output.\n'arbitrary'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nWider pivoted table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; ibis.options.interactive = True\nBasic usage\n&gt;&gt;&gt; fish_encounters = ibis.examples.fish_encounters.fetch()\n&gt;&gt;&gt; fish_encounters\n┏━━━━━━━┳━━━━━━━━━┳━━━━━━━┓\n┃ fish  ┃ station ┃ seen  ┃\n┡━━━━━━━╇━━━━━━━━━╇━━━━━━━┩\n│ int64 │ string  │ int64 │\n├───────┼─────────┼───────┤\n│  4842 │ Release │     1 │\n│  4842 │ I80_1   │     1 │\n│  4842 │ Lisbon  │     1 │\n│  4842 │ Rstr    │     1 │\n│  4842 │ Base_TD │     1 │\n│  4842 │ BCE     │     1 │\n│  4842 │ BCW     │     1 │\n│  4842 │ BCE2    │     1 │\n│  4842 │ BCW2    │     1 │\n│  4842 │ MAE     │     1 │\n│     … │ …       │     … │\n└───────┴─────────┴───────┘\n&gt;&gt;&gt; fish_encounters.pivot_wider(names_from=\"station\", values_from=\"seen\")\n┏━━━━━━━┳━━━━━━━━━┳━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━┳━━━━━━━┳━━━━━━━┳━━━┓\n┃ fish  ┃ Release ┃ I80_1 ┃ Lisbon ┃ Rstr  ┃ Base_TD ┃ BCE   ┃ BCW   ┃ … ┃\n┡━━━━━━━╇━━━━━━━━━╇━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━╇━━━━━━━╇━━━━━━━╇━━━┩\n│ int64 │ int64   │ int64 │ int64  │ int64 │ int64   │ int64 │ int64 │ … │\n├───────┼─────────┼───────┼────────┼───────┼─────────┼───────┼───────┼───┤\n│  4842 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4843 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4844 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4845 │       1 │     1 │      1 │     1 │       1 │  NULL │  NULL │ … │\n│  4847 │       1 │     1 │      1 │  NULL │    NULL │  NULL │  NULL │ … │\n│  4848 │       1 │     1 │      1 │     1 │    NULL │  NULL │  NULL │ … │\n│  4849 │       1 │     1 │   NULL │  NULL │    NULL │  NULL │  NULL │ … │\n│  4850 │       1 │     1 │   NULL │     1 │       1 │     1 │     1 │ … │\n│  4851 │       1 │     1 │   NULL │  NULL │    NULL │  NULL │  NULL │ … │\n│  4854 │       1 │     1 │   NULL │  NULL │    NULL │  NULL │  NULL │ … │\n│     … │       … │     … │      … │     … │       … │     … │     … │ … │\n└───────┴─────────┴───────┴────────┴───────┴─────────┴───────┴───────┴───┘\nFill missing pivoted values using values_fill\n&gt;&gt;&gt; fish_encounters.pivot_wider(names_from=\"station\", values_from=\"seen\", values_fill=0)\n┏━━━━━━━┳━━━━━━━━━┳━━━━━━━┳━━━━━━━━┳━━━━━━━┳━━━━━━━━━┳━━━━━━━┳━━━━━━━┳━━━┓\n┃ fish  ┃ Release ┃ I80_1 ┃ Lisbon ┃ Rstr  ┃ Base_TD ┃ BCE   ┃ BCW   ┃ … ┃\n┡━━━━━━━╇━━━━━━━━━╇━━━━━━━╇━━━━━━━━╇━━━━━━━╇━━━━━━━━━╇━━━━━━━╇━━━━━━━╇━━━┩\n│ int64 │ int64   │ int64 │ int64  │ int64 │ int64   │ int64 │ int64 │ … │\n├───────┼─────────┼───────┼────────┼───────┼─────────┼───────┼───────┼───┤\n│  4842 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4843 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4844 │       1 │     1 │      1 │     1 │       1 │     1 │     1 │ … │\n│  4845 │       1 │     1 │      1 │     1 │       1 │     0 │     0 │ … │\n│  4847 │       1 │     1 │      1 │     0 │       0 │     0 │     0 │ … │\n│  4848 │       1 │     1 │      1 │     1 │       0 │     0 │     0 │ … │\n│  4849 │       1 │     1 │      0 │     0 │       0 │     0 │     0 │ … │\n│  4850 │       1 │     1 │      0 │     1 │       1 │     1 │     1 │ … │\n│  4851 │       1 │     1 │      0 │     0 │       0 │     0 │     0 │ … │\n│  4854 │       1 │     1 │      0 │     0 │       0 │     0 │     0 │ … │\n│     … │       … │     … │      … │     … │       … │     … │     … │ … │\n└───────┴─────────┴───────┴────────┴───────┴─────────┴───────┴───────┴───┘\nCompute multiple values columns\n&gt;&gt;&gt; us_rent_income = ibis.examples.us_rent_income.fetch()\n&gt;&gt;&gt; us_rent_income\n┏━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━┓\n┃ geoid  ┃ name       ┃ variable ┃ estimate ┃ moe   ┃\n┡━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━┩\n│ string │ string     │ string   │ int64    │ int64 │\n├────────┼────────────┼──────────┼──────────┼───────┤\n│ 01     │ Alabama    │ income   │    24476 │   136 │\n│ 01     │ Alabama    │ rent     │      747 │     3 │\n│ 02     │ Alaska     │ income   │    32940 │   508 │\n│ 02     │ Alaska     │ rent     │     1200 │    13 │\n│ 04     │ Arizona    │ income   │    27517 │   148 │\n│ 04     │ Arizona    │ rent     │      972 │     4 │\n│ 05     │ Arkansas   │ income   │    23789 │   165 │\n│ 05     │ Arkansas   │ rent     │      709 │     5 │\n│ 06     │ California │ income   │    29454 │   109 │\n│ 06     │ California │ rent     │     1358 │     3 │\n│ …      │ …          │ …        │        … │     … │\n└────────┴────────────┴──────────┴──────────┴───────┘\n&gt;&gt;&gt; us_rent_income.pivot_wider(names_from=\"variable\", values_from=[\"estimate\", \"moe\"])\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━┓\n┃ geoid  ┃ name                 ┃ estimate_income ┃ moe_income ┃ … ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━┩\n│ string │ string               │ int64           │ int64      │ … │\n├────────┼──────────────────────┼─────────────────┼────────────┼───┤\n│ 01     │ Alabama              │           24476 │        136 │ … │\n│ 02     │ Alaska               │           32940 │        508 │ … │\n│ 04     │ Arizona              │           27517 │        148 │ … │\n│ 05     │ Arkansas             │           23789 │        165 │ … │\n│ 06     │ California           │           29454 │        109 │ … │\n│ 08     │ Colorado             │           32401 │        109 │ … │\n│ 09     │ Connecticut          │           35326 │        195 │ … │\n│ 10     │ Delaware             │           31560 │        247 │ … │\n│ 11     │ District of Columbia │           43198 │        681 │ … │\n│ 12     │ Florida              │           25952 │         70 │ … │\n│ …      │ …                    │               … │          … │ … │\n└────────┴──────────────────────┴─────────────────┴────────────┴───┘\nThe column name separator can be changed using the names_sep parameter\n&gt;&gt;&gt; us_rent_income.pivot_wider(\n...     names_from=\"variable\",\n...     names_sep=\".\",\n...     values_from=s.c(\"estimate\", \"moe\"),\n... )\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━┓\n┃ geoid  ┃ name                 ┃ estimate.income ┃ moe.income ┃ … ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━┩\n│ string │ string               │ int64           │ int64      │ … │\n├────────┼──────────────────────┼─────────────────┼────────────┼───┤\n│ 01     │ Alabama              │           24476 │        136 │ … │\n│ 02     │ Alaska               │           32940 │        508 │ … │\n│ 04     │ Arizona              │           27517 │        148 │ … │\n│ 05     │ Arkansas             │           23789 │        165 │ … │\n│ 06     │ California           │           29454 │        109 │ … │\n│ 08     │ Colorado             │           32401 │        109 │ … │\n│ 09     │ Connecticut          │           35326 │        195 │ … │\n│ 10     │ Delaware             │           31560 │        247 │ … │\n│ 11     │ District of Columbia │           43198 │        681 │ … │\n│ 12     │ Florida              │           25952 │         70 │ … │\n│ …      │ …                    │               … │          … │ … │\n└────────┴──────────────────────┴─────────────────┴────────────┴───┘\nSupply an alternative function to summarize values\n&gt;&gt;&gt; warpbreaks = ibis.examples.warpbreaks.fetch().select(\"wool\", \"tension\", \"breaks\")\n&gt;&gt;&gt; warpbreaks\n┏━━━━━━━━┳━━━━━━━━━┳━━━━━━━━┓\n┃ wool   ┃ tension ┃ breaks ┃\n┡━━━━━━━━╇━━━━━━━━━╇━━━━━━━━┩\n│ string │ string  │ int64  │\n├────────┼─────────┼────────┤\n│ A      │ L       │     26 │\n│ A      │ L       │     30 │\n│ A      │ L       │     54 │\n│ A      │ L       │     25 │\n│ A      │ L       │     70 │\n│ A      │ L       │     52 │\n│ A      │ L       │     51 │\n│ A      │ L       │     26 │\n│ A      │ L       │     67 │\n│ A      │ M       │     18 │\n│ …      │ …       │      … │\n└────────┴─────────┴────────┘\n&gt;&gt;&gt; warpbreaks.pivot_wider(names_from=\"wool\", values_from=\"breaks\", values_agg=\"mean\")\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━┓\n┃ tension ┃ A         ┃ B         ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━┩\n│ string  │ float64   │ float64   │\n├─────────┼───────────┼───────────┤\n│ L       │ 44.555556 │ 28.222222 │\n│ M       │ 24.000000 │ 28.777778 │\n│ H       │ 24.555556 │ 18.777778 │\n└─────────┴───────────┴───────────┘\nPassing Deferred objects to values_agg is supported\n&gt;&gt;&gt; warpbreaks.pivot_wider(\n...     names_from=\"tension\",\n...     values_from=\"breaks\",\n...     values_agg=_.sum(),\n... )\n┏━━━━━━━━┳━━━━━━━┳━━━━━━━┳━━━━━━━┓\n┃ wool   ┃ L     ┃ M     ┃ H     ┃\n┡━━━━━━━━╇━━━━━━━╇━━━━━━━╇━━━━━━━┩\n│ string │ int64 │ int64 │ int64 │\n├────────┼───────┼───────┼───────┤\n│ A      │   401 │   216 │   221 │\n│ B      │   254 │   259 │   169 │\n└────────┴───────┴───────┴───────┘\nUse a custom aggregate function\n&gt;&gt;&gt; warpbreaks.pivot_wider(\n...     names_from=\"wool\",\n...     values_from=\"breaks\",\n...     values_agg=lambda col: col.std() / col.mean(),\n... )\n┏━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┓\n┃ tension ┃ A        ┃ B        ┃\n┡━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━┩\n│ string  │ float64  │ float64  │\n├─────────┼──────────┼──────────┤\n│ L       │ 0.406183 │ 0.349325 │\n│ M       │ 0.360844 │ 0.327719 │\n│ H       │ 0.418344 │ 0.260590 │\n└─────────┴──────────┴──────────┘\nGenerate some random data, setting the random seed for reproducibility\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.seed(0)\n&gt;&gt;&gt; raw = ibis.memtable(\n...     [\n...         dict(\n...             product=product,\n...             country=country,\n...             year=year,\n...             production=random.random(),\n...         )\n...         for product in \"AB\"\n...         for country in [\"AI\", \"EI\"]\n...         for year in range(2000, 2015)\n...     ]\n... )\n&gt;&gt;&gt; production = raw.filter(\n...     ((_.product == \"A\") & (_.country == \"AI\")) | (_.product == \"B\")\n... )\n&gt;&gt;&gt; production\n┏━━━━━━━━━┳━━━━━━━━━┳━━━━━━━┳━━━━━━━━━━━━┓\n┃ product ┃ country ┃ year  ┃ production ┃\n┡━━━━━━━━━╇━━━━━━━━━╇━━━━━━━╇━━━━━━━━━━━━┩\n│ string  │ string  │ int64 │ float64    │\n├─────────┼─────────┼───────┼────────────┤\n│ B       │ AI      │  2000 │   0.477010 │\n│ B       │ AI      │  2001 │   0.865310 │\n│ B       │ AI      │  2002 │   0.260492 │\n│ B       │ AI      │  2003 │   0.805028 │\n│ B       │ AI      │  2004 │   0.548699 │\n│ B       │ AI      │  2005 │   0.014042 │\n│ B       │ AI      │  2006 │   0.719705 │\n│ B       │ AI      │  2007 │   0.398824 │\n│ B       │ AI      │  2008 │   0.824845 │\n│ B       │ AI      │  2009 │   0.668153 │\n│ …       │ …       │     … │          … │\n└─────────┴─────────┴───────┴────────────┘\nPivoting with multiple name columns\n&gt;&gt;&gt; production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     values_from=\"production\",\n... )\n┏━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┓\n┃ year  ┃ B_AI     ┃ B_EI     ┃ A_AI     ┃\n┡━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━┩\n│ int64 │ float64  │ float64  │ float64  │\n├───────┼──────────┼──────────┼──────────┤\n│  2000 │ 0.477010 │ 0.870471 │ 0.844422 │\n│  2001 │ 0.865310 │ 0.191067 │ 0.757954 │\n│  2002 │ 0.260492 │ 0.567511 │ 0.420572 │\n│  2003 │ 0.805028 │ 0.238616 │ 0.258917 │\n│  2004 │ 0.548699 │ 0.967540 │ 0.511275 │\n│  2005 │ 0.014042 │ 0.803179 │ 0.404934 │\n│  2006 │ 0.719705 │ 0.447970 │ 0.783799 │\n│  2007 │ 0.398824 │ 0.080446 │ 0.303313 │\n│  2008 │ 0.824845 │ 0.320055 │ 0.476597 │\n│  2009 │ 0.668153 │ 0.507941 │ 0.583382 │\n│     … │        … │        … │        … │\n└───────┴──────────┴──────────┴──────────┘\nSelect a subset of names. This call incurs no computation when constructing the expression.\n&gt;&gt;&gt; production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     names=[(\"A\", \"AI\"), (\"B\", \"AI\")],\n...     values_from=\"production\",\n... )\n┏━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┓\n┃ year  ┃ A_AI     ┃ B_AI     ┃\n┡━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━┩\n│ int64 │ float64  │ float64  │\n├───────┼──────────┼──────────┤\n│  2000 │ 0.844422 │ 0.477010 │\n│  2001 │ 0.757954 │ 0.865310 │\n│  2002 │ 0.420572 │ 0.260492 │\n│  2003 │ 0.258917 │ 0.805028 │\n│  2004 │ 0.511275 │ 0.548699 │\n│  2005 │ 0.404934 │ 0.014042 │\n│  2006 │ 0.783799 │ 0.719705 │\n│  2007 │ 0.303313 │ 0.398824 │\n│  2008 │ 0.476597 │ 0.824845 │\n│  2009 │ 0.583382 │ 0.668153 │\n│     … │        … │        … │\n└───────┴──────────┴──────────┘\nSort the new columns’ names\n&gt;&gt;&gt; production.pivot_wider(\n...     names_from=[\"product\", \"country\"],\n...     values_from=\"production\",\n...     names_sort=True,\n... )\n┏━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┳━━━━━━━━━━┓\n┃ year  ┃ A_AI     ┃ B_AI     ┃ B_EI     ┃\n┡━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━╇━━━━━━━━━━┩\n│ int64 │ float64  │ float64  │ float64  │\n├───────┼──────────┼──────────┼──────────┤\n│  2000 │ 0.844422 │ 0.477010 │ 0.870471 │\n│  2001 │ 0.757954 │ 0.865310 │ 0.191067 │\n│  2002 │ 0.420572 │ 0.260492 │ 0.567511 │\n│  2003 │ 0.258917 │ 0.805028 │ 0.238616 │\n│  2004 │ 0.511275 │ 0.548699 │ 0.967540 │\n│  2005 │ 0.404934 │ 0.014042 │ 0.803179 │\n│  2006 │ 0.783799 │ 0.719705 │ 0.447970 │\n│  2007 │ 0.303313 │ 0.398824 │ 0.080446 │\n│  2008 │ 0.476597 │ 0.824845 │ 0.320055 │\n│  2009 │ 0.583382 │ 0.668153 │ 0.507941 │\n│     … │        … │        … │        … │\n└───────┴──────────┴──────────┴──────────┘\n\n\n\nrelabel\nexpr.types.relations.Table.relabel(self, substitutions)\nRename columns in the table.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubstitutions\ntyping.Mapping[str, str] | typing.Callable[[str], str | None] | str | typing.Literal[‘snake_case’, ‘ALL_CAPS’]\nA mapping, function, or format string mapping old to new column names. If a column isn’t in the mapping (or if the callable returns None) it is left with its original name. May also pass a format string to rename all columns, like \"prefix_{name}\". Also accepts the literal string \"snake_case\" or \"ALL_CAPS\" which will relabel all columns to use a snake_case or \"ALL_CAPS\" naming convention.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA relabeled table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; first3 = s.r[:3]  # first 3 columns\n&gt;&gt;&gt; t = ibis.examples.penguins_raw_raw.fetch().select(first3)\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ studyName ┃ Sample Number ┃ Species                             ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string    │ int64         │ string                              │\n├───────────┼───────────────┼─────────────────────────────────────┤\n│ PAL0708   │             1 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             2 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             3 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             4 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             5 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             6 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             7 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             8 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │             9 │ Adelie Penguin (Pygoscelis adeliae) │\n│ PAL0708   │            10 │ Adelie Penguin (Pygoscelis adeliae) │\n│ …         │             … │ …                                   │\n└───────────┴───────────────┴─────────────────────────────────────┘\nRelabel column names using a mapping from old name to new name\n&gt;&gt;&gt; t.relabel({\"studyName\": \"study_name\"}).head(1)\n┏━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ study_name ┃ Sample Number ┃ Species                             ┃\n┡━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string     │ int64         │ string                              │\n├────────────┼───────────────┼─────────────────────────────────────┤\n│ PAL0708    │             1 │ Adelie Penguin (Pygoscelis adeliae) │\n└────────────┴───────────────┴─────────────────────────────────────┘\nRelabel column names using a snake_case convention\n&gt;&gt;&gt; t.relabel(\"snake_case\").head(1)\n┏━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ study_name ┃ sample_number ┃ species                             ┃\n┡━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string     │ int64         │ string                              │\n├────────────┼───────────────┼─────────────────────────────────────┤\n│ PAL0708    │             1 │ Adelie Penguin (Pygoscelis adeliae) │\n└────────────┴───────────────┴─────────────────────────────────────┘\nRelabel column names using a ALL_CAPS convention\n&gt;&gt;&gt; t.relabel(\"ALL_CAPS\").head(1)\n┏━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ STUDY_NAME ┃ SAMPLE_NUMBER ┃ SPECIES                             ┃\n┡━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string     │ int64         │ string                              │\n├────────────┼───────────────┼─────────────────────────────────────┤\n│ PAL0708    │             1 │ Adelie Penguin (Pygoscelis adeliae) │\n└────────────┴───────────────┴─────────────────────────────────────┘\nRelabel columns using a format string\n&gt;&gt;&gt; t.relabel(\"p_{name}\").head(1)\n┏━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ p_studyName ┃ p_Sample Number ┃ p_Species                           ┃\n┡━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string      │ int64           │ string                              │\n├─────────────┼─────────────────┼─────────────────────────────────────┤\n│ PAL0708     │               1 │ Adelie Penguin (Pygoscelis adeliae) │\n└─────────────┴─────────────────┴─────────────────────────────────────┘\nRelabel column names using a callable\n&gt;&gt;&gt; t.relabel(str.upper).head(1)\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ STUDYNAME ┃ SAMPLE NUMBER ┃ SPECIES                             ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string    │ int64         │ string                              │\n├───────────┼───────────────┼─────────────────────────────────────┤\n│ PAL0708   │             1 │ Adelie Penguin (Pygoscelis adeliae) │\n└───────────┴───────────────┴─────────────────────────────────────┘\n\n\n\nrowid\nexpr.types.relations.Table.rowid(self)\nA unique integer per row.\n!!! note “This operation is only valid on physical tables”\nAny further meaning behind this expression is backend dependent.\nGenerally this corresponds to some index into the database storage\n(for example, sqlite or duckdb's `rowid`).\nFor a monotonically increasing row number, see ibis.row_number.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerColumn\nAn integer column\n\n\n\n\n\n\nschema\nexpr.types.relations.Table.schema(self)\nReturn the schema for this table.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nSchema\nThe table’s schema.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t.schema()\nibis.Schema {\n  species            string\n  island             string\n  bill_length_mm     float64\n  bill_depth_mm      float64\n  flipper_length_mm  int64\n  body_mass_g        int64\n  sex                string\n  year               int64\n}\n\n\n\nselect\nexpr.types.relations.Table.select(self, *exprs, **named_exprs)\nCompute a new table expression using exprs and named_exprs.\nPassing an aggregate function to this method will broadcast the aggregate’s value over the number of rows in the table and automatically constructs a window function expression. See the examples section for more details.\nFor backwards compatibility the keyword argument exprs is reserved and cannot be used to name an expression. This behavior will be removed in v4.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexprs\nibis.Value | str | typing.Iterable[ibis.Value | str]\nColumn expression, string, or list of column expressions and strings.\n()\n\n\nnamed_exprs\nibis.Value | str\nColumn expressions\n{}\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch()\n&gt;&gt;&gt; t\n┏━━━━━━━━━┳━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━┓\n┃ species ┃ island    ┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ … ┃\n┡━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━┩\n│ string  │ string    │ float64        │ float64       │ int64             │ … │\n├─────────┼───────────┼────────────────┼───────────────┼───────────────────┼───┤\n│ Adelie  │ Torgersen │           39.1 │          18.7 │               181 │ … │\n│ Adelie  │ Torgersen │           39.5 │          17.4 │               186 │ … │\n│ Adelie  │ Torgersen │           40.3 │          18.0 │               195 │ … │\n│ Adelie  │ Torgersen │            nan │           nan │              NULL │ … │\n│ Adelie  │ Torgersen │           36.7 │          19.3 │               193 │ … │\n│ Adelie  │ Torgersen │           39.3 │          20.6 │               190 │ … │\n│ Adelie  │ Torgersen │           38.9 │          17.8 │               181 │ … │\n│ Adelie  │ Torgersen │           39.2 │          19.6 │               195 │ … │\n│ Adelie  │ Torgersen │           34.1 │          18.1 │               193 │ … │\n│ Adelie  │ Torgersen │           42.0 │          20.2 │               190 │ … │\n│ …       │ …         │              … │             … │                 … │ … │\n└─────────┴───────────┴────────────────┴───────────────┴───────────────────┴───┘\nSimple projection\n&gt;&gt;&gt; t.select(\"island\", \"bill_length_mm\").head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━┓\n┃ island    ┃ bill_length_mm ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━┩\n│ string    │ float64        │\n├───────────┼────────────────┤\n│ Torgersen │           39.1 │\n│ Torgersen │           39.5 │\n│ Torgersen │           40.3 │\n│ Torgersen │            nan │\n│ Torgersen │           36.7 │\n└───────────┴────────────────┘\nProjection by zero-indexed column position\n&gt;&gt;&gt; t.select(0, 4).head()\n┏━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┓\n┃ species ┃ flipper_length_mm ┃\n┡━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━┩\n│ string  │ int64             │\n├─────────┼───────────────────┤\n│ Adelie  │               181 │\n│ Adelie  │               186 │\n│ Adelie  │               195 │\n│ Adelie  │              NULL │\n│ Adelie  │               193 │\n└─────────┴───────────────────┘\nProjection with renaming and compute in one call\n&gt;&gt;&gt; t.select(next_year=t.year + 1).head()\n┏━━━━━━━━━━━┓\n┃ next_year ┃\n┡━━━━━━━━━━━┩\n│ int64     │\n├───────────┤\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n│      2008 │\n└───────────┘\nProjection with aggregation expressions\n&gt;&gt;&gt; t.select(\"island\", bill_mean=t.bill_length_mm.mean()).head()\n┏━━━━━━━━━━━┳━━━━━━━━━━━┓\n┃ island    ┃ bill_mean ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━┩\n│ string    │ float64   │\n├───────────┼───────────┤\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n│ Torgersen │  43.92193 │\n└───────────┴───────────┘\nProjection with a selector\n&gt;&gt;&gt; import ibis.selectors as s\n&gt;&gt;&gt; t.select(s.numeric() & ~s.c(\"year\")).head()\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ body_mass_g ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ float64        │ float64       │ int64             │ int64       │\n├────────────────┼───────────────┼───────────────────┼─────────────┤\n│           39.1 │          18.7 │               181 │        3750 │\n│           39.5 │          17.4 │               186 │        3800 │\n│           40.3 │          18.0 │               195 │        3250 │\n│            nan │           nan │              NULL │        NULL │\n│           36.7 │          19.3 │               193 │        3450 │\n└────────────────┴───────────────┴───────────────────┴─────────────┘\nProjection + aggregation across multiple columns\n&gt;&gt;&gt; from ibis import _\n&gt;&gt;&gt; t.select(s.across(s.numeric() & ~s.c(\"year\"), _.mean())).head()\n┏━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┓\n┃ bill_length_mm ┃ bill_depth_mm ┃ flipper_length_mm ┃ body_mass_g ┃\n┡━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━┩\n│ float64        │ float64       │ float64           │ float64     │\n├────────────────┼───────────────┼───────────────────┼─────────────┤\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n│       43.92193 │      17.15117 │        200.915205 │ 4201.754386 │\n└────────────────┴───────────────┴───────────────────┴─────────────┘\n\n\n\nsql\nexpr.types.relations.Table.sql(self, query, dialect=None)\nRun a SQL query against a table expression.\nSee [Table.alias][ibis.expr.types.relations.Table.alias] for details on using named table expressions in a SQL string.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nQuery string\nrequired\n\n\ndialect\nstr | None\nOptional string indicating the dialect of query. The default value of None will use the backend’s native dialect.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nAn opaque table expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.examples.penguins.fetch(table_name=\"penguins\")\n&gt;&gt;&gt; expr = t.sql(\"SELECT island, mean(bill_length_mm) FROM penguins GROUP BY 1 ORDER BY 2 DESC\")\n&gt;&gt;&gt; expr\n┏━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━┓\n┃ island    ┃ mean(bill_length_mm) ┃\n┡━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━┩\n│ string    │ float64              │\n├───────────┼──────────────────────┤\n│ Biscoe    │            45.257485 │\n│ Dream     │            44.167742 │\n│ Torgersen │            38.950980 │\n└───────────┴──────────────────────┘\n\n\n\nto_array\nexpr.types.relations.Table.to_array(self)\nView a single column table as an array.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nValue\nA single column view of a table\n\n\n\n\n\n\nto_pandas\nexpr.types.relations.Table.to_pandas(self, **kwargs)\nConvert a table expression to a pandas DataFrame.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkwargs\n\nSame as keyword arguments to [execute][ibis.expr.types.core.Expr.execute]\n{}\n\n\n\n\n\n\ntry_cast\nexpr.types.relations.Table.try_cast(self, schema)\nCast the columns of a table.\nIf the cast fails for a row, the value is returned as NULL or NaN depending on backend behavior.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nschema\nSupportsSchema\nMapping, schema or iterable of pairs to use for casting\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nCasted table\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [\"1\", \"2\", \"3\"], \"b\": [\"2.2\", \"3.3\", \"book\"]})\n&gt;&gt;&gt; t.try_cast({\"a\": \"int\", \"b\": \"float\"})\n┏━━━━━━━┳━━━━━━━━━┓\n┃ a     ┃ b       ┃\n┡━━━━━━━╇━━━━━━━━━┩\n│ int64 │ float64 │\n├───────┼─────────┤\n│     1 │     2.2 │\n│     2 │     3.3 │\n│     3 │     nan │\n└───────┴─────────┘\n\n\n\nunion\nexpr.types.relations.Table.union(self, table, *rest, distinct=False)\nCompute the set union of multiple table expressions.\nThe input tables must have identical schemas.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable\nTable\nA table expression\nrequired\n\n\n*rest\nTable\nAdditional table expressions\n()\n\n\ndistinct\nbool\nOnly return distinct rows\nFalse\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA new table containing the union of all input tables.\n\n\n\n\n\nSee Also\n[ibis.union][ibis.union]\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t1 = ibis.memtable({\"a\": [1, 2]})\n&gt;&gt;&gt; t1\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n└───────┘\n&gt;&gt;&gt; t2 = ibis.memtable({\"a\": [2, 3]})\n&gt;&gt;&gt; t2\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     2 │\n│     3 │\n└───────┘\n&gt;&gt;&gt; t1.union(t2)  # union all by default\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n│     2 │\n│     3 │\n└───────┘\n&gt;&gt;&gt; t1.union(t2, distinct=True).order_by(\"a\")\n┏━━━━━━━┓\n┃ a     ┃\n┡━━━━━━━┩\n│ int64 │\n├───────┤\n│     1 │\n│     2 │\n│     3 │\n└───────┘\n\n\n\nunpack\nexpr.types.relations.Table.unpack(self, *columns)\nProject the struct fields of each of columns into self.\nExisting fields are retained in the projection.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nstr\nString column names to project into self.\n()\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTable\nThe child table with struct fields of each of columns projected.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; lines = '''\n...     {\"name\": \"a\", \"pos\": {\"lat\": 10.1, \"lon\": 30.3}}\n...     {\"name\": \"b\", \"pos\": {\"lat\": 10.2, \"lon\": 30.2}}\n...     {\"name\": \"c\", \"pos\": {\"lat\": 10.3, \"lon\": 30.1}}\n... '''\n&gt;&gt;&gt; with open(\"/tmp/lines.json\", \"w\") as f:\n...     _ = f.write(lines)\n&gt;&gt;&gt; t = ibis.read_json(\"/tmp/lines.json\")\n&gt;&gt;&gt; t\n┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ name   ┃ pos                                ┃\n┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string │ struct&lt;lat: float64, lon: float64&gt; │\n├────────┼────────────────────────────────────┤\n│ a      │ {'lat': 10.1, 'lon': 30.3}         │\n│ b      │ {'lat': 10.2, 'lon': 30.2}         │\n│ c      │ {'lat': 10.3, 'lon': 30.1}         │\n└────────┴────────────────────────────────────┘\n&gt;&gt;&gt; t.unpack(\"pos\")\n┏━━━━━━━━┳━━━━━━━━━┳━━━━━━━━━┓\n┃ name   ┃ lat     ┃ lon     ┃\n┡━━━━━━━━╇━━━━━━━━━╇━━━━━━━━━┩\n│ string │ float64 │ float64 │\n├────────┼─────────┼─────────┤\n│ a      │    10.1 │    30.3 │\n│ b      │    10.2 │    30.2 │\n│ c      │    10.3 │    30.1 │\n└────────┴─────────┴─────────┘\n\n\nSee Also\n[StructValue.lift][ibis.expr.types.structs.StructValue.lift]\n\n\n\nview\nexpr.types.relations.Table.view(self)\nCreate a new table expression distinct from the current one.\nUse this API for any self-referencing operations like a self-join.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression"
  },
  {
    "objectID": "reference/expression-tables.html#methods-1",
    "href": "reference/expression-tables.html#methods-1",
    "title": "Table Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\naggregate\nCompute aggregates over a group by.\n\n\ncount\nComputing the number of rows per group.\n\n\nhaving\nAdd a post-aggregation result filter expr.\n\n\nmutate\nReturn a table projection with window functions applied.\n\n\norder_by\nSort a grouped table expression by expr.\n\n\nover\nApply a window over the input expressions.\n\n\nselect\nProject new columns out of the grouped table.\n\n\n\n\naggregate\nexpr.types.relations.GroupedTable.aggregate(self, metrics=None, **kwds)\nCompute aggregates over a group by.\n\n\ncount\nexpr.types.relations.GroupedTable.count(self)\nComputing the number of rows per group.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nThe aggregated table\n\n\n\n\n\n\nhaving\nexpr.types.relations.GroupedTable.having(self, expr)\nAdd a post-aggregation result filter expr.\n!!! warning “Expressions like x is None return bool and will not generate a SQL comparison to NULL”\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpr\nibis.BooleanScalar\nAn expression that filters based on an aggregate value.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGroupedTable\nA grouped table expression\n\n\n\n\n\n\nmutate\nexpr.types.relations.GroupedTable.mutate(self, *exprs, **kwexprs)\nReturn a table projection with window functions applied.\nAny arguments can be functions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexprs\nibis.Value | typing.Sequence[ibis.Value]\nList of expressions\n()\n\n\nkwexprs\nibis.Value\nExpressions\n{}\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; t = ibis.table([\n...     ('foo', 'string'),\n...     ('bar', 'string'),\n...     ('baz', 'double'),\n... ], name='t')\n&gt;&gt;&gt; t\nUnboundTable: t\n  foo string\n  bar string\n  baz float64\n&gt;&gt;&gt; expr = (t.group_by('foo')\n...          .order_by(ibis.desc('bar'))\n...          .mutate(qux=lambda x: x.baz.lag(), qux2=t.baz.lead()))\n&gt;&gt;&gt; print(expr)\nr0 := UnboundTable: t\n  foo string\n  bar string\n  baz float64\nSelection[r0]\n  selections:\n    r0\n    qux:  WindowFunction(...)\n    qux2: WindowFunction(...)\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTable\nA table expression with window functions applied\n\n\n\n\n\n\norder_by\nexpr.types.relations.GroupedTable.order_by(self, expr)\n\nNotes\nThis API call is ignored in aggregations.\n\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nexpr\nibis.Value | typing.Iterable[ibis.Value]\nExpressions to order the results by\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGroupedTable\nA sorted grouped GroupedTable\n\n\n\n\n\n\nover\nexpr.types.relations.GroupedTable.over(self, window=None, *, rows=None, range=None, group_by=None, order_by=None)\nApply a window over the input expressions.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwindow\n\nWindow to add to the input\nNone\n\n\nrows\n\nWhether to use the ROWS window clause\nNone\n\n\nrange\n\nWhether to use the RANGE window clause\nNone\n\n\ngroup_by\n\nGrouping key\nNone\n\n\norder_by\n\nOrdering key\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nGroupedTable\nA new grouped table expression\n\n\n\n\n\n\nselect\nexpr.types.relations.GroupedTable.select(self, *exprs, **kwexprs)\n\nSee Also\n[GroupedTable.mutate][ibis.expr.types.groupby.GroupedTable.mutate]"
  },
  {
    "objectID": "reference/top_level.html",
    "href": "reference/top_level.html",
    "title": "Top-level APIs",
    "section": "",
    "text": "These methods and objecst are available directly on the ibis module."
  },
  {
    "objectID": "reference/top_level.html#parameters",
    "href": "reference/top_level.html#parameters",
    "title": "Top-level APIs",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npredicates\nibis.BooleanValue\nBoolean value expressions\n()"
  },
  {
    "objectID": "reference/top_level.html#returns",
    "href": "reference/top_level.html#returns",
    "title": "Top-level APIs",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nA new predicate that evaluates to True if all composing predicates are True. If no predicates were provided, returns True."
  },
  {
    "objectID": "reference/expression-strings.html",
    "href": "reference/expression-strings.html",
    "title": "String Expressions",
    "section": "",
    "text": "All string operations are valid for both scalars and columns."
  },
  {
    "objectID": "reference/expression-strings.html#methods",
    "href": "reference/expression-strings.html#methods",
    "title": "String Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nascii_str\nReturn the numeric ASCII code of the first character of a string.\n\n\nauthority\nParse a URL and extract authority.\n\n\ncapitalize\nCapitalize the input string.\n\n\nconcat\nConcatenate strings.\n\n\ncontains\nReturn whether the expression contains substr.\n\n\nconvert_base\nConvert a string representing an integer from one base to another.\n\n\nendswith\nDetermine if self ends with end.\n\n\nfile\nParse a URL and extract file.\n\n\nfind\nReturn the position of the first occurrence of substring.\n\n\nfind_in_set\nFind the first occurrence of str_list within a list of strings.\n\n\nfragment\nParse a URL and extract fragment identifier.\n\n\nhashbytes\nCompute the binary hash value of the input.\n\n\nhost\nParse a URL and extract host.\n\n\nilike\nMatch patterns against self, case-insensitive.\n\n\njoin\nJoin a list of strings using self as the separator.\n\n\nleft\nReturn the nchars left-most characters.\n\n\nlength\nCompute the length of a string.\n\n\nlike\nMatch patterns against self, case-sensitive.\n\n\nlower\nConvert string to all lowercase.\n\n\nlpad\nPad arg by truncating on the right or padding on the left.\n\n\nlstrip\nRemove whitespace from the left side of string.\n\n\npath\nParse a URL and extract path.\n\n\nprotocol\nParse a URL and extract protocol.\n\n\nquery\nParse a URL and returns query strring or query string parameter.\n\n\nre_extract\nReturn the specified match at index from a regex pattern.\n\n\nre_replace\nReplace match found by regex pattern with replacement.\n\n\nre_search\nReturn whether the values match pattern.\n\n\nrepeat\nRepeat a string n times.\n\n\nreplace\nReplace each exact match of pattern with replacement.\n\n\nreverse\nReverse the characters of a string.\n\n\nright\nReturn up to nchars from the end of each string.\n\n\nrpad\nPad self by truncating or padding on the right.\n\n\nrstrip\nRemove whitespace from the right side of string.\n\n\nsplit\nSplit as string on delimiter.\n\n\nstartswith\nDetermine whether self starts with end.\n\n\nstrip\nRemove whitespace from left and right sides of a string.\n\n\nsubstr\nExtract a substring.\n\n\nto_timestamp\nParse a string and return a timestamp.\n\n\ntranslate\nReplace from_str characters in self characters in to_str.\n\n\nupper\nConvert string to all uppercase.\n\n\nuserinfo\nParse a URL and extract user info.\n\n\n\n\nascii_str\nexpr.types.strings.StringValue.ascii_str(self)\nReturn the numeric ASCII code of the first character of a string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nASCII code of the first character of the input\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n&gt;&gt;&gt; t.s.ascii_str()\n┏━━━━━━━━━━━━━━━━┓\n┃ StringAscii(s) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ int32          │\n├────────────────┤\n│             97 │\n│            100 │\n│            103 │\n└────────────────┘\n\n\n\nauthority\nexpr.types.strings.StringValue.authority(self)\nParse a URL and extract authority.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n&gt;&gt;&gt; result = url.authority()  # user:pass@example.com:80\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\ncapitalize\nexpr.types.strings.StringValue.capitalize(self)\nCapitalize the input string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nCapitalized string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n&gt;&gt;&gt; t.s.capitalize()\n┏━━━━━━━━━━━━━━━┓\n┃ Capitalize(s) ┃\n┡━━━━━━━━━━━━━━━┩\n│ string        │\n├───────────────┤\n│ Abc           │\n│ Def           │\n│ Ghi           │\n└───────────────┘\n\n\n\nconcat\nexpr.types.strings.StringValue.concat(self, other, *args)\nConcatenate strings.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nother\nstr | ibis.expr.types.strings.StringValue\nString to concatenate\nrequired\n\n\nargs\nstr | ibis.expr.types.strings.StringValue\nAdditional strings to concatenate\n()\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nAll strings concatenated\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n&gt;&gt;&gt; t.s.concat(\"xyz\")\n┏━━━━━━━━━━━━━━━━┓\n┃ StringConcat() ┃\n┡━━━━━━━━━━━━━━━━┩\n│ string         │\n├────────────────┤\n│ abcxyz         │\n│ bacxyz         │\n│ bcaxyz         │\n└────────────────┘\n\n\n\ncontains\nexpr.types.strings.StringValue.contains(self, substr)\nReturn whether the expression contains substr.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubstr\nstr | ibis.expr.types.strings.StringValue\nSubstring for which to check\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nBoolean indicating the presence of substr in the expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"bab\", \"ddd\", \"eaf\"]})\n&gt;&gt;&gt; t.s.contains(\"a\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringContains(s, 'a') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ True                   │\n│ False                  │\n│ True                   │\n└────────────────────────┘\n\n\n\nconvert_base\nexpr.types.strings.StringValue.convert_base(self, from_base, to_base)\nConvert a string representing an integer from one base to another.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfrom_base\nint | ibis.expr.types.IntegerValue\nNumeric base of the expression\nrequired\n\n\nto_base\nint | ibis.expr.types.IntegerValue\nNew base\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nConverted expression\n\n\n\n\n\n\nendswith\nexpr.types.strings.StringValue.endswith(self, end)\nDetermine if self ends with end.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nend\nstr | ibis.expr.types.strings.StringValue\nSuffix to check for\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nBoolean indicating whether self ends with end\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n&gt;&gt;&gt; t.s.endswith(\"project\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ EndsWith(s, 'project') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                │\n├────────────────────────┤\n│ True                   │\n│ False                  │\n└────────────────────────┘\n\n\n\nfile\nexpr.types.strings.StringValue.file(self)\nParse a URL and extract file.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://example.com:80/docs/books/tutorial/index.html?name=networking\")\n&gt;&gt;&gt; result = url.file()  # docs/books/tutorial/index.html?name=networking\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nfind\nexpr.types.strings.StringValue.find(self, substr, start=None, end=None)\nReturn the position of the first occurrence of substring.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsubstr\nstr | ibis.expr.types.strings.StringValue\nSubstring to search for\nrequired\n\n\nstart\nint | ibis.expr.types.IntegerValue | None\nZero based index of where to start the search\nNone\n\n\nend\nint | ibis.expr.types.IntegerValue | None\nZero based index of where to stop the search. Currently not implemented.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nPosition of substr in arg starting from start\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n&gt;&gt;&gt; t.s.find(\"a\")\n┏━━━━━━━━━━━━━━━━━━━━┓\n┃ StringFind(s, 'a') ┃\n┡━━━━━━━━━━━━━━━━━━━━┩\n│ int64              │\n├────────────────────┤\n│                  0 │\n│                  1 │\n│                  2 │\n└────────────────────┘\n&gt;&gt;&gt; t.s.find(\"z\")\n┏━━━━━━━━━━━━━━━━━━━━┓\n┃ StringFind(s, 'z') ┃\n┡━━━━━━━━━━━━━━━━━━━━┩\n│ int64              │\n├────────────────────┤\n│                 -1 │\n│                 -1 │\n│                 -1 │\n└────────────────────┘\n\n\n\nfind_in_set\nexpr.types.strings.StringValue.find_in_set(self, str_list)\nFind the first occurrence of str_list within a list of strings.\nNo string in str_list can have a comma.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstr_list\ntyping.Sequence[str]\nSequence of strings\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nPosition of str_list in self. Returns -1 if self isn’t found or if self contains ','.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; table = ibis.table(dict(string_col='string'))\n&gt;&gt;&gt; result = table.string_col.find_in_set(['a', 'b'])\n\n\n\nfragment\nexpr.types.strings.StringValue.fragment(self)\nParse a URL and extract fragment identifier.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://example.com:80/docs/#DOWNLOADING\")\n&gt;&gt;&gt; result = url.fragment()  # DOWNLOADING\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nhashbytes\nexpr.types.strings.StringValue.hashbytes(self, how='sha256')\nCompute the binary hash value of the input.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhow\ntyping.Literal[‘md5’, ‘sha1’, ‘sha256’, ‘sha512’]\nHash algorithm to use\n'sha256'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBinaryValue\nBinary expression\n\n\n\n\n\n\nhost\nexpr.types.strings.StringValue.host(self)\nParse a URL and extract host.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n&gt;&gt;&gt; result = url.host()  # example.com\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nilike\nexpr.types.strings.StringValue.ilike(self, patterns)\nMatch patterns against self, case-insensitive.\nThis function is modeled after SQL’s ILIKE directive. Use % as a multiple-character wildcard or _ as a single-character wildcard.\nUse re_search or rlike for regular expression-based matching.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npatterns\nstr | ibis.expr.types.strings.StringValue | typing.Iterable[str | ibis.expr.types.strings.StringValue]\nIf pattern is a list, then if any pattern matches the input then the corresponding row in the output is True.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nColumn indicating matches\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n&gt;&gt;&gt; t.s.ilike(\"%PROJect\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringSQLILike(s, '%PROJect') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                       │\n├───────────────────────────────┤\n│ True                          │\n│ False                         │\n└───────────────────────────────┘\n\n\n\njoin\nexpr.types.strings.StringValue.join(self, strings)\nJoin a list of strings using self as the separator.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstrings\ntyping.Sequence[str | ibis.expr.types.strings.StringValue] | ibis.expr.types.ArrayValue\nStrings to join with arg\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nJoined string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"arr\": [[\"a\", \"b\", \"c\"], None, [], [\"b\", None]]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━━━━━━━━━━━━━━┓\n┃ arr                  ┃\n┡━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;string&gt;        │\n├──────────────────────┤\n│ ['a', 'b', ... +1]   │\n│ NULL                 │\n│ []                   │\n│ ['b', None]          │\n└──────────────────────┘\n&gt;&gt;&gt; ibis.literal(\"|\").join(t.arr)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ArrayStringJoin('|', arr) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                    │\n├───────────────────────────┤\n│ a|b|c                     │\n│ NULL                      │\n│ NULL                      │\n│ b                         │\n└───────────────────────────┘\n\n\nSee Also\n[ArrayValue.join][ibis.expr.types.arrays.ArrayValue.join]\n\n\n\nleft\nexpr.types.strings.StringValue.left(self, nchars)\nReturn the nchars left-most characters.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnchars\nint | ibis.expr.types.IntegerValue\nMaximum number of characters to return\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nCharacters from the start\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n&gt;&gt;&gt; t.s.left(2)\n┏━━━━━━━━━━━━━━━━━━━━┓\n┃ Substring(s, 0, 2) ┃\n┡━━━━━━━━━━━━━━━━━━━━┩\n│ string             │\n├────────────────────┤\n│ ab                 │\n│ de                 │\n│ hi                 │\n└────────────────────┘\n\n\n\nlength\nexpr.types.strings.StringValue.length(self)\nCompute the length of a string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nThe length of each string in the expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"aaa\", \"a\", \"aa\"]})\n&gt;&gt;&gt; t.s.length()\n┏━━━━━━━━━━━━━━━━━┓\n┃ StringLength(s) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ int32           │\n├─────────────────┤\n│               3 │\n│               1 │\n│               2 │\n└─────────────────┘\n\n\n\nlike\nexpr.types.strings.StringValue.like(self, patterns)\nMatch patterns against self, case-sensitive.\nThis function is modeled after the SQL LIKE directive. Use % as a multiple-character wildcard or _ as a single-character wildcard.\nUse re_search or rlike for regular expression-based matching.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npatterns\nstr | ibis.expr.types.strings.StringValue | typing.Iterable[str | ibis.expr.types.strings.StringValue]\nIf pattern is a list, then if any pattern matches the input then the corresponding row in the output is True.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nColumn indicating matches\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n&gt;&gt;&gt; t.s.like(\"%project\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringSQLLike(s, '%project') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                      │\n├──────────────────────────────┤\n│ True                         │\n│ False                        │\n└──────────────────────────────┘\n\n\n\nlower\nexpr.types.strings.StringValue.lower(self)\nConvert string to all lowercase.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nLowercase string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"AAA\", \"a\", \"AA\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ AAA    │\n│ a      │\n│ AA     │\n└────────┘\n&gt;&gt;&gt; t.s.lower()\n┏━━━━━━━━━━━━━━┓\n┃ Lowercase(s) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ aaa          │\n│ a            │\n│ aa           │\n└──────────────┘\n\n\n\nlpad\nexpr.types.strings.StringValue.lpad(self, length, pad=' ')\nPad arg by truncating on the right or padding on the left.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlength\nint | ibis.expr.types.IntegerValue\nLength of output string\nrequired\n\n\npad\nstr | ibis.expr.types.strings.StringValue\nPad character\n' '\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nLeft-padded string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n&gt;&gt;&gt; t.s.lpad(5, \"-\")\n┏━━━━━━━━━━━━━━━━━┓\n┃ LPad(s, 5, '-') ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ --abc           │\n│ --def           │\n│ -ghij           │\n└─────────────────┘\n\n\n\nlstrip\nexpr.types.strings.StringValue.lstrip(self)\nRemove whitespace from the left side of string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nLeft-stripped string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n&gt;&gt;&gt; t.s.lstrip()\n┏━━━━━━━━━━━┓\n┃ LStrip(s) ┃\n┡━━━━━━━━━━━┩\n│ string    │\n├───────────┤\n│ a\\t       │\n│ b\\n       │\n│ c\\t       │\n└───────────┘\n\n\n\npath\nexpr.types.strings.StringValue.path(self)\nParse a URL and extract path.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://example.com:80/docs/books/tutorial/index.html?name=networking\")\n&gt;&gt;&gt; result = url.path()  # docs/books/tutorial/index.html\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nprotocol\nexpr.types.strings.StringValue.protocol(self)\nParse a URL and extract protocol.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n&gt;&gt;&gt; result = url.protocol()  # https\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nquery\nexpr.types.strings.StringValue.query(self, key=None)\nParse a URL and returns query strring or query string parameter.\nIf key is passed, return the value of the query string parameter named. If key is absent, return the query string.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nkey\nstr | ibis.expr.types.strings.StringValue | None\nQuery component to extract\nNone\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://example.com:80/docs/books/tutorial/index.html?name=networking\")\n&gt;&gt;&gt; result = url.query()  # name=networking\n&gt;&gt;&gt; query_name = url.query('name')  # networking\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value\n\n\n\n\n\n\nre_extract\nexpr.types.strings.StringValue.re_extract(self, pattern, index)\nReturn the specified match at index from a regex pattern.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npattern\nstr | ibis.expr.types.strings.StringValue\nRegular expression pattern string\nrequired\n\n\nindex\nint | ibis.expr.types.IntegerValue\nThe index of the match group to return. The behavior of this function follows the behavior of Python’s match objects: when index is zero and there’s a match, return the entire match, otherwise return the content of the index-th match group.\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted match or whole string if index is zero\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\nExtract a specific group\n&gt;&gt;&gt; t.s.re_extract(r\"^(a)bc\", 1)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexExtract(s, '^(a)bc', 1) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ a                            │\n│ ~                            │\n│ ~                            │\n└──────────────────────────────┘\nExtract the entire match\n&gt;&gt;&gt; t.s.re_extract(r\"^(a)bc\", 0)\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexExtract(s, '^(a)bc', 0) ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ abc                          │\n│ ~                            │\n│ ~                            │\n└──────────────────────────────┘\n\n\n\nre_replace\nexpr.types.strings.StringValue.re_replace(self, pattern, replacement)\nReplace match found by regex pattern with replacement.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npattern\nstr | ibis.expr.types.strings.StringValue\nRegular expression string\nrequired\n\n\nreplacement\nstr | ibis.expr.types.strings.StringValue\nReplacement string or regular expression\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nModified string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n&gt;&gt;&gt; t.s.re_replace(\"^(a)\", \"b\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexReplace(s, '^(a)', 'b') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                       │\n├──────────────────────────────┤\n│ bbc                          │\n│ bac                          │\n│ bca                          │\n└──────────────────────────────┘\n\n\n\nre_search\nexpr.types.strings.StringValue.re_search(self, pattern)\nReturn whether the values match pattern.\nReturns True if the regex matches a string and False otherwise.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npattern\nstr | ibis.expr.types.strings.StringValue\nRegular expression use for searching\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nIndicator of matches\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n&gt;&gt;&gt; t.s.re_search(\".+Hub\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ RegexSearch(s, '.+Hub') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean                 │\n├─────────────────────────┤\n│ False                   │\n│ True                    │\n└─────────────────────────┘\n\n\n\nrepeat\nexpr.types.strings.StringValue.repeat(self, n)\nRepeat a string n times.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nn\nint | ibis.expr.types.IntegerValue\nNumber of repetitions\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nRepeated string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"a\", \"bb\", \"c\"]})\n&gt;&gt;&gt; t.s.repeat(5)\n┏━━━━━━━━━━━━━━┓\n┃ Repeat(s, 5) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ aaaaa        │\n│ bbbbbbbbbb   │\n│ ccccc        │\n└──────────────┘\n\n\n\nreplace\nexpr.types.strings.StringValue.replace(self, pattern, replacement)\nReplace each exact match of pattern with replacement.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\npattern\nStringValue\nString pattern\nrequired\n\n\nreplacement\nStringValue\nString replacement\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nReplaced string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"bac\", \"bca\"]})\n&gt;&gt;&gt; t.s.replace(\"b\", \"z\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringReplace(s, 'b', 'z') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                     │\n├────────────────────────────┤\n│ azc                        │\n│ zac                        │\n│ zca                        │\n└────────────────────────────┘\n\n\n\nreverse\nexpr.types.strings.StringValue.reverse(self)\nReverse the characters of a string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nReversed string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghi\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ abc    │\n│ def    │\n│ ghi    │\n└────────┘\n&gt;&gt;&gt; t.s.reverse()\n┏━━━━━━━━━━━━┓\n┃ Reverse(s) ┃\n┡━━━━━━━━━━━━┩\n│ string     │\n├────────────┤\n│ cba        │\n│ fed        │\n│ ihg        │\n└────────────┘\n\n\n\nright\nexpr.types.strings.StringValue.right(self, nchars)\nReturn up to nchars from the end of each string.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnchars\nint | ibis.expr.types.IntegerValue\nMaximum number of characters to return\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nCharacters from the end\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n&gt;&gt;&gt; t.s.right(2)\n┏━━━━━━━━━━━━━━━━┓\n┃ StrRight(s, 2) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ string         │\n├────────────────┤\n│ bc             │\n│ fg             │\n│ lk             │\n└────────────────┘\n\n\n\nrpad\nexpr.types.strings.StringValue.rpad(self, length, pad=' ')\nPad self by truncating or padding on the right.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nself\n\nString to pad\nrequired\n\n\nlength\nint | ibis.expr.types.IntegerValue\nLength of output string\nrequired\n\n\npad\nstr | ibis.expr.types.strings.StringValue\nPad character\n' '\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nRight-padded string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"def\", \"ghij\"]})\n&gt;&gt;&gt; t.s.rpad(5, \"-\")\n┏━━━━━━━━━━━━━━━━━┓\n┃ RPad(s, 5, '-') ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ abc--           │\n│ def--           │\n│ ghij-           │\n└─────────────────┘\n\n\n\nrstrip\nexpr.types.strings.StringValue.rstrip(self)\nRemove whitespace from the right side of string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nRight-stripped string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n&gt;&gt;&gt; t.s.rstrip()\n┏━━━━━━━━━━━┓\n┃ RStrip(s) ┃\n┡━━━━━━━━━━━┩\n│ string    │\n├───────────┤\n│ \\ta       │\n│ \\nb       │\n│ \\vc       │\n└───────────┘\n\n\n\nsplit\nexpr.types.strings.StringValue.split(self, delimiter)\nSplit as string on delimiter.\n!!! note “This API only works on backends with array support.”\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndelimiter\nstr | ibis.expr.types.strings.StringValue\nValue to split by\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nArrayValue\nThe string split by delimiter\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"col\": [\"a,b,c\", \"d,e\", \"f\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ col    ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ a,b,c  │\n│ d,e    │\n│ f      │\n└────────┘\n&gt;&gt;&gt; t.col.split(\",\")\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringSplit(col, ',') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ array&lt;string&gt;         │\n├───────────────────────┤\n│ ['a', 'b', ... +1]    │\n│ ['d', 'e']            │\n│ ['f']                 │\n└───────────────────────┘\n\n\n\nstartswith\nexpr.types.strings.StringValue.startswith(self, start)\nDetermine whether self starts with end.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nstr | ibis.expr.types.strings.StringValue\nprefix to check for\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nBooleanValue\nBoolean indicating whether self starts with start\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"Ibis project\", \"GitHub\"]})\n&gt;&gt;&gt; t.s.startswith(\"Ibis\")\n┏━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StartsWith(s, 'Ibis') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━┩\n│ boolean               │\n├───────────────────────┤\n│ True                  │\n│ False                 │\n└───────────────────────┘\n\n\n\nstrip\nexpr.types.strings.StringValue.strip(self)\nRemove whitespace from left and right sides of a string.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nStripped string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"\\ta\\t\", \"\\nb\\n\", \"\\vc\\t\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ \\ta\\t  │\n│ \\nb\\n  │\n│ \\vc\\t  │\n└────────┘\n&gt;&gt;&gt; t.s.strip()\n┏━━━━━━━━━━┓\n┃ Strip(s) ┃\n┡━━━━━━━━━━┩\n│ string   │\n├──────────┤\n│ a        │\n│ b        │\n│ c        │\n└──────────┘\n\n\n\nsubstr\nexpr.types.strings.StringValue.substr(self, start, length=None)\nExtract a substring.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstart\nint | ibis.expr.types.IntegerValue\nFirst character to start splitting, indices start at 0\nrequired\n\n\nlength\nint | ibis.expr.types.IntegerValue | None\nMaximum length of each substring. If not supplied, searches the entire string\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nFound substring\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"abc\", \"defg\", \"hijlk\"]})\n&gt;&gt;&gt; t.s.substr(2)\n┏━━━━━━━━━━━━━━━━━┓\n┃ Substring(s, 2) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ string          │\n├─────────────────┤\n│ c               │\n│ fg              │\n│ jlk             │\n└─────────────────┘\n\n\n\nto_timestamp\nexpr.types.strings.StringValue.to_timestamp(self, format_str)\nParse a string and return a timestamp.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nformat_str\nstr\nFormat string in strptime format\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTimestampValue\nParsed timestamp value\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"ts\": [\"20170206\"]})\n&gt;&gt;&gt; t.ts.to_timestamp(\"%Y%m%d\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ StringToTimestamp(ts, '%Y%m%d') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ timestamp('UTC')                │\n├─────────────────────────────────┤\n│ 2017-02-06 00:00:00+00:00       │\n└─────────────────────────────────┘\n\n\n\ntranslate\nexpr.types.strings.StringValue.translate(self, from_str, to_str)\nReplace from_str characters in self characters in to_str.\nTo avoid unexpected behavior, from_str should be shorter than to_str.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfrom_str\nStringValue\nCharacters in arg to replace\nrequired\n\n\nto_str\nStringValue\nCharacters to use for replacement\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nTranslated string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; table = ibis.table(dict(string_col='string'))\n&gt;&gt;&gt; result = table.string_col.translate('a', 'b')\n\n\n\nupper\nexpr.types.strings.StringValue.upper(self)\nConvert string to all uppercase.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nUppercase string\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"s\": [\"aaa\", \"A\", \"aa\"]})\n&gt;&gt;&gt; t\n┏━━━━━━━━┓\n┃ s      ┃\n┡━━━━━━━━┩\n│ string │\n├────────┤\n│ aaa    │\n│ A      │\n│ aa     │\n└────────┘\n&gt;&gt;&gt; t.s.upper()\n┏━━━━━━━━━━━━━━┓\n┃ Uppercase(s) ┃\n┡━━━━━━━━━━━━━━┩\n│ string       │\n├──────────────┤\n│ AAA          │\n│ A            │\n│ AA           │\n└──────────────┘\n\n\n\nuserinfo\nexpr.types.strings.StringValue.userinfo(self)\nParse a URL and extract user info.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; url = ibis.literal(\"https://user:pass@example.com:80/docs/books\")\n&gt;&gt;&gt; result = url.userinfo()  # user:pass\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nExtracted string value"
  },
  {
    "objectID": "reference/config.Repr.html",
    "href": "reference/config.Repr.html",
    "title": "config.Repr",
    "section": "",
    "text": "config.Repr()\nExpression printing options.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ndepth\nint\nThe maximum number of expression nodes to print when repring.\n\n\ntable_columns\nint\nThe number of columns to show in leaf table expressions.\n\n\nquery_text_length\nint\nThe maximum number of characters to show in the query field repr of SQLQueryResult operations.\n\n\nshow_types\nbool\nShow the inferred type of value expressions in the repr.\n\n\ninteractive\nbool\nOptions controlling the interactive repr."
  },
  {
    "objectID": "reference/config.Repr.html#attributes",
    "href": "reference/config.Repr.html#attributes",
    "title": "config.Repr",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ndepth\nint\nThe maximum number of expression nodes to print when repring.\n\n\ntable_columns\nint\nThe number of columns to show in leaf table expressions.\n\n\nquery_text_length\nint\nThe maximum number of characters to show in the query field repr of SQLQueryResult operations.\n\n\nshow_types\nbool\nShow the inferred type of value expressions in the repr.\n\n\ninteractive\nbool\nOptions controlling the interactive repr."
  },
  {
    "objectID": "reference/config.ContextAdjustment.html",
    "href": "reference/config.ContextAdjustment.html",
    "title": "config.ContextAdjustment",
    "section": "",
    "text": "config.ContextAdjustment()\nOptions related to time context adjustment.\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ntime_col\nstr\nName of the timestamp column for execution with a timecontext. See ibis/expr/timecontext.py for details."
  },
  {
    "objectID": "reference/config.ContextAdjustment.html#attributes",
    "href": "reference/config.ContextAdjustment.html#attributes",
    "title": "config.ContextAdjustment",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ntime_col\nstr\nName of the timestamp column for execution with a timecontext. See ibis/expr/timecontext.py for details."
  },
  {
    "objectID": "reference/expression-numeric.html",
    "href": "reference/expression-numeric.html",
    "title": "Numeric and Boolean Expressions",
    "section": "",
    "text": "These APIs are available on numeric and boolean expressions."
  },
  {
    "objectID": "reference/expression-numeric.html#methods",
    "href": "reference/expression-numeric.html#methods",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nabs\nReturn the absolute value of self.\n\n\nacos\nCompute the arc cosine of self.\n\n\nasin\nCompute the arc sine of self.\n\n\natan\nCompute the arc tangent of self.\n\n\natan2\nCompute the two-argument version of arc tangent.\n\n\nceil\nReturn the ceiling of self.\n\n\nclip\nTrim values outside of lower and upper bounds.\n\n\ncos\nCompute the cosine of self.\n\n\ncot\nCompute the cotangent of self.\n\n\ndegrees\nCompute the degrees of self radians.\n\n\nexp\nCompute \\(e^\\texttt{self}\\).\n\n\nfloor\nReturn the floor of an expression.\n\n\nln\nCompute \\(\\ln\\left(\\texttt{self}\\right)\\).\n\n\nlog\nCompute \\(\\log_{\\texttt{base}}\\left(\\texttt{self}\\right)\\).\n\n\nlog10\nCompute \\(\\log_{10}\\left(\\texttt{self}\\right)\\).\n\n\nlog2\nCompute \\(\\log_{2}\\left(\\texttt{self}\\right)\\).\n\n\nnegate\nNegate a numeric expression.\n\n\nnullifzero\nReturn NULL if an expression is zero.\n\n\npoint\nReturn a point constructed from the coordinate values.\n\n\nradians\nCompute radians from self degrees.\n\n\nround\nRound values to an indicated number of decimal places.\n\n\nsign\nReturn the sign of the input.\n\n\nsin\nCompute the sine of self.\n\n\nsqrt\nCompute the square root of self.\n\n\ntan\nCompute the tangent of self.\n\n\nzeroifnull\nReturn zero if an expression is NULL.\n\n\n\n\nabs\nexpr.types.numeric.NumericValue.abs(self)\nReturn the absolute value of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n&gt;&gt;&gt; t.values.abs()\n┏━━━━━━━━━━━━━┓\n┃ Abs(values) ┃\n┡━━━━━━━━━━━━━┩\n│ int64       │\n├─────────────┤\n│           1 │\n│           2 │\n│           3 │\n│           4 │\n└─────────────┘\n\n\n\nacos\nexpr.types.numeric.NumericValue.acos(self)\nCompute the arc cosine of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.acos()\n┏━━━━━━━━━━━━━━┓\n┃ Acos(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│     3.141593 │\n│     1.570796 │\n│     0.000000 │\n└──────────────┘\n\n\n\nasin\nexpr.types.numeric.NumericValue.asin(self)\nCompute the arc sine of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.asin()\n┏━━━━━━━━━━━━━━┓\n┃ Asin(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│    -1.570796 │\n│     0.000000 │\n│     1.570796 │\n└──────────────┘\n\n\n\natan\nexpr.types.numeric.NumericValue.atan(self)\nCompute the arc tangent of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.atan()\n┏━━━━━━━━━━━━━━┓\n┃ Atan(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│    -0.785398 │\n│     0.000000 │\n│     0.785398 │\n└──────────────┘\n\n\n\natan2\nexpr.types.numeric.NumericValue.atan2(self, other)\nCompute the two-argument version of arc tangent.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.atan2(0)\n┏━━━━━━━━━━━━━━━━━━┓\n┃ Atan2(values, 0) ┃\n┡━━━━━━━━━━━━━━━━━━┩\n│ float64          │\n├──────────────────┤\n│        -1.570796 │\n│         0.000000 │\n│         1.570796 │\n└──────────────────┘\n\n\n\nceil\nexpr.types.numeric.NumericValue.ceil(self)\nReturn the ceiling of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n&gt;&gt;&gt; t.values.ceil()\n┏━━━━━━━━━━━━━━┓\n┃ Ceil(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ int64        │\n├──────────────┤\n│            1 │\n│            2 │\n│            2 │\n│            3 │\n│            4 │\n└──────────────┘\n\n\n\nclip\nexpr.types.numeric.NumericValue.clip(self, lower=None, upper=None)\nTrim values outside of lower and upper bounds.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlower\nibis.expr.types.numeric.NumericValue | None\nLower bound\nNone\n\n\nupper\nibis.expr.types.numeric.NumericValue | None\nUpper bound\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericValue\nClipped input\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": range(8)})\n&gt;&gt;&gt; t.values.clip(lower=3, upper=6)\n┏━━━━━━━━━━━━━━━━━━━━┓\n┃ Clip(values, 3, 6) ┃\n┡━━━━━━━━━━━━━━━━━━━━┩\n│ int64              │\n├────────────────────┤\n│                  3 │\n│                  3 │\n│                  3 │\n│                  3 │\n│                  4 │\n│                  5 │\n│                  6 │\n│                  6 │\n└────────────────────┘\n\n\n\ncos\nexpr.types.numeric.NumericValue.cos(self)\nCompute the cosine of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.cos()\n┏━━━━━━━━━━━━━┓\n┃ Cos(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│    0.540302 │\n│    1.000000 │\n│    0.540302 │\n└─────────────┘\n\n\n\ncot\nexpr.types.numeric.NumericValue.cot(self)\nCompute the cotangent of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.cot()\n┏━━━━━━━━━━━━━┓\n┃ Cot(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -0.642093 │\n│         inf │\n│    0.642093 │\n└─────────────┘\n\n\n\ndegrees\nexpr.types.numeric.NumericValue.degrees(self)\nCompute the degrees of self radians.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from math import pi\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [0, pi / 2, pi, 3 * pi / 2, 2 * pi]})\n&gt;&gt;&gt; t.values.degrees()\n┏━━━━━━━━━━━━━━━━━┓\n┃ Degrees(values) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│             0.0 │\n│            90.0 │\n│           180.0 │\n│           270.0 │\n│           360.0 │\n└─────────────────┘\n\n\n\nexp\nexpr.types.numeric.NumericValue.exp(self)\nCompute \\(e^\\texttt{self}\\).\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericValue\n\\(e^\\texttt{self}\\)\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": range(4)})\n&gt;&gt;&gt; t.values.exp()\n┏━━━━━━━━━━━━━┓\n┃ Exp(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│    1.000000 │\n│    2.718282 │\n│    7.389056 │\n│   20.085537 │\n└─────────────┘\n\n\n\nfloor\nexpr.types.numeric.NumericValue.floor(self)\nReturn the floor of an expression.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 1.1, 2, 2.1, 3.3]})\n&gt;&gt;&gt; t.values.floor()\n┏━━━━━━━━━━━━━━━┓\n┃ Floor(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ int64         │\n├───────────────┤\n│             1 │\n│             1 │\n│             2 │\n│             2 │\n│             3 │\n└───────────────┘\n\n\n\nln\nexpr.types.numeric.NumericValue.ln(self)\nCompute \\(\\ln\\left(\\texttt{self}\\right)\\).\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 2.718281828, 3]})\n&gt;&gt;&gt; t.values.ln()\n┏━━━━━━━━━━━━┓\n┃ Ln(values) ┃\n┡━━━━━━━━━━━━┩\n│ float64    │\n├────────────┤\n│   0.000000 │\n│   1.000000 │\n│   1.098612 │\n└────────────┘\n\n\n\nlog\nexpr.types.numeric.NumericValue.log(self, base=None)\nCompute \\(\\log_{\\texttt{base}}\\left(\\texttt{self}\\right)\\).\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbase\nibis.expr.types.numeric.NumericValue | None\nThe base of the logarithm. If None, base e is used.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericValue\nLogarithm of arg with base base\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; from math import e\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [e, e**2, e**3]})\n&gt;&gt;&gt; t.values.log()\n┏━━━━━━━━━━━━━┓\n┃ Log(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│         1.0 │\n│         2.0 │\n│         3.0 │\n└─────────────┘\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [10, 100, 1000]})\n&gt;&gt;&gt; t.values.log(base=10)\n┏━━━━━━━━━━━━━━━━━┓\n┃ Log(values, 10) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│             1.0 │\n│             2.0 │\n│             3.0 │\n└─────────────────┘\n\n\n\nlog10\nexpr.types.numeric.NumericValue.log10(self)\nCompute \\(\\log_{10}\\left(\\texttt{self}\\right)\\).\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 10, 100]})\n&gt;&gt;&gt; t.values.log10()\n┏━━━━━━━━━━━━━━━┓\n┃ Log10(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ float64       │\n├───────────────┤\n│           0.0 │\n│           1.0 │\n│           2.0 │\n└───────────────┘\n\n\n\nlog2\nexpr.types.numeric.NumericValue.log2(self)\nCompute \\(\\log_{2}\\left(\\texttt{self}\\right)\\).\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 2, 4, 8]})\n&gt;&gt;&gt; t.values.log2()\n┏━━━━━━━━━━━━━━┓\n┃ Log2(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│          0.0 │\n│          1.0 │\n│          2.0 │\n│          3.0 │\n└──────────────┘\n\n\n\nnegate\nexpr.types.numeric.NumericValue.negate(self)\nNegate a numeric expression.\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericValue\nA numeric value expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.negate()\n┏━━━━━━━━━━━━━━━━┓\n┃ Negate(values) ┃\n┡━━━━━━━━━━━━━━━━┩\n│ int64          │\n├────────────────┤\n│              1 │\n│              0 │\n│             -1 │\n└────────────────┘\n\n\n\nnullifzero\nexpr.types.numeric.NumericValue.nullifzero(self)\nReturn NULL if an expression is zero.\n\n\npoint\nexpr.types.numeric.NumericValue.point(self, right)\nReturn a point constructed from the coordinate values.\nConstant coordinates result in construction of a POINT literal or column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nint | float | ibis.expr.types.numeric.NumericValue\nY coordinate\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nPointValue\nPoints\n\n\n\n\n\n\nradians\nexpr.types.numeric.NumericValue.radians(self)\nCompute radians from self degrees.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [0, 90, 180, 270, 360]})\n&gt;&gt;&gt; t.values.radians()\n┏━━━━━━━━━━━━━━━━━┓\n┃ Radians(values) ┃\n┡━━━━━━━━━━━━━━━━━┩\n│ float64         │\n├─────────────────┤\n│        0.000000 │\n│        1.570796 │\n│        3.141593 │\n│        4.712389 │\n│        6.283185 │\n└─────────────────┘\n\n\n\nround\nexpr.types.numeric.NumericValue.round(self, digits=None)\nRound values to an indicated number of decimal places.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndigits\nint | ibis.expr.types.numeric.IntegerValue | None\nThe number of digits to round to. Here’s how the digits parameter affects the expression output type: | digits | self.type() | Output | | :———–: | :———–: | :——-: | | None or 0 | decimal | decimal | | Nonzero | decimal | decimal | | None or 0 | Floating | int64 | | Nonzero | Floating | float64 |\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericValue\nThe rounded expression\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1.22, 1.64, 2.15, 2.54]})\n&gt;&gt;&gt; t\n┏━━━━━━━━━┓\n┃ values  ┃\n┡━━━━━━━━━┩\n│ float64 │\n├─────────┤\n│    1.22 │\n│    1.64 │\n│    2.15 │\n│    2.54 │\n└─────────┘\n&gt;&gt;&gt; t.values.round()\n┏━━━━━━━━━━━━━━━┓\n┃ Round(values) ┃\n┡━━━━━━━━━━━━━━━┩\n│ int64         │\n├───────────────┤\n│             1 │\n│             2 │\n│             2 │\n│             3 │\n└───────────────┘\n&gt;&gt;&gt; t.values.round(digits=1)\n┏━━━━━━━━━━━━━━━━━━┓\n┃ Round(values, 1) ┃\n┡━━━━━━━━━━━━━━━━━━┩\n│ float64          │\n├──────────────────┤\n│              1.2 │\n│              1.6 │\n│              2.2 │\n│              2.5 │\n└──────────────────┘\n\n\n\nsign\nexpr.types.numeric.NumericValue.sign(self)\nReturn the sign of the input.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 2, -3, 4]})\n&gt;&gt;&gt; t.values.sign()\n┏━━━━━━━━━━━━━━┓\n┃ Sign(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ int64        │\n├──────────────┤\n│           -1 │\n│            1 │\n│           -1 │\n│            1 │\n└──────────────┘\n\n\n\nsin\nexpr.types.numeric.NumericValue.sin(self)\nCompute the sine of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.sin()\n┏━━━━━━━━━━━━━┓\n┃ Sin(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -0.841471 │\n│    0.000000 │\n│    0.841471 │\n└─────────────┘\n\n\n\nsqrt\nexpr.types.numeric.NumericValue.sqrt(self)\nCompute the square root of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [1, 4, 9, 16]})\n&gt;&gt;&gt; t.values.sqrt()\n┏━━━━━━━━━━━━━━┓\n┃ Sqrt(values) ┃\n┡━━━━━━━━━━━━━━┩\n│ float64      │\n├──────────────┤\n│          1.0 │\n│          2.0 │\n│          3.0 │\n│          4.0 │\n└──────────────┘\n\n\n\ntan\nexpr.types.numeric.NumericValue.tan(self)\nCompute the tangent of self.\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"values\": [-1, 0, 1]})\n&gt;&gt;&gt; t.values.tan()\n┏━━━━━━━━━━━━━┓\n┃ Tan(values) ┃\n┡━━━━━━━━━━━━━┩\n│ float64     │\n├─────────────┤\n│   -1.557408 │\n│    0.000000 │\n│    1.557408 │\n└─────────────┘\n\n\n\nzeroifnull\nexpr.types.numeric.NumericValue.zeroifnull(self)\nReturn zero if an expression is NULL."
  },
  {
    "objectID": "reference/expression-numeric.html#methods-1",
    "href": "reference/expression-numeric.html#methods-1",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nbucket\nCompute a discrete binning of a numeric array.\n\n\ncorr\nReturn the correlation of two numeric columns.\n\n\ncov\nReturn the covariance of two numeric columns.\n\n\ncummean\nReturn the cumulative mean of the input.\n\n\ncumsum\nReturn the cumulative sum of the input.\n\n\nhistogram\nCompute a histogram with fixed width bins.\n\n\nmean\nReturn the mean of a numeric column.\n\n\nmedian\nReturn the median of the column.\n\n\nquantile\nReturn value at the given quantile.\n\n\nstd\nReturn the standard deviation of a numeric column.\n\n\nsum\nReturn the sum of a numeric column.\n\n\nvar\nReturn the variance of a numeric column.\n\n\n\n\nbucket\nexpr.types.numeric.NumericColumn.bucket(self, buckets, closed='left', close_extreme=True, include_under=False, include_over=False)\nCompute a discrete binning of a numeric array.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nbuckets\ntyping.Sequence[int]\nList of buckets\nrequired\n\n\nclosed\ntyping.Literal[‘left’, ‘right’]\nWhich side of each interval is closed. For example: python buckets = [0, 100, 200] closed = \"left\"  # 100 falls in 2nd bucket closed = \"right\"  # 100 falls in 1st bucket\n'left'\n\n\nclose_extreme\nbool\nWhether the extreme values fall in the last bucket\nTrue\n\n\ninclude_over\nbool\nInclude values greater than the last bucket in the last bucket\nFalse\n\n\ninclude_under\nbool\nInclude values less than the first bucket in the first bucket\nFalse\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerColumn\nA categorical column expression\n\n\n\n\n\n\ncorr\nexpr.types.numeric.NumericColumn.corr(self, right, where=None, how='sample')\nReturn the correlation of two numeric columns.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nNumericColumn\nNumeric column\nrequired\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\nhow\ntyping.Literal[‘sample’, ‘pop’]\nPopulation or sample correlation\n'sample'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nThe correlation of left and right\n\n\n\n\n\n\ncov\nexpr.types.numeric.NumericColumn.cov(self, right, where=None, how='sample')\nReturn the covariance of two numeric columns.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nright\nNumericColumn\nNumeric column\nrequired\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\nhow\ntyping.Literal[‘sample’, ‘pop’]\nPopulation or sample covariance\n'sample'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nThe covariance of self and right\n\n\n\n\n\n\ncummean\nexpr.types.numeric.NumericColumn.cummean(self)\nReturn the cumulative mean of the input.\n\n\ncumsum\nexpr.types.numeric.NumericColumn.cumsum(self)\nReturn the cumulative sum of the input.\n\n\nhistogram\nexpr.types.numeric.NumericColumn.histogram(self, nbins=None, binwidth=None, base=None, eps=1e-13)\nCompute a histogram with fixed width bins.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nnbins\nint | None\nIf supplied, will be used to compute the binwidth\nNone\n\n\nbinwidth\nfloat | None\nIf not supplied, computed from the data (actual max and min values)\nNone\n\n\nbase\nfloat | None\nThe value of the first histogram bin. Defaults to the minimum value of column.\nNone\n\n\neps\nfloat\nAllowed floating point epsilon for histogram base\n1e-13\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nColumn\nBucketed column\n\n\n\n\n\n\nmean\nexpr.types.numeric.NumericColumn.mean(self, where=None)\nReturn the mean of a numeric column.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nThe mean of the input expression\n\n\n\n\n\n\nmedian\nexpr.types.numeric.NumericColumn.median(self, where=None)\nReturn the median of the column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nOptional boolean expression. If given, only the values where where evaluates to true will be considered for the median.\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nMedian of the column\n\n\n\n\n\n\nquantile\nexpr.types.numeric.NumericColumn.quantile(self, quantile, interpolation=None, where=None)\nReturn value at the given quantile.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquantile\ntyping.Sequence[ibis.expr.types.numeric.NumericValue | float]\n0 &lt;= quantile &lt;= 1, the quantile(s) to compute\nrequired\n\n\ninterpolation\ntyping.Literal[‘linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’] | None\n!!! warning “This parameter is backend dependent and may have no effect” This parameter specifies the interpolation method to use, when the desired quantile lies between two data points i and j: * linear: i + (j - i) * fraction, where fraction is the fractional part of the index surrounded by i and j. * lower: i. * higher: j. * nearest: i or j whichever is nearest. * midpoint: (i + j) / 2.\nNone\n\n\nwhere\nibis.BooleanValue | None\nBoolean filter for input values\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nQuantile of the input\n\n\n\n\n\n\nstd\nexpr.types.numeric.NumericColumn.std(self, where=None, how='sample')\nReturn the standard deviation of a numeric column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\nhow\ntyping.Literal[‘sample’, ‘pop’]\nSample or population standard deviation\n'sample'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nStandard deviation of arg\n\n\n\n\n\n\nsum\nexpr.types.numeric.NumericColumn.sum(self, where=None)\nReturn the sum of a numeric column.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nThe sum of the input expression\n\n\n\n\n\n\nvar\nexpr.types.numeric.NumericColumn.var(self, where=None, how='sample')\nReturn the variance of a numeric column.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nwhere\nibis.BooleanValue | None\nFilter\nNone\n\n\nhow\ntyping.Literal[‘sample’, ‘pop’]\nSample or population variance\n'sample'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nNumericScalar\nStandard deviation of arg"
  },
  {
    "objectID": "reference/expression-numeric.html#methods-2",
    "href": "reference/expression-numeric.html#methods-2",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nconvert_base\nConvert an integer from one base to another.\n\n\nlabel\nLabel a set of integer values with strings.\n\n\nto_interval\nConvert an integer to an interval.\n\n\nto_timestamp\nConvert an integral UNIX timestamp to a timestamp expression.\n\n\n\n\nconvert_base\nexpr.types.numeric.IntegerValue.convert_base(self, from_base, to_base)\nConvert an integer from one base to another.\n\nParameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfrom_base\nIntegerValue\nNumeric base of expression\nrequired\n\n\nto_base\nIntegerValue\nNew base\nrequired\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntegerValue\nConverted expression\n\n\n\n\n\n\nlabel\nexpr.types.numeric.IntegerValue.label(self, labels, nulls=None)\nLabel a set of integer values with strings.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabels\ntyping.Iterable[str]\nAn iterable of string labels. Each integer value in self will be mapped to a value in labels.\nrequired\n\n\nnulls\nstr | None\nString label to use for NULL values\nNone\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nStringValue\nself labeled with labels\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"a\": [0, 1, 0, 2]})\n&gt;&gt;&gt; t.select(t.a, labeled=t.a.label([\"a\", \"b\", \"c\"]))\n┏━━━━━━━┳━━━━━━━━━┓\n┃ a     ┃ labeled ┃\n┡━━━━━━━╇━━━━━━━━━┩\n│ int64 │ string  │\n├───────┼─────────┤\n│     0 │ a       │\n│     1 │ b       │\n│     0 │ a       │\n│     2 │ c       │\n└───────┴─────────┘\n\n\n\nto_interval\nexpr.types.numeric.IntegerValue.to_interval(self, unit='s')\nConvert an integer to an interval.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nunit\ntyping.Literal[‘Y’, ‘M’, ‘W’, ‘D’, ‘h’, ‘m’, ‘s’, ‘ms’, ‘us’, ‘ns’]\nUnit for the resulting interval\n's'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nIntervalValue\nAn interval in units of unit\n\n\n\n\n\n\nto_timestamp\nexpr.types.numeric.IntegerValue.to_timestamp(self, unit='s')\nConvert an integral UNIX timestamp to a timestamp expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nunit\ntyping.Literal[‘s’, ‘ms’, ‘us’]\nThe resolution of arg\n's'\n\n\n\n\n\nReturns\n\n\n\nType\nDescription\n\n\n\n\nTimestampValue\nself converted to a timestamp"
  },
  {
    "objectID": "reference/expression-numeric.html#methods-3",
    "href": "reference/expression-numeric.html#methods-3",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nbit_and\nAggregate the column using the bitwise and operator.\n\n\nbit_or\nAggregate the column using the bitwise or operator.\n\n\nbit_xor\nAggregate the column using the bitwise exclusive or operator.\n\n\n\n\nbit_and\nexpr.types.numeric.IntegerColumn.bit_and(self, where=None)\nAggregate the column using the bitwise and operator.\n\n\nbit_or\nexpr.types.numeric.IntegerColumn.bit_or(self, where=None)\nAggregate the column using the bitwise or operator.\n\n\nbit_xor\nexpr.types.numeric.IntegerColumn.bit_xor(self, where=None)\nAggregate the column using the bitwise exclusive or operator."
  },
  {
    "objectID": "reference/expression-numeric.html#methods-4",
    "href": "reference/expression-numeric.html#methods-4",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nisinf\nReturn whether the value is infinity.\n\n\nisnan\nReturn whether the value is NaN.\n\n\n\n\nisinf\nexpr.types.numeric.FloatingValue.isinf(self)\nReturn whether the value is infinity.\n\n\nisnan\nexpr.types.numeric.FloatingValue.isnan(self)\nReturn whether the value is NaN."
  },
  {
    "objectID": "reference/expression-numeric.html#methods-5",
    "href": "reference/expression-numeric.html#methods-5",
    "title": "Numeric and Boolean Expressions",
    "section": "Methods",
    "text": "Methods\n\n\n\nName\nDescription\n\n\n\n\nifelse\nConstruct a ternary conditional expression.\n\n\n\n\nifelse\nexpr.types.logical.BooleanValue.ifelse(self, true_expr, false_expr)\nConstruct a ternary conditional expression.\n\nParameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntrue_expr\nibis.Value\nExpression to return if self evaluates to True\nrequired\n\n\nfalse_expr\nibis.Value\nExpression to return if self evaluates to False or NULL\nrequired\n\n\n\n\n\nReturns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nValue\nThe value of true_expr if arg is True else false_expr\n\n\n\n\n\nExamples\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; ibis.options.interactive = True\n&gt;&gt;&gt; t = ibis.memtable({\"is_person\": [True, False, True, None]})\n&gt;&gt;&gt; t.is_person.ifelse(\"yes\", \"no\")\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ Where(is_person, 'yes', 'no') ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ string                        │\n├───────────────────────────────┤\n│ yes                           │\n│ no                            │\n│ yes                           │\n│ no                            │\n└───────────────────────────────┘"
  },
  {
    "objectID": "backends/index.html",
    "href": "backends/index.html",
    "title": "Backends",
    "section": "",
    "text": "Backends\nA backend is where execution of Ibis table expressions occur after compiling into some intermediate representation. A backend is often a database and the intermediate representation often SQL, but several types of backends exist.\nSee the configuration guide to inspect or reconfigure the backend used by default. View the operation support matrix to see which operations are supported by each backend.\nEach backend has its own configuration options documented here."
  },
  {
    "objectID": "backends/dask.html",
    "href": "backends/dask.html",
    "title": "Dask",
    "section": "",
    "text": "Install ibis and dependencies for the Dask backend:\n\npipcondamamba\n\n\npip install 'ibis-framework[dask]'\n\n\nconda install -c conda-forge ibis-dask\n\n\nmamba install -c conda-forge ibis-dask\n\n\n\n\n\n\n\n\nCreate a client by passing in a dictionary of paths to ibis.dask.connect.\n\nSee [ibis.backends.dask.Backend.do_connect][ibis.backends.dask.None.do_connect] for connection parameter information. \n\n!!! info “ibis.dask.connect is a thin wrapper around [ibis.backends.dask.Backend.do_connect][ibis.backends.dask.None.do_connect].” \n\n\n\n\n\n\nbackends.dask.Backend.do_connect(self, dictionary=None)\nConstruct a Dask backend client from a dictionary of data sources.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ntyping.MutableMapping[str, dask.DataFrame] | None\nAn optional mapping from str table names to Dask DataFrames.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; data = {\n...     \"t\": dd.read_parquet(\"path/to/file.parquet\"),\n...     \"s\": dd.read_csv(\"path/to/file.csv\"),\n... }\n&gt;&gt;&gt; ibis.dask.connect(data)\n\n\n\n\n\n\n\n\n\nbackends.dask.Backend()"
  },
  {
    "objectID": "backends/dask.html#install",
    "href": "backends/dask.html#install",
    "title": "Dask",
    "section": "",
    "text": "Install ibis and dependencies for the Dask backend:\n\npipcondamamba\n\n\npip install 'ibis-framework[dask]'\n\n\nconda install -c conda-forge ibis-dask\n\n\nmamba install -c conda-forge ibis-dask"
  },
  {
    "objectID": "backends/dask.html#connect",
    "href": "backends/dask.html#connect",
    "title": "Dask",
    "section": "",
    "text": "Create a client by passing in a dictionary of paths to ibis.dask.connect.\n\nSee [ibis.backends.dask.Backend.do_connect][ibis.backends.dask.None.do_connect] for connection parameter information. \n\n!!! info “ibis.dask.connect is a thin wrapper around [ibis.backends.dask.Backend.do_connect][ibis.backends.dask.None.do_connect].” \n\n\n\n\n\n\nbackends.dask.Backend.do_connect(self, dictionary=None)\nConstruct a Dask backend client from a dictionary of data sources.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndictionary\ntyping.MutableMapping[str, dask.DataFrame] | None\nAn optional mapping from str table names to Dask DataFrames.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; import dask.dataframe as dd\n&gt;&gt;&gt; data = {\n...     \"t\": dd.read_parquet(\"path/to/file.parquet\"),\n...     \"s\": dd.read_csv(\"path/to/file.csv\"),\n... }\n&gt;&gt;&gt; ibis.dask.connect(data)"
  },
  {
    "objectID": "backends/dask.html#ibis.backends.dask.Backend",
    "href": "backends/dask.html#ibis.backends.dask.Backend",
    "title": "Dask",
    "section": "",
    "text": "backends.dask.Backend()"
  },
  {
    "objectID": "backends/impala.html",
    "href": "backends/impala.html",
    "title": "Impala",
    "section": "",
    "text": "One goal of Ibis is to provide an integrated Python API for an Impala cluster without requiring you to switch back and forth between Python code and the Impala shell.\n\n\nInstall ibis and dependencies for the Impala backend:\n\npipcondamamba\n\n\npip install 'ibis-framework[impala]'\n\n\nconda install -c conda-forge ibis-impala\n\n\nmamba install -c conda-forge ibis-impala\n\n\n\n\n\n\n\n\nCreate a client by passing in connection parameters to ibis.impala.connect.\n\nSee [ibis.backends.impala.Backend.do_connect][ibis.backends.impala.None.do_connect] for connection parameter information. \n\n!!! info “ibis.impala.connect is a thin wrapper around [ibis.backends.impala.Backend.do_connect][ibis.backends.impala.None.do_connect].” \n\n\n\n\n\n\nbackends.impala.Backend.do_connect(self, host='localhost', port=21050, database='default', timeout=45, use_ssl=False, ca_cert=None, user=None, password=None, auth_mechanism='NOSASL', kerberos_service_name='impala', pool_size=8, hdfs_client=None)\nCreate an Impala Backend for use with Ibis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhost\nstr\nHost name of the impalad or HiveServer2 in Hive\n'localhost'\n\n\nport\nint\nImpala’s HiveServer2 port\n21050\n\n\ndatabase\nstr\nDefault database when obtaining new cursors\n'default'\n\n\ntimeout\nint\nConnection timeout in seconds when communicating with HiveServer2\n45\n\n\nuse_ssl\nbool\nUse SSL when connecting to HiveServer2\nFalse\n\n\nca_cert\nstr | pathlib.Path | None\nLocal path to 3rd party CA certificate or copy of server certificate for self-signed certificates. If SSL is enabled, but this argument is None, then certificate validation is skipped.\nNone\n\n\nuser\nstr | None\nLDAP user to authenticate\nNone\n\n\npassword\nstr | None\nLDAP password to authenticate\nNone\n\n\nauth_mechanism\ntyping.Literal[‘NOSASL’, ‘PLAIN’, ‘GSSAPI’, ‘LDAP’]\n| Value | Meaning | | :——–: | :—————————– | | 'NOSASL' | insecure Impala connections | | 'PLAIN' | insecure Hive clusters | | 'LDAP' | LDAP authenticated connections | | 'GSSAPI' | Kerberos-secured clusters |\n'NOSASL'\n\n\nkerberos_service_name\nstr\nSpecify a particular impalad service principal.\n'impala'\n\n\npool_size\nint\nSize of the connection pool. Typically this is not necessary to configure.\n8\n\n\nhdfs_client\nfsspec.spec.AbstractFileSystem | None\nAn existing HDFS client.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; hdfs_host = os.environ.get('IBIS_TEST_NN_HOST', 'localhost')\n&gt;&gt;&gt; hdfs_port = int(os.environ.get('IBIS_TEST_NN_PORT', 50070))\n&gt;&gt;&gt; impala_host = os.environ.get('IBIS_TEST_IMPALA_HOST', 'localhost')\n&gt;&gt;&gt; impala_port = int(os.environ.get('IBIS_TEST_IMPALA_PORT', 21050))\n&gt;&gt;&gt; hdfs = ibis.impala.hdfs_connect(host=hdfs_host, port=hdfs_port)\n&gt;&gt;&gt; client = ibis.impala.connect(\n...     host=impala_host,\n...     port=impala_port,\n...     hdfs_client=hdfs,\n... )\n&gt;&gt;&gt; client\n&lt;ibis.backends.impala.Backend object at 0x...&gt;\nBoth method calls can take auth_mechanism='GSSAPI' or auth_mechanism='LDAP' to connect to Kerberos clusters. Depending on your cluster setup, this may also include SSL. See the API reference for more, along with the Impala shell reference, as the connection semantics are identical.\nThese methods are available on the Impala client object after connecting to your HDFS cluster (ibis.impala.hdfs_connect) and connecting to Impala with ibis.impala.connect. See backends.impala for a tutorial on using this backend.\n\n\n\n\n\n\n\nbackends.impala.Backend()\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_database\nCreate a new Impala database.\n\n\ndrop_database\nDrop an Impala database.\n\n\nlist_databases\n\n\n\n\n\n\nbackends.impala.Backend.create_database(self, name, path=None, force=False)\nCreate a new Impala database.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\n\nDatabase name\nrequired\n\n\npath\n\nHDFS path where to store the database data; otherwise uses Impala default\nNone\n\n\nforce\n\nForcibly create the database\nFalse\n\n\n\n\n\n\n\nbackends.impala.Backend.drop_database(self, name, force=False)\nDrop an Impala database.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\n\nDatabase name\nrequired\n\n\nforce\n\nIf False and there are any tables in this database, raises an IntegrityError\nFalse\n\n\n\n\n\n\n\nbackends.impala.Backend.list_databases(self, like=None)\n\n\n\n\n\n\nThe Backend object itself has many helper utility methods. You’ll find the most methods on ImpalaTable.\n\n\nbackends.impala.Backend()\n\n\n\n\n\nName\nDescription\n\n\n\n\ntable\n\n\n\nsql\nConvert a SQL query to an Ibis table expression.\n\n\nraw_sql\nExecute a query string.\n\n\nlist_tables\n\n\n\ndrop_table\nDrop an Impala table.\n\n\ncreate_table\nCreate a new table in Impala using an Ibis table expression.\n\n\ninsert\nInsert data into an existing table.\n\n\ninvalidate_metadata\nIssue an INVALIDATE METADATA command.\n\n\ntruncate_table\nDelete all rows from an existing table.\n\n\nget_schema\nReturn a Schema object for the indicated table and database.\n\n\ncache_table\nCaches a table in cluster memory in the given pool.\n\n\nget_options\nReturn current query options for the Impala session.\n\n\nset_options\n\n\n\nset_compression_codec\n\n\n\n\n\n\nbackends.impala.Backend.table(self, name, database=None, **kwargs)\n\n\n\nbackends.impala.Backend.sql(self, query, schema=None, dialect=None)\nConvert a SQL query to an Ibis table expression.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL string\nrequired\n\n\nschema\nibis.Schema | None\nThe expected schema for this query. If not provided, will be inferred automatically if possible.\nNone\n\n\ndialect\nstr | None\nOptional string indicating the dialect of query. The default value of None will use the backend’s native dialect.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\n\n\nbackends.impala.Backend.raw_sql(self, query)\nExecute a query string.\n!!! warning “The returned cursor object must be manually released if results are returned.”\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nDDL or DML statement\nrequired\n\n\n\n\n\n\n\nbackends.impala.Backend.list_tables(self, like=None, database=None)\n\n\n\nbackends.impala.Backend.drop_table(self, name, *, database=None, force=False)\nDrop an Impala table.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\nforce\nbool\nDatabase may throw exception if table does not exist\nFalse\n\n\n\n\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; db = 'operations'\n&gt;&gt;&gt; con.drop_table(table, database=db, force=True)\n\n\n\n\nbackends.impala.Backend.create_table(self, name, obj=None, *, schema=None, database=None, temp=None, overwrite=False, external=False, format='parquet', location=None, partition=None, like_parquet=None)\nCreate a new table in Impala using an Ibis table expression.\nThis is currently designed for tables whose data is stored in HDFS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\nobj\nibis.Table | None\nIf passed, creates table from select statement results\nNone\n\n\nschema\n\nMutually exclusive with obj, creates an empty table with a particular schema\nNone\n\n\ndatabase\n\nDatabase name\nNone\n\n\ntemp\nbool | None\nWhether a table is temporary\nNone\n\n\noverwrite\nbool\nDo not create table if table with indicated name already exists\nFalse\n\n\nexternal\nbool\nCreate an external table; Impala will not delete the underlying data when the table is dropped\nFalse\n\n\nformat\n\nFile format\n'parquet'\n\n\nlocation\n\nSpecify the directory location where Impala reads and writes files for the table\nNone\n\n\npartition\n\nMust pass a schema to use this. Cannot partition from an expression.\nNone\n\n\nlike_parquet\n\nCan specify instead of a schema\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.insert(self, table_name, obj=None, database=None, overwrite=False, partition=None, values=None, validate=True)\nInsert data into an existing table.\nSee [ImpalaTable.insert][ibis.backends.impala.client.ImpalaTable.insert] for parameters.\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; con.insert(table, table_expr)\nCompletely overwrite contents\n&gt;&gt;&gt; con.insert(table, table_expr, overwrite=True)\n\n\n\n\nbackends.impala.Backend.invalidate_metadata(self, name=None, database=None)\nIssue an INVALIDATE METADATA command.\nOptionally this applies to a specific table. See Impala documentation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr | None\nTable name. Can be fully qualified (with database)\nNone\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.truncate_table(self, name, database=None)\nDelete all rows from an existing table.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.get_schema(self, table_name, database=None)\nReturn a Schema object for the indicated table and database.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable_name\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSchema\nIbis schema\n\n\n\n\n\n\n\nbackends.impala.Backend.cache_table(self, table_name, *, database=None, pool='default')\nCaches a table in cluster memory in the given pool.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable_name\n\nTable name\nrequired\n\n\ndatabase\n\nDatabase name\nNone\n\n\npool\n\nThe name of the pool in which to cache the table\n'default'\n\n\n\n\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; db = 'operations'\n&gt;&gt;&gt; pool = 'op_4GB_pool'\n&gt;&gt;&gt; con.cache_table('my_table', database=db, pool=pool)\n\n\n\n\nbackends.impala.Backend.get_options(self)\nReturn current query options for the Impala session.\n\n\n\nbackends.impala.Backend.set_options(self, options)\n\n\n\nbackends.impala.Backend.set_compression_codec(self, codec)\nThe best way to interact with a single table is through the ImpalaTable object you get back from Backend.table.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - add_partition\n        - alter\n        - alter_partition\n        - column_stats\n        - compute_stats\n        - describe_formatted\n        - drop\n        - drop_partition\n        - files\n        - insert\n        - invalidate_metadata\n        - is_partitioned\n        - load_data\n        - metadata\n        - partition_schema\n        - partitions\n        - refresh\n        - rename\n        - schema\n        - stats\n\n&lt;!-- prettier-ignore-end --&gt;\n\n\n\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - drop_table_or_view\n        - create_view\n\n&lt;!-- prettier-ignore-end --&gt;\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - delimited_file\n        - parquet_file\n        - avro_file\n\n&lt;!-- prettier-ignore-end --&gt;\n\n\n\nIbis delegates all HDFS interaction to the fsspec library.\n\n\n\nTo use Ibis with Impala, you first must connect to a cluster using the ibis.impala.connect function, optionally supplying an HDFS connection:\nimport ibis\n\nhdfs = ibis.impala.hdfs_connect(host=webhdfs_host, port=webhdfs_port)\nclient = ibis.impala.connect(host=impala_host, port=impala_port, hdfs_client=hdfs)\nAll examples here use the following block of code to connect to impala using docker:\nimport ibis\n\nhdfs = ibis.impala.hdfs_connect(host=\"localhost\", port=50070)\nclient = ibis.impala.connect(host=host, hdfs_client=hdfs)\nYou can accomplish many tasks directly through the client object, but we additionally provide APIs to streamline tasks involving a single Impala table or database.\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.base.sql.BaseSQLBackend.table\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\nThe client’s table method allows you to create an Ibis table expression referencing a physical Impala table:\ntable = client.table('functional_alltypes', database='ibis_testing')\nImpalaTable is a Python subclass of the more general Ibis Table that has additional Impala-specific methods. So you can use it interchangeably with any code expecting a Table.\nLike all table expressions in Ibis, ImpalaTable has a schema method you can use to examine its schema:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - schema\n\n&lt;!-- prettier-ignore-end --&gt;\nWhile the client has a drop_table method you can use to drop tables, the table itself has a method drop that you can use:\ntable.drop()\n\n\n\nIbis expressions have execution methods like to_pandas that compile and run the expressions on Impala or whichever backend is being referenced.\nFor example:\n&gt;&gt;&gt; fa = db.functional_alltypes\n&gt;&gt;&gt; expr = fa.double_col.sum()\n&gt;&gt;&gt; expr.to_pandas()\n331785.00000000006\nFor longer-running queries, Ibis will attempt to cancel the query in progress if an interrupt is received.\n\n\n\nThere are several ways to create new Impala tables:\n\nFrom an Ibis table expression\nEmpty, from a declared schema\nEmpty and partitioned\n\nIn all cases, you should use the create_table method either on the top-level client connection or a database object.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend.create_table\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\n\n\nIf you pass an Ibis expression to create_table, Ibis issues a CREATE TABLE ... AS SELECT (CTAS) statement:\n&gt;&gt;&gt; table = db.table('functional_alltypes')\n&gt;&gt;&gt; expr = table.group_by('string_col').size()\n&gt;&gt;&gt; db.create_table('string_freqs', expr, format='parquet')\n\n&gt;&gt;&gt; freqs = db.table('string_freqs')\n&gt;&gt;&gt; freqs.to_pandas()\n  string_col  count\n0          9    730\n1          3    730\n2          6    730\n3          4    730\n4          1    730\n5          8    730\n6          2    730\n7          7    730\n8          5    730\n9          0    730\n\n&gt;&gt;&gt; files = freqs.files()\n&gt;&gt;&gt; files\n                                                Path  Size Partition\n0  hdfs://impala:8020/user/hive/warehouse/ibis_te...  584B\n\n&gt;&gt;&gt; freqs.drop()\nYou can also choose to create an empty table and use insert (see below).\n\n\n\nTo create an empty table, you must declare an Ibis schema that will be translated to the appropriate Impala schema and data types.\nAs Ibis types are simplified compared with Impala types, this may expand in the future to include a more fine-grained schema declaration.\nYou can use the create_table method either on a database or client object.\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema)\nBy default, this stores the data files in the database default location. You can force a particular path with the location option.\nfrom getpass import getuser\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\nlocation = '/home/{}/new-table-data'.format(getuser())\ndb.create_table(name, schema=schema, location=location)\nIf the schema matches a known table schema, you can always use the schema method to get a schema object:\n&gt;&gt;&gt; t = db.table('functional_alltypes')\n&gt;&gt;&gt; t.schema()\nibis.Schema {\n  id               int32\n  bool_col         boolean\n  tinyint_col      int8\n  smallint_col     int16\n  int_col          int32\n  bigint_col       int64\n  float_col        float32\n  double_col       float64\n  date_string_col  string\n  string_col       string\n  timestamp_col    timestamp\n  year             int32\n  month            int32\n}\n\n\n\nTo create an empty partitioned table, include a list of columns to be used as the partition keys.\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema, partition=['year', 'month'])\n\n\n\n\nIbis enables you to manage partitioned tables in various ways. Since each partition behaves as its own \"subtable\" sharing a common schema, each partition can have its own file format, directory path, serialization properties, and so forth.\nThere are a handful of table methods for adding and removing partitions and getting information about the partition schema and any existing partition data:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - add_partition\n        - drop_partition\n        - is_partitioned\n        - partition_schema\n        - partitions\n\n&lt;!-- prettier-ignore-end --&gt;\nTo address a specific partition in any method that is partition specific, you can either use a dict with the partition key names and values, or pass a list of the partition values:\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema, partition=['year', 'month'])\n\ntable = db.table(name)\n\ntable.add_partition({'year': 2007, 'month', 4})\ntable.add_partition([2007, 5])\ntable.add_partition([2007, 6])\n\ntable.drop_partition([2007, 6])\nWe’ll cover partition metadata management and data loading below.\n\n\n\nIf the schemas are compatible, you can insert into a table directly from an Ibis table expression:\n&gt;&gt;&gt; t = db.functional_alltypes\n&gt;&gt;&gt; db.create_table('insert_test', schema=t.schema())\n&gt;&gt;&gt; target = db.table('insert_test')\n\n&gt;&gt;&gt; target.insert(t[:3])\n&gt;&gt;&gt; target.insert(t[:3])\n&gt;&gt;&gt; target.insert(t[:3])\n\n&gt;&gt;&gt; target.to_pandas()\n     id  bool_col  tinyint_col  ...           timestamp_col  year  month\n0  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n1  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n2  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n3  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n4  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n5  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n6  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n7  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n8  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n\n[9 rows x 13 columns]\n\n&gt;&gt;&gt; target.drop()\nIf the table is partitioned, you must indicate the partition you are inserting into:\npart = {'year': 2007, 'month': 4}\ntable.insert(expr, partition=part)\n\n\n\nIbis has functions that wrap many of the DDL commands for Impala table metadata.\n\n\nTo get a handy wrangled version of DESCRIBE FORMATTED use the metadata method.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable.metadata\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\n&gt;&gt;&gt; t = client.table('ibis_testing.functional_alltypes')\n&gt;&gt;&gt; meta = t.metadata()\n&gt;&gt;&gt; meta\n&lt;class 'ibis.backends.impala.metadata.TableMetadata'&gt;\n{'info': {'CreateTime': datetime.datetime(2021, 1, 14, 21, 23, 8),\n          'Database': 'ibis_testing',\n          'LastAccessTime': 'UNKNOWN',\n          'Location': 'hdfs://impala:8020/__ibis/ibis-testing-data/parquet/functional_alltypes',\n          'Owner': 'root',\n          'Protect Mode': 'None',\n          'Retention': 0,\n          'Table Parameters': {'COLUMN_STATS_ACCURATE': False,\n                               'EXTERNAL': True,\n                               'STATS_GENERATED_VIA_STATS_TASK': True,\n                               'numFiles': 3,\n                               'numRows': 7300,\n                               'rawDataSize': '-1',\n                               'totalSize': 106278,\n                               'transient_lastDdlTime': datetime.datetime(2021, 1, 14, 21, 23, 17)},\n          'Table Type': 'EXTERNAL_TABLE'},\n 'schema': [('id', 'int'),\n            ('bool_col', 'boolean'),\n            ('tinyint_col', 'tinyint'),\n            ('smallint_col', 'smallint'),\n            ('int_col', 'int'),\n            ('bigint_col', 'bigint'),\n            ('float_col', 'float'),\n            ('double_col', 'double'),\n            ('date_string_col', 'string'),\n            ('string_col', 'string'),\n            ('timestamp_col', 'timestamp'),\n            ('year', 'int'),\n            ('month', 'int')],\n 'storage info': {'Bucket Columns': '[]',\n                  'Compressed': False,\n                  'InputFormat': 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat',\n                  'Num Buckets': 0,\n                  'OutputFormat': 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat',\n                  'SerDe Library': 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe',\n                  'Sort Columns': '[]'}}\n\n&gt;&gt;&gt; meta.location\n'hdfs://impala:8020/__ibis/ibis-testing-data/parquet/functional_alltypes'\n\n&gt;&gt;&gt; meta.create_time\ndatetime.datetime(2021, 1, 14, 21, 23, 8)\nThe files function is also available to see all of the physical HDFS data files backing a table:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - files\n\n&lt;!-- prettier-ignore-end --&gt;\n&gt;&gt;&gt; ss = c.table('tpcds_parquet.store_sales')\n\n&gt;&gt;&gt; ss.files()[:5]\n                                                path      size  \\\n0  hdfs://localhost:20500/test-warehouse/tpcds.st...  160.61KB\n1  hdfs://localhost:20500/test-warehouse/tpcds.st...  123.88KB\n2  hdfs://localhost:20500/test-warehouse/tpcds.st...  139.28KB\n3  hdfs://localhost:20500/test-warehouse/tpcds.st...  139.60KB\n4  hdfs://localhost:20500/test-warehouse/tpcds.st...   62.84KB\n\n                 partition\n0  ss_sold_date_sk=2451803\n1  ss_sold_date_sk=2451819\n2  ss_sold_date_sk=2451772\n3  ss_sold_date_sk=2451789\n4  ss_sold_date_sk=2451741\n\n\n\nFor unpartitioned tables, you can use the alter method to change its location, file format, and other properties. For partitioned tables, to change partition-specific metadata use alter_partition.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - alter\n        - alter_partition\n\n&lt;!-- prettier-ignore-end --&gt;\nFor example, if you wanted to \"point\" an existing table at a directory of CSV files, you could run the following command:\nfrom getpass import getuser\n\ncsv_props = {\n    'serialization.format': ',',\n    'field.delim': ',',\n}\ndata_dir = '/home/{}/my-csv-files'.format(getuser())\n\ntable.alter(location=data_dir, format='text', serde_properties=csv_props)\nIf the table is partitioned, you can modify only the properties of a particular partition:\ntable.alter_partition(\n    {'year': 2007, 'month': 5},\n    location=data_dir,\n    format='text',\n    serde_properties=csv_props\n)\n\n\n\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - compute_stats\n\n&lt;!-- prettier-ignore-end --&gt;\nImpala-backed physical tables have a method compute_stats that computes table, column, and partition-level statistics to assist with query planning and optimization. It is standard practice to invoke this after creating a table or loading new data:\ntable.compute_stats()\nIf you are using a recent version of Impala, you can also access the COMPUTE INCREMENTAL STATS DDL command:\ntable.compute_stats(incremental=True)\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - column_stats\n        - stats\n\n&lt;!-- prettier-ignore-end --&gt;\nThe compute_stats and stats functions return the results of SHOW COLUMN STATS and SHOW TABLE STATS, respectively, and their output will depend, of course, on the last COMPUTE STATS call.\n&gt;&gt;&gt; ss = c.table('tpcds_parquet.store_sales')\n&gt;&gt;&gt; ss.compute_stats(incremental=True)\n&gt;&gt;&gt; stats = ss.stats()\n&gt;&gt;&gt; stats[:5]\n  ss_sold_date_sk  #Rows  #Files     Size Bytes Cached Cache Replication  \\\n0         2450829   1071       1  78.34KB   NOT CACHED        NOT CACHED\n1         2450846    839       1  61.83KB   NOT CACHED        NOT CACHED\n2         2450860    747       1  54.86KB   NOT CACHED        NOT CACHED\n3         2450874    922       1  66.74KB   NOT CACHED        NOT CACHED\n4         2450888    856       1  63.33KB   NOT CACHED        NOT CACHED\n\n    Format Incremental stats  \\\n0  PARQUET              true\n1  PARQUET              true\n2  PARQUET              true\n3  PARQUET              true\n4  PARQUET              true\n\n                                            Location\n0  hdfs://localhost:20500/test-warehouse/tpcds.st...\n1  hdfs://localhost:20500/test-warehouse/tpcds.st...\n2  hdfs://localhost:20500/test-warehouse/tpcds.st...\n3  hdfs://localhost:20500/test-warehouse/tpcds.st...\n4  hdfs://localhost:20500/test-warehouse/tpcds.st...\n\n&gt;&gt;&gt; cstats = ss.column_stats()\n&gt;&gt;&gt; cstats\n                   Column          Type  #Distinct Values  #Nulls  Max Size  Avg Size\n0         ss_sold_time_sk        BIGINT             13879      -1       NaN         8\n1              ss_item_sk        BIGINT             17925      -1       NaN         8\n2          ss_customer_sk        BIGINT             15207      -1       NaN         8\n3             ss_cdemo_sk        BIGINT             16968      -1       NaN         8\n4             ss_hdemo_sk        BIGINT              6220      -1       NaN         8\n5              ss_addr_sk        BIGINT             14077      -1       NaN         8\n6             ss_store_sk        BIGINT                 6      -1       NaN         8\n7             ss_promo_sk        BIGINT               298      -1       NaN         8\n8        ss_ticket_number           INT             15006      -1       NaN         4\n9             ss_quantity           INT                99      -1       NaN         4\n10      ss_wholesale_cost  DECIMAL(7,2)             10196      -1       NaN         4\n11          ss_list_price  DECIMAL(7,2)             19393      -1       NaN         4\n12         ss_sales_price  DECIMAL(7,2)             15594      -1       NaN         4\n13    ss_ext_discount_amt  DECIMAL(7,2)             29772      -1       NaN         4\n14     ss_ext_sales_price  DECIMAL(7,2)            102758      -1       NaN         4\n15  ss_ext_wholesale_cost  DECIMAL(7,2)            125448      -1       NaN         4\n16      ss_ext_list_price  DECIMAL(7,2)            141419      -1       NaN         4\n17             ss_ext_tax  DECIMAL(7,2)             33837      -1       NaN         4\n18          ss_coupon_amt  DECIMAL(7,2)             29772      -1       NaN         4\n19            ss_net_paid  DECIMAL(7,2)            109981      -1       NaN         4\n20    ss_net_paid_inc_tax  DECIMAL(7,2)            132286      -1       NaN         4\n21          ss_net_profit  DECIMAL(7,2)            122436      -1       NaN         4\n22        ss_sold_date_sk        BIGINT               120       0       NaN         8\n\n\n\nThese DDL commands are available as table-level and client-level methods:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - invalidate_metadata\n\n&lt;!-- prettier-ignore-end --&gt;\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - invalidate_metadata\n        - refresh\n\n&lt;!-- prettier-ignore-end --&gt;\nYou can invalidate the cached metadata for a single table or for all tables using invalidate_metadata, and similarly invoke REFRESH db_name.table_name using the refresh method.\nclient.invalidate_metadata()\n\ntable = db.table(table_name)\ntable.invalidate_metadata()\n\ntable.refresh()\nThese methods are often used in conjunction with the LOAD DATA commands and COMPUTE STATS. See the Impala documentation for full details.\n\n\n\n\nThe LOAD DATA DDL physically moves a single data file or a directory of files into the correct location for a table or table partition. It is especially useful for partitioned tables as you do not have to construct the directory path for a partition by hand, so simpler and less error-prone than manually moving files with low level HDFS commands. It also deals with file name conflicts so data is not lost in such cases.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - load_data\n\n&lt;!-- prettier-ignore-end --&gt;\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - load_data\n\n&lt;!-- prettier-ignore-end --&gt;\nTo use these methods, pass the path of a single file or a directory of files you want to load. Afterward, you may want to update the table statistics (see Impala documentation):\ntable.load_data(path)\ntable.refresh()\nLike the other methods with support for partitioned tables, you can load into a particular partition with the partition keyword argument:\npart = [2007, 5]\ntable.load_data(path, partition=part)\n\n\n\nIbis gives you access to Impala session-level variables that affect query execution:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - disable_codegen\n        - get_options\n        - set_options\n        - set_compression_codec\n\n&lt;!-- prettier-ignore-end --&gt;\nFor example:\n&gt;&gt;&gt; client.get_options()\n{'ABORT_ON_ERROR': '0',\n 'APPX_COUNT_DISTINCT': '0',\n 'BUFFER_POOL_LIMIT': '',\n 'COMPRESSION_CODEC': '',\n 'COMPUTE_STATS_MIN_SAMPLE_SIZE': '1073741824',\n 'DEFAULT_JOIN_DISTRIBUTION_MODE': '0',\n 'DEFAULT_SPILLABLE_BUFFER_SIZE': '2097152',\n 'DISABLE_CODEGEN': '0',\n 'DISABLE_CODEGEN_ROWS_THRESHOLD': '50000',\n 'DISABLE_ROW_RUNTIME_FILTERING': '0',\n 'DISABLE_STREAMING_PREAGGREGATIONS': '0',\n 'DISABLE_UNSAFE_SPILLS': '0',\n 'ENABLE_EXPR_REWRITES': '1',\n 'EXEC_SINGLE_NODE_ROWS_THRESHOLD': '100',\n 'EXEC_TIME_LIMIT_S': '0',\n 'EXPLAIN_LEVEL': '1',\n 'HBASE_CACHE_BLOCKS': '0',\n 'HBASE_CACHING': '0',\n 'IDLE_SESSION_TIMEOUT': '0',\n 'MAX_ERRORS': '100',\n 'MAX_NUM_RUNTIME_FILTERS': '10',\n 'MAX_ROW_SIZE': '524288',\n 'MEM_LIMIT': '0',\n 'MIN_SPILLABLE_BUFFER_SIZE': '65536',\n 'MT_DOP': '',\n 'NUM_SCANNER_THREADS': '0',\n 'OPTIMIZE_PARTITION_KEY_SCANS': '0',\n 'PARQUET_ANNOTATE_STRINGS_UTF8': '0',\n 'PARQUET_ARRAY_RESOLUTION': '2',\n 'PARQUET_DICTIONARY_FILTERING': '1',\n 'PARQUET_FALLBACK_SCHEMA_RESOLUTION': '0',\n 'PARQUET_FILE_SIZE': '0',\n 'PARQUET_READ_STATISTICS': '1',\n 'PREFETCH_MODE': '1',\n 'QUERY_TIMEOUT_S': '0',\n 'REPLICA_PREFERENCE': '0',\n 'REQUEST_POOL': '',\n 'RUNTIME_BLOOM_FILTER_SIZE': '1048576',\n 'RUNTIME_FILTER_MAX_SIZE': '16777216',\n 'RUNTIME_FILTER_MIN_SIZE': '1048576',\n 'RUNTIME_FILTER_MODE': '2',\n 'RUNTIME_FILTER_WAIT_TIME_MS': '0',\n 'S3_SKIP_INSERT_STAGING': '1',\n 'SCHEDULE_RANDOM_REPLICA': '0',\n 'SCRATCH_LIMIT': '-1',\n 'SEQ_COMPRESSION_MODE': '',\n 'SYNC_DDL': '0'}\nTo enable Snappy compression for Parquet files, you could do either of:\n&gt;&gt;&gt; client.set_options({'COMPRESSION_CODEC': 'snappy'})\n&gt;&gt;&gt; client.set_compression_codec('snappy')\n\n&gt;&gt;&gt; client.get_options()['COMPRESSION_CODEC']\n'SNAPPY'\n\n\n\nOverall interoperability between the Hadoop / Spark ecosystems and pandas / the PyData stack is poor, but it will improve in time (this is a major part of the Ibis roadmap).\nIbis’s Impala tools currently interoperate with pandas in these ways:\n\nIbis expressions return pandas objects (i.e. DataFrame or Series) for non-scalar expressions when calling their to_pandas method\nThe create_table and insert methods can accept pandas objects. This includes inserting into partitioned tables. It currently uses CSV as the ingest route.\n\nFor example:\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; data = pd.DataFrame({'foo': [1, 2, 3, 4], 'bar': ['a', 'b', 'c', 'd']})\n\n&gt;&gt;&gt; db.create_table('pandas_table', data)\n&gt;&gt;&gt; t = db.pandas_table\n&gt;&gt;&gt; t.to_pandas()\n  bar  foo\n0   a    1\n1   b    2\n2   c    3\n3   d    4\n\n&gt;&gt;&gt; t.drop()\n\n&gt;&gt;&gt; db.create_table('empty_for_insert', schema=t.schema())\n\n&gt;&gt;&gt; to_insert = db.empty_for_insert\n&gt;&gt;&gt; to_insert.insert(data)\n&gt;&gt;&gt; to_insert.to_pandas()\n  bar  foo\n0   a    1\n1   b    2\n2   c    3\n3   d    4\n\n&gt;&gt;&gt; to_insert.drop()\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; data = pd.DataFrame({'foo': [1, 2, 3, 4], 'bar': ['a', 'b', 'c', 'd']})\n\n&gt;&gt;&gt; db.create_table('pandas_table', data)\n&gt;&gt;&gt; t = db.pandas_table\n&gt;&gt;&gt; t.to_pandas()\n   foo bar\n0    1   a\n1    2   b\n2    3   c\n3    4   d\n\n&gt;&gt;&gt; t.drop()\n&gt;&gt;&gt; db.create_table('empty_for_insert', schema=t.schema())\n&gt;&gt;&gt; to_insert = db.empty_for_insert\n&gt;&gt;&gt; to_insert.insert(data)\n&gt;&gt;&gt; to_insert.to_pandas()\n   foo bar\n0    1   a\n1    2   b\n2    3   c\n3    4   d\n\n&gt;&gt;&gt; to_insert.drop()\n\n\n\nIf you’ve set up an HDFS connection, you can use the Ibis HDFS interface to look through your data and read and write files to and from HDFS:\n&gt;&gt;&gt; hdfs = con.hdfs\n&gt;&gt;&gt; hdfs.ls('/__ibis/ibis-testing-data')\n['README.md',\n 'avro',\n 'awards_players.csv',\n 'batting.csv',\n 'csv',\n 'diamonds.csv',\n 'functional_alltypes.csv',\n 'functional_alltypes.parquet',\n 'geo.csv',\n 'ibis_testing.db',\n 'parquet',\n 'struct_table.avro',\n 'udf']\n&gt;&gt;&gt; hdfs.ls('/__ibis/ibis-testing-data/parquet')\n['functional_alltypes',\n 'tpch_customer',\n 'tpch_lineitem',\n 'tpch_nation',\n 'tpch_orders',\n 'tpch_part',\n 'tpch_partsupp',\n 'tpch_region',\n 'tpch_supplier']\nSuppose we wanted to download /__ibis/ibis-testing-data/parquet/functional_alltypes, which is a directory. We need only do:\n$ rm -rf parquet_dir/\n&gt;&gt;&gt; hdfs.get('/__ibis/ibis-testing-data/parquet/functional_alltypes',\n...          'parquet_dir',\n...           recursive=True)\n'/ibis/docs/source/tutorial/parquet_dir'\nNow we have that directory locally:\n$ ls parquet_dir/\n9a41de519352ab07-4e76bc4d9fb5a789_1624886651_data.0.parq\n9a41de519352ab07-4e76bc4d9fb5a78a_778826485_data.0.parq\n9a41de519352ab07-4e76bc4d9fb5a78b_1277612014_data.0.parq\nFiles and directories can be written to HDFS just as easily using put:\n&gt;&gt;&gt; path = '/__ibis/dir-write-example'\n&gt;&gt;&gt; hdfs.rm(path, recursive=True)\n&gt;&gt;&gt; hdfs.put(path, 'parquet_dir', recursive=True)\n&gt;&gt;&gt; hdfs.ls('/__ibis/dir-write-example')\n['9a41de519352ab07-4e76bc4d9fb5a789_1624886651_data.0.parq',\n '9a41de519352ab07-4e76bc4d9fb5a78a_778826485_data.0.parq',\n '9a41de519352ab07-4e76bc4d9fb5a78b_1277612014_data.0.parq']\nDelete files and directories with rm:\n&gt;&gt;&gt; hdfs.rm('/__ibis/dir-write-example', recursive=True)\nrm -rf parquet_dir/\n\n\n\nIbis can easily create temporary or persistent Impala tables that reference data in the following formats:\n\nParquet (parquet_file)\nAvro (avro_file)\nDelimited text formats (CSV, TSV, etc.) (delimited_file)\n\nParquet is the easiest because the schema can be read from the data files:\n&gt;&gt;&gt; path = '/__ibis/ibis-testing-data/parquet/tpch_lineitem'\n&gt;&gt;&gt; lineitem = con.parquet_file(path)\n&gt;&gt;&gt; lineitem.limit(2)\n   l_orderkey  l_partkey  l_suppkey  l_linenumber l_quantity l_extendedprice  \\\n0           1     155190       7706             1      17.00        21168.23\n1           1      67310       7311             2      36.00        45983.16\n\n  l_discount l_tax l_returnflag l_linestatus  l_shipdate l_commitdate  \\\n0       0.04  0.02            N            O  1996-03-13   1996-02-12\n1       0.09  0.06            N            O  1996-04-12   1996-02-28\n\n  l_receiptdate     l_shipinstruct l_shipmode  \\\n0    1996-03-22  DELIVER IN PERSON      TRUCK\n1    1996-04-20   TAKE BACK RETURN       MAIL\n\n                            l_comment\n0             egular courts above the\n1  ly final dependencies: slyly bold\n&gt;&gt;&gt; lineitem.l_extendedprice.sum()\nDecimal('229577310901.20')\nIf you want to query a Parquet file and also create a table in Impala that remains after your session, you can pass more information to parquet_file:\n&gt;&gt;&gt; table = con.parquet_file(path, name='my_parquet_table',\n...                          database='ibis_testing',\n...                          persist=True)\n&gt;&gt;&gt; table.l_extendedprice.sum()\nDecimal('229577310901.20')\n&gt;&gt;&gt; con.table('my_parquet_table').l_extendedprice.sum()\nDecimal('229577310901.20')\n&gt;&gt;&gt; con.drop_table('my_parquet_table')\nTo query delimited files, you need to write down an Ibis schema. At some point we’d like to build some helper tools that will infer the schema for you, all in good time.\nThere’s some CSV files in the test folder, so let’s use those:\n&gt;&gt;&gt; hdfs.get('/__ibis/ibis-testing-data/csv', 'csv-files', recursive=True)\n'/ibis/docs/source/tutorial/csv-files'\n$ cat csv-files/0.csv\n63IEbRheTh,0.679388707915,6\nmG4hlqnjeG,2.80710565922,15\nJTPdX9SZH5,-0.155126406372,55\n2jcl6FypOl,1.03787834032,21\nk3TbJLaadQ,-1.40190801103,23\nrP5J4xvinM,-0.442092712869,22\nWniUylixYt,-0.863748033806,27\nznsDuKOB1n,-0.566029637098,47\n4SRP9jlo1M,0.331460412318,88\nKsfjPyDf5e,-0.578930506363,70\n$ rm -rf csv-files/\nThe schema here is pretty simple (see ibis.schema for more):\n&gt;&gt;&gt; schema = ibis.schema([('foo', 'string'),\n...                       ('bar', 'double'),\n...                       ('baz', 'int32')])\n\n&gt;&gt;&gt; table = con.delimited_file('/__ibis/ibis-testing-data/csv',\n...                            schema)\n&gt;&gt;&gt; table.limit(10)\n          foo       bar  baz\n0  63IEbRheTh  0.679389    6\n1  mG4hlqnjeG  2.807106   15\n2  JTPdX9SZH5 -0.155126   55\n3  2jcl6FypOl  1.037878   21\n4  k3TbJLaadQ -1.401908   23\n5  rP5J4xvinM -0.442093   22\n6  WniUylixYt -0.863748   27\n7  znsDuKOB1n -0.566030   47\n8  4SRP9jlo1M  0.331460   88\n9  KsfjPyDf5e -0.578931   70\n&gt;&gt;&gt; table.bar.summary()\n   count  nulls       min       max       sum    mean  approx_nunique\n0    100      0 -1.401908  2.807106  8.479978  0.0848              10\nFor functions like parquet_file and delimited_file, an HDFS directory must be passed (we’ll add support for S3 and other filesystems later) and the directory must contain files all having the same schema.\nIf you have Avro data, you can query it too if you have the full avro schema:\n&gt;&gt;&gt; avro_schema = {\n...     \"fields\": [\n...         {\"type\": [\"int\", \"null\"], \"name\": \"R_REGIONKEY\"},\n...         {\"type\": [\"string\", \"null\"], \"name\": \"R_NAME\"},\n...         {\"type\": [\"string\", \"null\"], \"name\": \"R_COMMENT\"}],\n...     \"type\": \"record\",\n...     \"name\": \"a\"\n... }\n\n&gt;&gt;&gt; path = '/__ibis/ibis-testing-data/avro/tpch.region'\n\n&gt;&gt;&gt; hdfs.mkdir(path, create_parents=True)\n&gt;&gt;&gt; table = con.avro_file(path, avro_schema)\n&gt;&gt;&gt; table\nEmpty DataFrame\nColumns: [r_regionkey, r_name, r_comment]\nIndex: []\n\n\n\nWe’re adding a growing list of useful utility functions for interacting with an Impala cluster on the client object. The idea is that you should be able to do any database-admin-type work with Ibis and not have to switch over to the Impala SQL shell. Any ways we can make this more pleasant, please let us know.\nHere’s some of the features, which we’ll give examples for:\n\nListing and searching for available databases and tables\nCreating and dropping databases\nGetting table schemas\n\n&gt;&gt;&gt; con.list_databases(like='ibis*')\n['ibis_testing', 'ibis_testing_tmp_db']\n&gt;&gt;&gt; con.list_tables(database='ibis_testing', like='tpch*')\n['tpch_customer',\n 'tpch_lineitem',\n 'tpch_nation',\n 'tpch_orders',\n 'tpch_part',\n 'tpch_partsupp',\n 'tpch_region',\n 'tpch_region_avro',\n 'tpch_supplier']\n&gt;&gt;&gt; schema = con.get_schema('functional_alltypes')\n&gt;&gt;&gt; schema\nibis.Schema {\n  id               int32\n  bool_col         boolean\n  tinyint_col      int8\n  smallint_col     int16\n  int_col          int32\n  bigint_col       int64\n  float_col        float32\n  double_col       float64\n  date_string_col  string\n  string_col       string\n  timestamp_col    timestamp\n  year             int32\n  month            int32\n}\nDatabases can be created, too, and you can set the storage path in HDFS you want for the data files\n&gt;&gt;&gt; db = 'ibis_testing2'\n&gt;&gt;&gt; con.create_database(db, path='/__ibis/my-test-database', force=True)\n\n&gt;&gt;&gt; # you may or may not have to give the impala user write and execute permissions to '/__ibis/my-test-database'\n&gt;&gt;&gt; hdfs.chmod('/__ibis/my-test-database', 0o777)\n&gt;&gt;&gt; con.create_table('example_table', con.table('functional_alltypes'),\n...                  database=db, force=True)\nHopefully, there will be data files in the indicated spot in HDFS:\n&gt;&gt;&gt; hdfs.ls('/__ibis/my-test-database')\n['example_table']\nTo drop a database, including all tables in it, you can use drop_database with force=True:\n&gt;&gt;&gt; con.drop_database(db, force=True)\n\n\n\nSince Impala internally uses LLVM to compile parts of queries (aka “codegen”) to make them faster on large data sets there is a certain amount of overhead with running many kinds of queries, even on small datasets. You can disable LLVM code generation when using Ibis, which may significantly speed up queries on smaller datasets:\n&gt;&gt;&gt; from numpy.random import rand\n&gt;&gt;&gt; con.disable_codegen()\n&gt;&gt;&gt; t = con.table('ibis_testing.functional_alltypes')\n$ time python -c \"(t.double_col + rand()).sum().to_pandas()\"\n27.7 ms ± 996 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n# Turn codegen back on\ncon.disable_codegen(False)\n$ time python -c \"(t.double_col + rand()).sum().to_pandas()\"\n27 ms ± 1.62 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\nIt’s important to remember that codegen is a fixed overhead and will significantly speed up queries on big data\n\n\n\nImpala currently supports user-defined scalar functions (known henceforth as UDFs) and aggregate functions (respectively UDAs) via a C++ extension API.\nInitial support for using C++ UDFs in Ibis came in version 0.4.0.\n\n\nLet’s take an example to illustrate how to make a C++ UDF available to Ibis. Here is a function that computes an approximate equality between floating point values:\n#include \"impala_udf/udf.h\"\n\n#include &lt;cctype&gt;\n#include &lt;cmath&gt;\n\nBooleanVal FuzzyEquals(FunctionContext* ctx, const DoubleVal& x, const DoubleVal& y) {\n  const double EPSILON = 0.000001f;\n  if (x.is_null || y.is_null) return BooleanVal::null();\n  double delta = fabs(x.val - y.val);\n  return BooleanVal(delta &lt; EPSILON);\n}\nYou can compile this to either a shared library (a .so file) or to LLVM bitcode with clang (a .ll file). Skipping that step for now (will add some more detailed instructions here later, promise).\nTo make this function callable, we use ibis.impala.wrap_udf:\nlibrary = '/ibis/udfs/udftest.ll'\ninputs = ['double', 'double']\noutput = 'boolean'\nsymbol = 'FuzzyEquals'\nudf_db = 'ibis_testing'\nudf_name = 'fuzzy_equals'\n\nfuzzy_equals = ibis.impala.wrap_udf(\n    library, inputs, output, symbol, name=udf_name\n)\nIn typical workflows, you will set up a UDF in Impala once then use it thenceforth. So the first time you do this, you need to create the UDF in Impala:\nclient.create_function(fuzzy_equals, database=udf_db)\nNow, we must register this function as a new Impala operation in Ibis. This must take place each time you load your Ibis session.\nfunc.register(fuzzy_equals.name, udf_db)\nThe object fuzzy_equals is callable and works with Ibis expressions:\n&gt;&gt;&gt; db = c.database('ibis_testing')\n\n&gt;&gt;&gt; t = db.functional_alltypes\n\n&gt;&gt;&gt; expr = fuzzy_equals(t.float_col, t.double_col / 10)\n\n&gt;&gt;&gt; expr.to_pandas()[:10]\n0     True\n1    False\n2    False\n3    False\n4    False\n5    False\n6    False\n7    False\n8    False\n9    False\nName: tmp, dtype: bool\nNote that the call to register on the UDF object must happen each time you use Ibis. If you have a lot of UDFs, I suggest you create a file with all of your wrapper declarations and user APIs that you load with your Ibis session to plug in all your own functions.\n\n\n\n\nIbis is compatible with Hadoop clusters that are secured with Kerberos (as well as SSL and LDAP). Note that to enable this support, you’ll also need to install the kerberos package.\n$ pip install kerberos\nJust like the Impala shell and ODBC/JDBC connectors, Ibis connects to Impala through the HiveServer2 interface (using the impyla client). Therefore, the connection semantics are similar to the other access methods for working with secure clusters.\nSpecifically, after authenticating yourself against Kerberos (e.g., by issuing the appropriate kinit command), simply pass auth_mechanism='GSSAPI' or auth_mechanism='LDAP' (and set kerberos_service_name if necessary along with user and password if necessary) to the ibis.impala_connect(...) method when instantiating an ImpalaConnection. This method also takes arguments to configure SSL (use_ssl, ca_cert). See the documentation for the Impala shell for more details.\nIbis also includes functionality that communicates directly with HDFS, using the WebHDFS REST API. When calling ibis.impala.hdfs_connect(...), also pass auth_mechanism='GSSAPI' or auth_mechanism='LDAP', and ensure that you are connecting to the correct port, which may likely be an SSL-secured WebHDFS port. Also note that you can pass verify=False to avoid verifying SSL certificates (which may be helpful in testing). Ibis will assume https when connecting to a Kerberized cluster. Because some Ibis commands create HDFS directories as well as new Impala databases and/or tables, your user will require the necessary privileges.\n\n\n\nCloudera CDH ships with HDFS, Impala, Hive and many other components. Sometimes it’s not obvious what default configuration values these tools are using or should be using.\nCheck out this link to see the default configuration values for every component of CDH."
  },
  {
    "objectID": "backends/impala.html#install",
    "href": "backends/impala.html#install",
    "title": "Impala",
    "section": "",
    "text": "Install ibis and dependencies for the Impala backend:\n\npipcondamamba\n\n\npip install 'ibis-framework[impala]'\n\n\nconda install -c conda-forge ibis-impala\n\n\nmamba install -c conda-forge ibis-impala"
  },
  {
    "objectID": "backends/impala.html#connect",
    "href": "backends/impala.html#connect",
    "title": "Impala",
    "section": "",
    "text": "Create a client by passing in connection parameters to ibis.impala.connect.\n\nSee [ibis.backends.impala.Backend.do_connect][ibis.backends.impala.None.do_connect] for connection parameter information. \n\n!!! info “ibis.impala.connect is a thin wrapper around [ibis.backends.impala.Backend.do_connect][ibis.backends.impala.None.do_connect].” \n\n\n\n\n\n\nbackends.impala.Backend.do_connect(self, host='localhost', port=21050, database='default', timeout=45, use_ssl=False, ca_cert=None, user=None, password=None, auth_mechanism='NOSASL', kerberos_service_name='impala', pool_size=8, hdfs_client=None)\nCreate an Impala Backend for use with Ibis.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nhost\nstr\nHost name of the impalad or HiveServer2 in Hive\n'localhost'\n\n\nport\nint\nImpala’s HiveServer2 port\n21050\n\n\ndatabase\nstr\nDefault database when obtaining new cursors\n'default'\n\n\ntimeout\nint\nConnection timeout in seconds when communicating with HiveServer2\n45\n\n\nuse_ssl\nbool\nUse SSL when connecting to HiveServer2\nFalse\n\n\nca_cert\nstr | pathlib.Path | None\nLocal path to 3rd party CA certificate or copy of server certificate for self-signed certificates. If SSL is enabled, but this argument is None, then certificate validation is skipped.\nNone\n\n\nuser\nstr | None\nLDAP user to authenticate\nNone\n\n\npassword\nstr | None\nLDAP password to authenticate\nNone\n\n\nauth_mechanism\ntyping.Literal[‘NOSASL’, ‘PLAIN’, ‘GSSAPI’, ‘LDAP’]\n| Value | Meaning | | :——–: | :—————————– | | 'NOSASL' | insecure Impala connections | | 'PLAIN' | insecure Hive clusters | | 'LDAP' | LDAP authenticated connections | | 'GSSAPI' | Kerberos-secured clusters |\n'NOSASL'\n\n\nkerberos_service_name\nstr\nSpecify a particular impalad service principal.\n'impala'\n\n\npool_size\nint\nSize of the connection pool. Typically this is not necessary to configure.\n8\n\n\nhdfs_client\nfsspec.spec.AbstractFileSystem | None\nAn existing HDFS client.\nNone\n\n\n\n\n\n\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; import ibis\n&gt;&gt;&gt; hdfs_host = os.environ.get('IBIS_TEST_NN_HOST', 'localhost')\n&gt;&gt;&gt; hdfs_port = int(os.environ.get('IBIS_TEST_NN_PORT', 50070))\n&gt;&gt;&gt; impala_host = os.environ.get('IBIS_TEST_IMPALA_HOST', 'localhost')\n&gt;&gt;&gt; impala_port = int(os.environ.get('IBIS_TEST_IMPALA_PORT', 21050))\n&gt;&gt;&gt; hdfs = ibis.impala.hdfs_connect(host=hdfs_host, port=hdfs_port)\n&gt;&gt;&gt; client = ibis.impala.connect(\n...     host=impala_host,\n...     port=impala_port,\n...     hdfs_client=hdfs,\n... )\n&gt;&gt;&gt; client\n&lt;ibis.backends.impala.Backend object at 0x...&gt;\nBoth method calls can take auth_mechanism='GSSAPI' or auth_mechanism='LDAP' to connect to Kerberos clusters. Depending on your cluster setup, this may also include SSL. See the API reference for more, along with the Impala shell reference, as the connection semantics are identical.\nThese methods are available on the Impala client object after connecting to your HDFS cluster (ibis.impala.hdfs_connect) and connecting to Impala with ibis.impala.connect. See backends.impala for a tutorial on using this backend."
  },
  {
    "objectID": "backends/impala.html#database-methods",
    "href": "backends/impala.html#database-methods",
    "title": "Impala",
    "section": "",
    "text": "backends.impala.Backend()\n\n\n\n\n\nName\nDescription\n\n\n\n\ncreate_database\nCreate a new Impala database.\n\n\ndrop_database\nDrop an Impala database.\n\n\nlist_databases\n\n\n\n\n\n\nbackends.impala.Backend.create_database(self, name, path=None, force=False)\nCreate a new Impala database.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\n\nDatabase name\nrequired\n\n\npath\n\nHDFS path where to store the database data; otherwise uses Impala default\nNone\n\n\nforce\n\nForcibly create the database\nFalse\n\n\n\n\n\n\n\nbackends.impala.Backend.drop_database(self, name, force=False)\nDrop an Impala database.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\n\nDatabase name\nrequired\n\n\nforce\n\nIf False and there are any tables in this database, raises an IntegrityError\nFalse\n\n\n\n\n\n\n\nbackends.impala.Backend.list_databases(self, like=None)"
  },
  {
    "objectID": "backends/impala.html#table-methods",
    "href": "backends/impala.html#table-methods",
    "title": "Impala",
    "section": "",
    "text": "The Backend object itself has many helper utility methods. You’ll find the most methods on ImpalaTable.\n\n\nbackends.impala.Backend()\n\n\n\n\n\nName\nDescription\n\n\n\n\ntable\n\n\n\nsql\nConvert a SQL query to an Ibis table expression.\n\n\nraw_sql\nExecute a query string.\n\n\nlist_tables\n\n\n\ndrop_table\nDrop an Impala table.\n\n\ncreate_table\nCreate a new table in Impala using an Ibis table expression.\n\n\ninsert\nInsert data into an existing table.\n\n\ninvalidate_metadata\nIssue an INVALIDATE METADATA command.\n\n\ntruncate_table\nDelete all rows from an existing table.\n\n\nget_schema\nReturn a Schema object for the indicated table and database.\n\n\ncache_table\nCaches a table in cluster memory in the given pool.\n\n\nget_options\nReturn current query options for the Impala session.\n\n\nset_options\n\n\n\nset_compression_codec\n\n\n\n\n\n\nbackends.impala.Backend.table(self, name, database=None, **kwargs)\n\n\n\nbackends.impala.Backend.sql(self, query, schema=None, dialect=None)\nConvert a SQL query to an Ibis table expression.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nSQL string\nrequired\n\n\nschema\nibis.Schema | None\nThe expected schema for this query. If not provided, will be inferred automatically if possible.\nNone\n\n\ndialect\nstr | None\nOptional string indicating the dialect of query. The default value of None will use the backend’s native dialect.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nTable\nTable expression\n\n\n\n\n\n\n\nbackends.impala.Backend.raw_sql(self, query)\nExecute a query string.\n!!! warning “The returned cursor object must be manually released if results are returned.”\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nquery\nstr\nDDL or DML statement\nrequired\n\n\n\n\n\n\n\nbackends.impala.Backend.list_tables(self, like=None, database=None)\n\n\n\nbackends.impala.Backend.drop_table(self, name, *, database=None, force=False)\nDrop an Impala table.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\nforce\nbool\nDatabase may throw exception if table does not exist\nFalse\n\n\n\n\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; db = 'operations'\n&gt;&gt;&gt; con.drop_table(table, database=db, force=True)\n\n\n\n\nbackends.impala.Backend.create_table(self, name, obj=None, *, schema=None, database=None, temp=None, overwrite=False, external=False, format='parquet', location=None, partition=None, like_parquet=None)\nCreate a new table in Impala using an Ibis table expression.\nThis is currently designed for tables whose data is stored in HDFS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\nobj\nibis.Table | None\nIf passed, creates table from select statement results\nNone\n\n\nschema\n\nMutually exclusive with obj, creates an empty table with a particular schema\nNone\n\n\ndatabase\n\nDatabase name\nNone\n\n\ntemp\nbool | None\nWhether a table is temporary\nNone\n\n\noverwrite\nbool\nDo not create table if table with indicated name already exists\nFalse\n\n\nexternal\nbool\nCreate an external table; Impala will not delete the underlying data when the table is dropped\nFalse\n\n\nformat\n\nFile format\n'parquet'\n\n\nlocation\n\nSpecify the directory location where Impala reads and writes files for the table\nNone\n\n\npartition\n\nMust pass a schema to use this. Cannot partition from an expression.\nNone\n\n\nlike_parquet\n\nCan specify instead of a schema\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.insert(self, table_name, obj=None, database=None, overwrite=False, partition=None, values=None, validate=True)\nInsert data into an existing table.\nSee [ImpalaTable.insert][ibis.backends.impala.client.ImpalaTable.insert] for parameters.\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; con.insert(table, table_expr)\nCompletely overwrite contents\n&gt;&gt;&gt; con.insert(table, table_expr, overwrite=True)\n\n\n\n\nbackends.impala.Backend.invalidate_metadata(self, name=None, database=None)\nIssue an INVALIDATE METADATA command.\nOptionally this applies to a specific table. See Impala documentation.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr | None\nTable name. Can be fully qualified (with database)\nNone\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.truncate_table(self, name, database=None)\nDelete all rows from an existing table.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\nbackends.impala.Backend.get_schema(self, table_name, database=None)\nReturn a Schema object for the indicated table and database.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable_name\nstr\nTable name\nrequired\n\n\ndatabase\nstr | None\nDatabase name\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nSchema\nIbis schema\n\n\n\n\n\n\n\nbackends.impala.Backend.cache_table(self, table_name, *, database=None, pool='default')\nCaches a table in cluster memory in the given pool.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntable_name\n\nTable name\nrequired\n\n\ndatabase\n\nDatabase name\nNone\n\n\npool\n\nThe name of the pool in which to cache the table\n'default'\n\n\n\n\n\n\n&gt;&gt;&gt; table = 'my_table'\n&gt;&gt;&gt; db = 'operations'\n&gt;&gt;&gt; pool = 'op_4GB_pool'\n&gt;&gt;&gt; con.cache_table('my_table', database=db, pool=pool)\n\n\n\n\nbackends.impala.Backend.get_options(self)\nReturn current query options for the Impala session.\n\n\n\nbackends.impala.Backend.set_options(self, options)\n\n\n\nbackends.impala.Backend.set_compression_codec(self, codec)\nThe best way to interact with a single table is through the ImpalaTable object you get back from Backend.table.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - add_partition\n        - alter\n        - alter_partition\n        - column_stats\n        - compute_stats\n        - describe_formatted\n        - drop\n        - drop_partition\n        - files\n        - insert\n        - invalidate_metadata\n        - is_partitioned\n        - load_data\n        - metadata\n        - partition_schema\n        - partitions\n        - refresh\n        - rename\n        - schema\n        - stats\n\n&lt;!-- prettier-ignore-end --&gt;"
  },
  {
    "objectID": "backends/impala.html#creating-views",
    "href": "backends/impala.html#creating-views",
    "title": "Impala",
    "section": "",
    "text": "&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - drop_table_or_view\n        - create_view\n\n&lt;!-- prettier-ignore-end --&gt;"
  },
  {
    "objectID": "backends/impala.html#accessing-data-formats-in-hdfs",
    "href": "backends/impala.html#accessing-data-formats-in-hdfs",
    "title": "Impala",
    "section": "",
    "text": "&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - delimited_file\n        - parquet_file\n        - avro_file\n\n&lt;!-- prettier-ignore-end --&gt;"
  },
  {
    "objectID": "backends/impala.html#hdfs-interaction",
    "href": "backends/impala.html#hdfs-interaction",
    "title": "Impala",
    "section": "",
    "text": "Ibis delegates all HDFS interaction to the fsspec library."
  },
  {
    "objectID": "backends/impala.html#the-impala-client-object",
    "href": "backends/impala.html#the-impala-client-object",
    "title": "Impala",
    "section": "",
    "text": "To use Ibis with Impala, you first must connect to a cluster using the ibis.impala.connect function, optionally supplying an HDFS connection:\nimport ibis\n\nhdfs = ibis.impala.hdfs_connect(host=webhdfs_host, port=webhdfs_port)\nclient = ibis.impala.connect(host=impala_host, port=impala_port, hdfs_client=hdfs)\nAll examples here use the following block of code to connect to impala using docker:\nimport ibis\n\nhdfs = ibis.impala.hdfs_connect(host=\"localhost\", port=50070)\nclient = ibis.impala.connect(host=host, hdfs_client=hdfs)\nYou can accomplish many tasks directly through the client object, but we additionally provide APIs to streamline tasks involving a single Impala table or database."
  },
  {
    "objectID": "backends/impala.html#table-objects",
    "href": "backends/impala.html#table-objects",
    "title": "Impala",
    "section": "",
    "text": "&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.base.sql.BaseSQLBackend.table\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\nThe client’s table method allows you to create an Ibis table expression referencing a physical Impala table:\ntable = client.table('functional_alltypes', database='ibis_testing')\nImpalaTable is a Python subclass of the more general Ibis Table that has additional Impala-specific methods. So you can use it interchangeably with any code expecting a Table.\nLike all table expressions in Ibis, ImpalaTable has a schema method you can use to examine its schema:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - schema\n\n&lt;!-- prettier-ignore-end --&gt;\nWhile the client has a drop_table method you can use to drop tables, the table itself has a method drop that you can use:\ntable.drop()"
  },
  {
    "objectID": "backends/impala.html#expression-execution",
    "href": "backends/impala.html#expression-execution",
    "title": "Impala",
    "section": "",
    "text": "Ibis expressions have execution methods like to_pandas that compile and run the expressions on Impala or whichever backend is being referenced.\nFor example:\n&gt;&gt;&gt; fa = db.functional_alltypes\n&gt;&gt;&gt; expr = fa.double_col.sum()\n&gt;&gt;&gt; expr.to_pandas()\n331785.00000000006\nFor longer-running queries, Ibis will attempt to cancel the query in progress if an interrupt is received."
  },
  {
    "objectID": "backends/impala.html#creating-tables",
    "href": "backends/impala.html#creating-tables",
    "title": "Impala",
    "section": "",
    "text": "There are several ways to create new Impala tables:\n\nFrom an Ibis table expression\nEmpty, from a declared schema\nEmpty and partitioned\n\nIn all cases, you should use the create_table method either on the top-level client connection or a database object.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend.create_table\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\n\n\nIf you pass an Ibis expression to create_table, Ibis issues a CREATE TABLE ... AS SELECT (CTAS) statement:\n&gt;&gt;&gt; table = db.table('functional_alltypes')\n&gt;&gt;&gt; expr = table.group_by('string_col').size()\n&gt;&gt;&gt; db.create_table('string_freqs', expr, format='parquet')\n\n&gt;&gt;&gt; freqs = db.table('string_freqs')\n&gt;&gt;&gt; freqs.to_pandas()\n  string_col  count\n0          9    730\n1          3    730\n2          6    730\n3          4    730\n4          1    730\n5          8    730\n6          2    730\n7          7    730\n8          5    730\n9          0    730\n\n&gt;&gt;&gt; files = freqs.files()\n&gt;&gt;&gt; files\n                                                Path  Size Partition\n0  hdfs://impala:8020/user/hive/warehouse/ibis_te...  584B\n\n&gt;&gt;&gt; freqs.drop()\nYou can also choose to create an empty table and use insert (see below).\n\n\n\nTo create an empty table, you must declare an Ibis schema that will be translated to the appropriate Impala schema and data types.\nAs Ibis types are simplified compared with Impala types, this may expand in the future to include a more fine-grained schema declaration.\nYou can use the create_table method either on a database or client object.\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema)\nBy default, this stores the data files in the database default location. You can force a particular path with the location option.\nfrom getpass import getuser\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\nlocation = '/home/{}/new-table-data'.format(getuser())\ndb.create_table(name, schema=schema, location=location)\nIf the schema matches a known table schema, you can always use the schema method to get a schema object:\n&gt;&gt;&gt; t = db.table('functional_alltypes')\n&gt;&gt;&gt; t.schema()\nibis.Schema {\n  id               int32\n  bool_col         boolean\n  tinyint_col      int8\n  smallint_col     int16\n  int_col          int32\n  bigint_col       int64\n  float_col        float32\n  double_col       float64\n  date_string_col  string\n  string_col       string\n  timestamp_col    timestamp\n  year             int32\n  month            int32\n}\n\n\n\nTo create an empty partitioned table, include a list of columns to be used as the partition keys.\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema, partition=['year', 'month'])"
  },
  {
    "objectID": "backends/impala.html#partitioned-tables",
    "href": "backends/impala.html#partitioned-tables",
    "title": "Impala",
    "section": "",
    "text": "Ibis enables you to manage partitioned tables in various ways. Since each partition behaves as its own \"subtable\" sharing a common schema, each partition can have its own file format, directory path, serialization properties, and so forth.\nThere are a handful of table methods for adding and removing partitions and getting information about the partition schema and any existing partition data:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - add_partition\n        - drop_partition\n        - is_partitioned\n        - partition_schema\n        - partitions\n\n&lt;!-- prettier-ignore-end --&gt;\nTo address a specific partition in any method that is partition specific, you can either use a dict with the partition key names and values, or pass a list of the partition values:\nschema = ibis.schema([('foo', 'string'),\n                      ('year', 'int32'),\n                      ('month', 'int16')])\nname = 'new_table'\ndb.create_table(name, schema=schema, partition=['year', 'month'])\n\ntable = db.table(name)\n\ntable.add_partition({'year': 2007, 'month', 4})\ntable.add_partition([2007, 5])\ntable.add_partition([2007, 6])\n\ntable.drop_partition([2007, 6])\nWe’ll cover partition metadata management and data loading below."
  },
  {
    "objectID": "backends/impala.html#inserting-data-into-tables",
    "href": "backends/impala.html#inserting-data-into-tables",
    "title": "Impala",
    "section": "",
    "text": "If the schemas are compatible, you can insert into a table directly from an Ibis table expression:\n&gt;&gt;&gt; t = db.functional_alltypes\n&gt;&gt;&gt; db.create_table('insert_test', schema=t.schema())\n&gt;&gt;&gt; target = db.table('insert_test')\n\n&gt;&gt;&gt; target.insert(t[:3])\n&gt;&gt;&gt; target.insert(t[:3])\n&gt;&gt;&gt; target.insert(t[:3])\n\n&gt;&gt;&gt; target.to_pandas()\n     id  bool_col  tinyint_col  ...           timestamp_col  year  month\n0  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n1  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n2  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n3  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n4  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n5  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n6  5770      True            0  ... 2010-08-01 00:00:00.000  2010      8\n7  5771     False            1  ... 2010-08-01 00:01:00.000  2010      8\n8  5772      True            2  ... 2010-08-01 00:02:00.100  2010      8\n\n[9 rows x 13 columns]\n\n&gt;&gt;&gt; target.drop()\nIf the table is partitioned, you must indicate the partition you are inserting into:\npart = {'year': 2007, 'month': 4}\ntable.insert(expr, partition=part)"
  },
  {
    "objectID": "backends/impala.html#managing-table-metadata",
    "href": "backends/impala.html#managing-table-metadata",
    "title": "Impala",
    "section": "",
    "text": "Ibis has functions that wrap many of the DDL commands for Impala table metadata.\n\n\nTo get a handy wrangled version of DESCRIBE FORMATTED use the metadata method.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable.metadata\n    options:\n      heading_level: 3\n&lt;!-- prettier-ignore-end --&gt;\n&gt;&gt;&gt; t = client.table('ibis_testing.functional_alltypes')\n&gt;&gt;&gt; meta = t.metadata()\n&gt;&gt;&gt; meta\n&lt;class 'ibis.backends.impala.metadata.TableMetadata'&gt;\n{'info': {'CreateTime': datetime.datetime(2021, 1, 14, 21, 23, 8),\n          'Database': 'ibis_testing',\n          'LastAccessTime': 'UNKNOWN',\n          'Location': 'hdfs://impala:8020/__ibis/ibis-testing-data/parquet/functional_alltypes',\n          'Owner': 'root',\n          'Protect Mode': 'None',\n          'Retention': 0,\n          'Table Parameters': {'COLUMN_STATS_ACCURATE': False,\n                               'EXTERNAL': True,\n                               'STATS_GENERATED_VIA_STATS_TASK': True,\n                               'numFiles': 3,\n                               'numRows': 7300,\n                               'rawDataSize': '-1',\n                               'totalSize': 106278,\n                               'transient_lastDdlTime': datetime.datetime(2021, 1, 14, 21, 23, 17)},\n          'Table Type': 'EXTERNAL_TABLE'},\n 'schema': [('id', 'int'),\n            ('bool_col', 'boolean'),\n            ('tinyint_col', 'tinyint'),\n            ('smallint_col', 'smallint'),\n            ('int_col', 'int'),\n            ('bigint_col', 'bigint'),\n            ('float_col', 'float'),\n            ('double_col', 'double'),\n            ('date_string_col', 'string'),\n            ('string_col', 'string'),\n            ('timestamp_col', 'timestamp'),\n            ('year', 'int'),\n            ('month', 'int')],\n 'storage info': {'Bucket Columns': '[]',\n                  'Compressed': False,\n                  'InputFormat': 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat',\n                  'Num Buckets': 0,\n                  'OutputFormat': 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat',\n                  'SerDe Library': 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe',\n                  'Sort Columns': '[]'}}\n\n&gt;&gt;&gt; meta.location\n'hdfs://impala:8020/__ibis/ibis-testing-data/parquet/functional_alltypes'\n\n&gt;&gt;&gt; meta.create_time\ndatetime.datetime(2021, 1, 14, 21, 23, 8)\nThe files function is also available to see all of the physical HDFS data files backing a table:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - files\n\n&lt;!-- prettier-ignore-end --&gt;\n&gt;&gt;&gt; ss = c.table('tpcds_parquet.store_sales')\n\n&gt;&gt;&gt; ss.files()[:5]\n                                                path      size  \\\n0  hdfs://localhost:20500/test-warehouse/tpcds.st...  160.61KB\n1  hdfs://localhost:20500/test-warehouse/tpcds.st...  123.88KB\n2  hdfs://localhost:20500/test-warehouse/tpcds.st...  139.28KB\n3  hdfs://localhost:20500/test-warehouse/tpcds.st...  139.60KB\n4  hdfs://localhost:20500/test-warehouse/tpcds.st...   62.84KB\n\n                 partition\n0  ss_sold_date_sk=2451803\n1  ss_sold_date_sk=2451819\n2  ss_sold_date_sk=2451772\n3  ss_sold_date_sk=2451789\n4  ss_sold_date_sk=2451741\n\n\n\nFor unpartitioned tables, you can use the alter method to change its location, file format, and other properties. For partitioned tables, to change partition-specific metadata use alter_partition.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - alter\n        - alter_partition\n\n&lt;!-- prettier-ignore-end --&gt;\nFor example, if you wanted to \"point\" an existing table at a directory of CSV files, you could run the following command:\nfrom getpass import getuser\n\ncsv_props = {\n    'serialization.format': ',',\n    'field.delim': ',',\n}\ndata_dir = '/home/{}/my-csv-files'.format(getuser())\n\ntable.alter(location=data_dir, format='text', serde_properties=csv_props)\nIf the table is partitioned, you can modify only the properties of a particular partition:\ntable.alter_partition(\n    {'year': 2007, 'month': 5},\n    location=data_dir,\n    format='text',\n    serde_properties=csv_props\n)"
  },
  {
    "objectID": "backends/impala.html#table-statistics",
    "href": "backends/impala.html#table-statistics",
    "title": "Impala",
    "section": "",
    "text": "&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - compute_stats\n\n&lt;!-- prettier-ignore-end --&gt;\nImpala-backed physical tables have a method compute_stats that computes table, column, and partition-level statistics to assist with query planning and optimization. It is standard practice to invoke this after creating a table or loading new data:\ntable.compute_stats()\nIf you are using a recent version of Impala, you can also access the COMPUTE INCREMENTAL STATS DDL command:\ntable.compute_stats(incremental=True)\n\n\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - column_stats\n        - stats\n\n&lt;!-- prettier-ignore-end --&gt;\nThe compute_stats and stats functions return the results of SHOW COLUMN STATS and SHOW TABLE STATS, respectively, and their output will depend, of course, on the last COMPUTE STATS call.\n&gt;&gt;&gt; ss = c.table('tpcds_parquet.store_sales')\n&gt;&gt;&gt; ss.compute_stats(incremental=True)\n&gt;&gt;&gt; stats = ss.stats()\n&gt;&gt;&gt; stats[:5]\n  ss_sold_date_sk  #Rows  #Files     Size Bytes Cached Cache Replication  \\\n0         2450829   1071       1  78.34KB   NOT CACHED        NOT CACHED\n1         2450846    839       1  61.83KB   NOT CACHED        NOT CACHED\n2         2450860    747       1  54.86KB   NOT CACHED        NOT CACHED\n3         2450874    922       1  66.74KB   NOT CACHED        NOT CACHED\n4         2450888    856       1  63.33KB   NOT CACHED        NOT CACHED\n\n    Format Incremental stats  \\\n0  PARQUET              true\n1  PARQUET              true\n2  PARQUET              true\n3  PARQUET              true\n4  PARQUET              true\n\n                                            Location\n0  hdfs://localhost:20500/test-warehouse/tpcds.st...\n1  hdfs://localhost:20500/test-warehouse/tpcds.st...\n2  hdfs://localhost:20500/test-warehouse/tpcds.st...\n3  hdfs://localhost:20500/test-warehouse/tpcds.st...\n4  hdfs://localhost:20500/test-warehouse/tpcds.st...\n\n&gt;&gt;&gt; cstats = ss.column_stats()\n&gt;&gt;&gt; cstats\n                   Column          Type  #Distinct Values  #Nulls  Max Size  Avg Size\n0         ss_sold_time_sk        BIGINT             13879      -1       NaN         8\n1              ss_item_sk        BIGINT             17925      -1       NaN         8\n2          ss_customer_sk        BIGINT             15207      -1       NaN         8\n3             ss_cdemo_sk        BIGINT             16968      -1       NaN         8\n4             ss_hdemo_sk        BIGINT              6220      -1       NaN         8\n5              ss_addr_sk        BIGINT             14077      -1       NaN         8\n6             ss_store_sk        BIGINT                 6      -1       NaN         8\n7             ss_promo_sk        BIGINT               298      -1       NaN         8\n8        ss_ticket_number           INT             15006      -1       NaN         4\n9             ss_quantity           INT                99      -1       NaN         4\n10      ss_wholesale_cost  DECIMAL(7,2)             10196      -1       NaN         4\n11          ss_list_price  DECIMAL(7,2)             19393      -1       NaN         4\n12         ss_sales_price  DECIMAL(7,2)             15594      -1       NaN         4\n13    ss_ext_discount_amt  DECIMAL(7,2)             29772      -1       NaN         4\n14     ss_ext_sales_price  DECIMAL(7,2)            102758      -1       NaN         4\n15  ss_ext_wholesale_cost  DECIMAL(7,2)            125448      -1       NaN         4\n16      ss_ext_list_price  DECIMAL(7,2)            141419      -1       NaN         4\n17             ss_ext_tax  DECIMAL(7,2)             33837      -1       NaN         4\n18          ss_coupon_amt  DECIMAL(7,2)             29772      -1       NaN         4\n19            ss_net_paid  DECIMAL(7,2)            109981      -1       NaN         4\n20    ss_net_paid_inc_tax  DECIMAL(7,2)            132286      -1       NaN         4\n21          ss_net_profit  DECIMAL(7,2)            122436      -1       NaN         4\n22        ss_sold_date_sk        BIGINT               120       0       NaN         8\n\n\n\nThese DDL commands are available as table-level and client-level methods:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - invalidate_metadata\n\n&lt;!-- prettier-ignore-end --&gt;\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - invalidate_metadata\n        - refresh\n\n&lt;!-- prettier-ignore-end --&gt;\nYou can invalidate the cached metadata for a single table or for all tables using invalidate_metadata, and similarly invoke REFRESH db_name.table_name using the refresh method.\nclient.invalidate_metadata()\n\ntable = db.table(table_name)\ntable.invalidate_metadata()\n\ntable.refresh()\nThese methods are often used in conjunction with the LOAD DATA commands and COMPUTE STATS. See the Impala documentation for full details."
  },
  {
    "objectID": "backends/impala.html#issuing-load-data-commands",
    "href": "backends/impala.html#issuing-load-data-commands",
    "title": "Impala",
    "section": "",
    "text": "The LOAD DATA DDL physically moves a single data file or a directory of files into the correct location for a table or table partition. It is especially useful for partitioned tables as you do not have to construct the directory path for a partition by hand, so simpler and less error-prone than manually moving files with low level HDFS commands. It also deals with file name conflicts so data is not lost in such cases.\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - load_data\n\n&lt;!-- prettier-ignore-end --&gt;\n\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.client.ImpalaTable\n    options:\n      heading_level: 3\n      members:\n        - load_data\n\n&lt;!-- prettier-ignore-end --&gt;\nTo use these methods, pass the path of a single file or a directory of files you want to load. Afterward, you may want to update the table statistics (see Impala documentation):\ntable.load_data(path)\ntable.refresh()\nLike the other methods with support for partitioned tables, you can load into a particular partition with the partition keyword argument:\npart = [2007, 5]\ntable.load_data(path, partition=part)"
  },
  {
    "objectID": "backends/impala.html#parquet-and-other-session-options",
    "href": "backends/impala.html#parquet-and-other-session-options",
    "title": "Impala",
    "section": "",
    "text": "Ibis gives you access to Impala session-level variables that affect query execution:\n&lt;!-- prettier-ignore-start --&gt;\n::: ibis.backends.impala.Backend\n    options:\n      heading_level: 3\n      members:\n        - disable_codegen\n        - get_options\n        - set_options\n        - set_compression_codec\n\n&lt;!-- prettier-ignore-end --&gt;\nFor example:\n&gt;&gt;&gt; client.get_options()\n{'ABORT_ON_ERROR': '0',\n 'APPX_COUNT_DISTINCT': '0',\n 'BUFFER_POOL_LIMIT': '',\n 'COMPRESSION_CODEC': '',\n 'COMPUTE_STATS_MIN_SAMPLE_SIZE': '1073741824',\n 'DEFAULT_JOIN_DISTRIBUTION_MODE': '0',\n 'DEFAULT_SPILLABLE_BUFFER_SIZE': '2097152',\n 'DISABLE_CODEGEN': '0',\n 'DISABLE_CODEGEN_ROWS_THRESHOLD': '50000',\n 'DISABLE_ROW_RUNTIME_FILTERING': '0',\n 'DISABLE_STREAMING_PREAGGREGATIONS': '0',\n 'DISABLE_UNSAFE_SPILLS': '0',\n 'ENABLE_EXPR_REWRITES': '1',\n 'EXEC_SINGLE_NODE_ROWS_THRESHOLD': '100',\n 'EXEC_TIME_LIMIT_S': '0',\n 'EXPLAIN_LEVEL': '1',\n 'HBASE_CACHE_BLOCKS': '0',\n 'HBASE_CACHING': '0',\n 'IDLE_SESSION_TIMEOUT': '0',\n 'MAX_ERRORS': '100',\n 'MAX_NUM_RUNTIME_FILTERS': '10',\n 'MAX_ROW_SIZE': '524288',\n 'MEM_LIMIT': '0',\n 'MIN_SPILLABLE_BUFFER_SIZE': '65536',\n 'MT_DOP': '',\n 'NUM_SCANNER_THREADS': '0',\n 'OPTIMIZE_PARTITION_KEY_SCANS': '0',\n 'PARQUET_ANNOTATE_STRINGS_UTF8': '0',\n 'PARQUET_ARRAY_RESOLUTION': '2',\n 'PARQUET_DICTIONARY_FILTERING': '1',\n 'PARQUET_FALLBACK_SCHEMA_RESOLUTION': '0',\n 'PARQUET_FILE_SIZE': '0',\n 'PARQUET_READ_STATISTICS': '1',\n 'PREFETCH_MODE': '1',\n 'QUERY_TIMEOUT_S': '0',\n 'REPLICA_PREFERENCE': '0',\n 'REQUEST_POOL': '',\n 'RUNTIME_BLOOM_FILTER_SIZE': '1048576',\n 'RUNTIME_FILTER_MAX_SIZE': '16777216',\n 'RUNTIME_FILTER_MIN_SIZE': '1048576',\n 'RUNTIME_FILTER_MODE': '2',\n 'RUNTIME_FILTER_WAIT_TIME_MS': '0',\n 'S3_SKIP_INSERT_STAGING': '1',\n 'SCHEDULE_RANDOM_REPLICA': '0',\n 'SCRATCH_LIMIT': '-1',\n 'SEQ_COMPRESSION_MODE': '',\n 'SYNC_DDL': '0'}\nTo enable Snappy compression for Parquet files, you could do either of:\n&gt;&gt;&gt; client.set_options({'COMPRESSION_CODEC': 'snappy'})\n&gt;&gt;&gt; client.set_compression_codec('snappy')\n\n&gt;&gt;&gt; client.get_options()['COMPRESSION_CODEC']\n'SNAPPY'"
  },
  {
    "objectID": "backends/impala.html#ingesting-data-from-pandas",
    "href": "backends/impala.html#ingesting-data-from-pandas",
    "title": "Impala",
    "section": "",
    "text": "Overall interoperability between the Hadoop / Spark ecosystems and pandas / the PyData stack is poor, but it will improve in time (this is a major part of the Ibis roadmap).\nIbis’s Impala tools currently interoperate with pandas in these ways:\n\nIbis expressions return pandas objects (i.e. DataFrame or Series) for non-scalar expressions when calling their to_pandas method\nThe create_table and insert methods can accept pandas objects. This includes inserting into partitioned tables. It currently uses CSV as the ingest route.\n\nFor example:\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; data = pd.DataFrame({'foo': [1, 2, 3, 4], 'bar': ['a', 'b', 'c', 'd']})\n\n&gt;&gt;&gt; db.create_table('pandas_table', data)\n&gt;&gt;&gt; t = db.pandas_table\n&gt;&gt;&gt; t.to_pandas()\n  bar  foo\n0   a    1\n1   b    2\n2   c    3\n3   d    4\n\n&gt;&gt;&gt; t.drop()\n\n&gt;&gt;&gt; db.create_table('empty_for_insert', schema=t.schema())\n\n&gt;&gt;&gt; to_insert = db.empty_for_insert\n&gt;&gt;&gt; to_insert.insert(data)\n&gt;&gt;&gt; to_insert.to_pandas()\n  bar  foo\n0   a    1\n1   b    2\n2   c    3\n3   d    4\n\n&gt;&gt;&gt; to_insert.drop()\n&gt;&gt;&gt; import pandas as pd\n\n&gt;&gt;&gt; data = pd.DataFrame({'foo': [1, 2, 3, 4], 'bar': ['a', 'b', 'c', 'd']})\n\n&gt;&gt;&gt; db.create_table('pandas_table', data)\n&gt;&gt;&gt; t = db.pandas_table\n&gt;&gt;&gt; t.to_pandas()\n   foo bar\n0    1   a\n1    2   b\n2    3   c\n3    4   d\n\n&gt;&gt;&gt; t.drop()\n&gt;&gt;&gt; db.create_table('empty_for_insert', schema=t.schema())\n&gt;&gt;&gt; to_insert = db.empty_for_insert\n&gt;&gt;&gt; to_insert.insert(data)\n&gt;&gt;&gt; to_insert.to_pandas()\n   foo bar\n0    1   a\n1    2   b\n2    3   c\n3    4   d\n\n&gt;&gt;&gt; to_insert.drop()"
  },
  {
    "objectID": "backends/impala.html#uploading-downloading-data-from-hdfs",
    "href": "backends/impala.html#uploading-downloading-data-from-hdfs",
    "title": "Impala",
    "section": "",
    "text": "If you’ve set up an HDFS connection, you can use the Ibis HDFS interface to look through your data and read and write files to and from HDFS:\n&gt;&gt;&gt; hdfs = con.hdfs\n&gt;&gt;&gt; hdfs.ls('/__ibis/ibis-testing-data')\n['README.md',\n 'avro',\n 'awards_players.csv',\n 'batting.csv',\n 'csv',\n 'diamonds.csv',\n 'functional_alltypes.csv',\n 'functional_alltypes.parquet',\n 'geo.csv',\n 'ibis_testing.db',\n 'parquet',\n 'struct_table.avro',\n 'udf']\n&gt;&gt;&gt; hdfs.ls('/__ibis/ibis-testing-data/parquet')\n['functional_alltypes',\n 'tpch_customer',\n 'tpch_lineitem',\n 'tpch_nation',\n 'tpch_orders',\n 'tpch_part',\n 'tpch_partsupp',\n 'tpch_region',\n 'tpch_supplier']\nSuppose we wanted to download /__ibis/ibis-testing-data/parquet/functional_alltypes, which is a directory. We need only do:\n$ rm -rf parquet_dir/\n&gt;&gt;&gt; hdfs.get('/__ibis/ibis-testing-data/parquet/functional_alltypes',\n...          'parquet_dir',\n...           recursive=True)\n'/ibis/docs/source/tutorial/parquet_dir'\nNow we have that directory locally:\n$ ls parquet_dir/\n9a41de519352ab07-4e76bc4d9fb5a789_1624886651_data.0.parq\n9a41de519352ab07-4e76bc4d9fb5a78a_778826485_data.0.parq\n9a41de519352ab07-4e76bc4d9fb5a78b_1277612014_data.0.parq\nFiles and directories can be written to HDFS just as easily using put:\n&gt;&gt;&gt; path = '/__ibis/dir-write-example'\n&gt;&gt;&gt; hdfs.rm(path, recursive=True)\n&gt;&gt;&gt; hdfs.put(path, 'parquet_dir', recursive=True)\n&gt;&gt;&gt; hdfs.ls('/__ibis/dir-write-example')\n['9a41de519352ab07-4e76bc4d9fb5a789_1624886651_data.0.parq',\n '9a41de519352ab07-4e76bc4d9fb5a78a_778826485_data.0.parq',\n '9a41de519352ab07-4e76bc4d9fb5a78b_1277612014_data.0.parq']\nDelete files and directories with rm:\n&gt;&gt;&gt; hdfs.rm('/__ibis/dir-write-example', recursive=True)\nrm -rf parquet_dir/"
  },
  {
    "objectID": "backends/impala.html#queries-on-parquet-avro-and-delimited-files-in-hdfs",
    "href": "backends/impala.html#queries-on-parquet-avro-and-delimited-files-in-hdfs",
    "title": "Impala",
    "section": "",
    "text": "Ibis can easily create temporary or persistent Impala tables that reference data in the following formats:\n\nParquet (parquet_file)\nAvro (avro_file)\nDelimited text formats (CSV, TSV, etc.) (delimited_file)\n\nParquet is the easiest because the schema can be read from the data files:\n&gt;&gt;&gt; path = '/__ibis/ibis-testing-data/parquet/tpch_lineitem'\n&gt;&gt;&gt; lineitem = con.parquet_file(path)\n&gt;&gt;&gt; lineitem.limit(2)\n   l_orderkey  l_partkey  l_suppkey  l_linenumber l_quantity l_extendedprice  \\\n0           1     155190       7706             1      17.00        21168.23\n1           1      67310       7311             2      36.00        45983.16\n\n  l_discount l_tax l_returnflag l_linestatus  l_shipdate l_commitdate  \\\n0       0.04  0.02            N            O  1996-03-13   1996-02-12\n1       0.09  0.06            N            O  1996-04-12   1996-02-28\n\n  l_receiptdate     l_shipinstruct l_shipmode  \\\n0    1996-03-22  DELIVER IN PERSON      TRUCK\n1    1996-04-20   TAKE BACK RETURN       MAIL\n\n                            l_comment\n0             egular courts above the\n1  ly final dependencies: slyly bold\n&gt;&gt;&gt; lineitem.l_extendedprice.sum()\nDecimal('229577310901.20')\nIf you want to query a Parquet file and also create a table in Impala that remains after your session, you can pass more information to parquet_file:\n&gt;&gt;&gt; table = con.parquet_file(path, name='my_parquet_table',\n...                          database='ibis_testing',\n...                          persist=True)\n&gt;&gt;&gt; table.l_extendedprice.sum()\nDecimal('229577310901.20')\n&gt;&gt;&gt; con.table('my_parquet_table').l_extendedprice.sum()\nDecimal('229577310901.20')\n&gt;&gt;&gt; con.drop_table('my_parquet_table')\nTo query delimited files, you need to write down an Ibis schema. At some point we’d like to build some helper tools that will infer the schema for you, all in good time.\nThere’s some CSV files in the test folder, so let’s use those:\n&gt;&gt;&gt; hdfs.get('/__ibis/ibis-testing-data/csv', 'csv-files', recursive=True)\n'/ibis/docs/source/tutorial/csv-files'\n$ cat csv-files/0.csv\n63IEbRheTh,0.679388707915,6\nmG4hlqnjeG,2.80710565922,15\nJTPdX9SZH5,-0.155126406372,55\n2jcl6FypOl,1.03787834032,21\nk3TbJLaadQ,-1.40190801103,23\nrP5J4xvinM,-0.442092712869,22\nWniUylixYt,-0.863748033806,27\nznsDuKOB1n,-0.566029637098,47\n4SRP9jlo1M,0.331460412318,88\nKsfjPyDf5e,-0.578930506363,70\n$ rm -rf csv-files/\nThe schema here is pretty simple (see ibis.schema for more):\n&gt;&gt;&gt; schema = ibis.schema([('foo', 'string'),\n...                       ('bar', 'double'),\n...                       ('baz', 'int32')])\n\n&gt;&gt;&gt; table = con.delimited_file('/__ibis/ibis-testing-data/csv',\n...                            schema)\n&gt;&gt;&gt; table.limit(10)\n          foo       bar  baz\n0  63IEbRheTh  0.679389    6\n1  mG4hlqnjeG  2.807106   15\n2  JTPdX9SZH5 -0.155126   55\n3  2jcl6FypOl  1.037878   21\n4  k3TbJLaadQ -1.401908   23\n5  rP5J4xvinM -0.442093   22\n6  WniUylixYt -0.863748   27\n7  znsDuKOB1n -0.566030   47\n8  4SRP9jlo1M  0.331460   88\n9  KsfjPyDf5e -0.578931   70\n&gt;&gt;&gt; table.bar.summary()\n   count  nulls       min       max       sum    mean  approx_nunique\n0    100      0 -1.401908  2.807106  8.479978  0.0848              10\nFor functions like parquet_file and delimited_file, an HDFS directory must be passed (we’ll add support for S3 and other filesystems later) and the directory must contain files all having the same schema.\nIf you have Avro data, you can query it too if you have the full avro schema:\n&gt;&gt;&gt; avro_schema = {\n...     \"fields\": [\n...         {\"type\": [\"int\", \"null\"], \"name\": \"R_REGIONKEY\"},\n...         {\"type\": [\"string\", \"null\"], \"name\": \"R_NAME\"},\n...         {\"type\": [\"string\", \"null\"], \"name\": \"R_COMMENT\"}],\n...     \"type\": \"record\",\n...     \"name\": \"a\"\n... }\n\n&gt;&gt;&gt; path = '/__ibis/ibis-testing-data/avro/tpch.region'\n\n&gt;&gt;&gt; hdfs.mkdir(path, create_parents=True)\n&gt;&gt;&gt; table = con.avro_file(path, avro_schema)\n&gt;&gt;&gt; table\nEmpty DataFrame\nColumns: [r_regionkey, r_name, r_comment]\nIndex: []"
  },
  {
    "objectID": "backends/impala.html#other-helper-functions-for-interacting-with-the-database",
    "href": "backends/impala.html#other-helper-functions-for-interacting-with-the-database",
    "title": "Impala",
    "section": "",
    "text": "We’re adding a growing list of useful utility functions for interacting with an Impala cluster on the client object. The idea is that you should be able to do any database-admin-type work with Ibis and not have to switch over to the Impala SQL shell. Any ways we can make this more pleasant, please let us know.\nHere’s some of the features, which we’ll give examples for:\n\nListing and searching for available databases and tables\nCreating and dropping databases\nGetting table schemas\n\n&gt;&gt;&gt; con.list_databases(like='ibis*')\n['ibis_testing', 'ibis_testing_tmp_db']\n&gt;&gt;&gt; con.list_tables(database='ibis_testing', like='tpch*')\n['tpch_customer',\n 'tpch_lineitem',\n 'tpch_nation',\n 'tpch_orders',\n 'tpch_part',\n 'tpch_partsupp',\n 'tpch_region',\n 'tpch_region_avro',\n 'tpch_supplier']\n&gt;&gt;&gt; schema = con.get_schema('functional_alltypes')\n&gt;&gt;&gt; schema\nibis.Schema {\n  id               int32\n  bool_col         boolean\n  tinyint_col      int8\n  smallint_col     int16\n  int_col          int32\n  bigint_col       int64\n  float_col        float32\n  double_col       float64\n  date_string_col  string\n  string_col       string\n  timestamp_col    timestamp\n  year             int32\n  month            int32\n}\nDatabases can be created, too, and you can set the storage path in HDFS you want for the data files\n&gt;&gt;&gt; db = 'ibis_testing2'\n&gt;&gt;&gt; con.create_database(db, path='/__ibis/my-test-database', force=True)\n\n&gt;&gt;&gt; # you may or may not have to give the impala user write and execute permissions to '/__ibis/my-test-database'\n&gt;&gt;&gt; hdfs.chmod('/__ibis/my-test-database', 0o777)\n&gt;&gt;&gt; con.create_table('example_table', con.table('functional_alltypes'),\n...                  database=db, force=True)\nHopefully, there will be data files in the indicated spot in HDFS:\n&gt;&gt;&gt; hdfs.ls('/__ibis/my-test-database')\n['example_table']\nTo drop a database, including all tables in it, you can use drop_database with force=True:\n&gt;&gt;&gt; con.drop_database(db, force=True)"
  },
  {
    "objectID": "backends/impala.html#faster-queries-on-small-data-in-impala",
    "href": "backends/impala.html#faster-queries-on-small-data-in-impala",
    "title": "Impala",
    "section": "",
    "text": "Since Impala internally uses LLVM to compile parts of queries (aka “codegen”) to make them faster on large data sets there is a certain amount of overhead with running many kinds of queries, even on small datasets. You can disable LLVM code generation when using Ibis, which may significantly speed up queries on smaller datasets:\n&gt;&gt;&gt; from numpy.random import rand\n&gt;&gt;&gt; con.disable_codegen()\n&gt;&gt;&gt; t = con.table('ibis_testing.functional_alltypes')\n$ time python -c \"(t.double_col + rand()).sum().to_pandas()\"\n27.7 ms ± 996 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n# Turn codegen back on\ncon.disable_codegen(False)\n$ time python -c \"(t.double_col + rand()).sum().to_pandas()\"\n27 ms ± 1.62 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\nIt’s important to remember that codegen is a fixed overhead and will significantly speed up queries on big data"
  },
  {
    "objectID": "backends/impala.html#user-defined-functions-udf",
    "href": "backends/impala.html#user-defined-functions-udf",
    "title": "Impala",
    "section": "",
    "text": "Impala currently supports user-defined scalar functions (known henceforth as UDFs) and aggregate functions (respectively UDAs) via a C++ extension API.\nInitial support for using C++ UDFs in Ibis came in version 0.4.0.\n\n\nLet’s take an example to illustrate how to make a C++ UDF available to Ibis. Here is a function that computes an approximate equality between floating point values:\n#include \"impala_udf/udf.h\"\n\n#include &lt;cctype&gt;\n#include &lt;cmath&gt;\n\nBooleanVal FuzzyEquals(FunctionContext* ctx, const DoubleVal& x, const DoubleVal& y) {\n  const double EPSILON = 0.000001f;\n  if (x.is_null || y.is_null) return BooleanVal::null();\n  double delta = fabs(x.val - y.val);\n  return BooleanVal(delta &lt; EPSILON);\n}\nYou can compile this to either a shared library (a .so file) or to LLVM bitcode with clang (a .ll file). Skipping that step for now (will add some more detailed instructions here later, promise).\nTo make this function callable, we use ibis.impala.wrap_udf:\nlibrary = '/ibis/udfs/udftest.ll'\ninputs = ['double', 'double']\noutput = 'boolean'\nsymbol = 'FuzzyEquals'\nudf_db = 'ibis_testing'\nudf_name = 'fuzzy_equals'\n\nfuzzy_equals = ibis.impala.wrap_udf(\n    library, inputs, output, symbol, name=udf_name\n)\nIn typical workflows, you will set up a UDF in Impala once then use it thenceforth. So the first time you do this, you need to create the UDF in Impala:\nclient.create_function(fuzzy_equals, database=udf_db)\nNow, we must register this function as a new Impala operation in Ibis. This must take place each time you load your Ibis session.\nfunc.register(fuzzy_equals.name, udf_db)\nThe object fuzzy_equals is callable and works with Ibis expressions:\n&gt;&gt;&gt; db = c.database('ibis_testing')\n\n&gt;&gt;&gt; t = db.functional_alltypes\n\n&gt;&gt;&gt; expr = fuzzy_equals(t.float_col, t.double_col / 10)\n\n&gt;&gt;&gt; expr.to_pandas()[:10]\n0     True\n1    False\n2    False\n3    False\n4    False\n5    False\n6    False\n7    False\n8    False\n9    False\nName: tmp, dtype: bool\nNote that the call to register on the UDF object must happen each time you use Ibis. If you have a lot of UDFs, I suggest you create a file with all of your wrapper declarations and user APIs that you load with your Ibis session to plug in all your own functions."
  },
  {
    "objectID": "backends/impala.html#working-with-secure-clusters-kerberos",
    "href": "backends/impala.html#working-with-secure-clusters-kerberos",
    "title": "Impala",
    "section": "",
    "text": "Ibis is compatible with Hadoop clusters that are secured with Kerberos (as well as SSL and LDAP). Note that to enable this support, you’ll also need to install the kerberos package.\n$ pip install kerberos\nJust like the Impala shell and ODBC/JDBC connectors, Ibis connects to Impala through the HiveServer2 interface (using the impyla client). Therefore, the connection semantics are similar to the other access methods for working with secure clusters.\nSpecifically, after authenticating yourself against Kerberos (e.g., by issuing the appropriate kinit command), simply pass auth_mechanism='GSSAPI' or auth_mechanism='LDAP' (and set kerberos_service_name if necessary along with user and password if necessary) to the ibis.impala_connect(...) method when instantiating an ImpalaConnection. This method also takes arguments to configure SSL (use_ssl, ca_cert). See the documentation for the Impala shell for more details.\nIbis also includes functionality that communicates directly with HDFS, using the WebHDFS REST API. When calling ibis.impala.hdfs_connect(...), also pass auth_mechanism='GSSAPI' or auth_mechanism='LDAP', and ensure that you are connecting to the correct port, which may likely be an SSL-secured WebHDFS port. Also note that you can pass verify=False to avoid verifying SSL certificates (which may be helpful in testing). Ibis will assume https when connecting to a Kerberized cluster. Because some Ibis commands create HDFS directories as well as new Impala databases and/or tables, your user will require the necessary privileges."
  },
  {
    "objectID": "backends/impala.html#default-configuration-values-for-cdh-components",
    "href": "backends/impala.html#default-configuration-values-for-cdh-components",
    "title": "Impala",
    "section": "",
    "text": "Cloudera CDH ships with HDFS, Impala, Hive and many other components. Sometimes it’s not obvious what default configuration values these tools are using or should be using.\nCheck out this link to see the default configuration values for every component of CDH."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]